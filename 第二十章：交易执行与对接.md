# ç¬¬äºŒåç« ï¼šäº¤æ˜“æ‰§è¡Œä¸å¯¹æ¥

ğŸ¯ **é€‚åˆäººç¾¤**ï¼šå‡†å¤‡å®ç›˜çš„ç”¨æˆ· | â±ï¸ **å­¦ä¹ å‘¨æœŸ**ï¼š1-2å‘¨

## æœ¬ç« å¯¼è¯»

ç­–ç•¥å›æµ‹æˆåŠŸåï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å¯¹æ¥äº¤æ˜“æ¥å£è¿›è¡Œå®ç›˜äº¤æ˜“ã€‚æœ¬ç« å°†è¯¦ç»†ä»‹ç»QMTå¹³å°çš„å®æˆ˜åº”ç”¨ã€vnpyäº¤æ˜“æ¡†æ¶ï¼Œä»¥åŠäº¤æ˜“æ‰§è¡Œä¼˜åŒ–æŠ€æœ¯ã€‚

**æœ¬ç« å†…å®¹**ï¼š
- ğŸ’¼ 20.1 QMTå¹³å°æ·±åº¦åº”ç”¨
- ğŸ”§ 20.2 vnpyäº¤æ˜“æ¡†æ¶
- âš¡ 20.3 äº¤æ˜“æ‰§è¡Œä¼˜åŒ–

---

## 20.1 QMTå¹³å°æ·±åº¦åº”ç”¨

QMTï¼ˆQuantitative Trading Platformï¼‰æ˜¯è¿…æŠ•ç§‘æŠ€å¼€å‘çš„ä¸“ä¸šé‡åŒ–äº¤æ˜“å¹³å°ã€‚

### â— 20.1.1 QMTåŸºç¡€ä½¿ç”¨

```python
from xtquant import xtdata, xttrader

# 1. åˆå§‹åŒ–äº¤æ˜“æ¥å£
account = xttrader.XtQuantTrader('path/to/userdata', 'session_id')

# 2. è¿æ¥è´¦æˆ·
acc_id = 'è´¦æˆ·ID'
account.connect()

# 3. æŸ¥è¯¢æŒä»“
positions = account.query_stock_positions(acc_id)
for pos in positions:
    print(f"è‚¡ç¥¨: {pos.stock_code}, æŒä»“: {pos.volume}, å¯ç”¨: {pos.can_use_volume}")

# 4. æŸ¥è¯¢èµ„é‡‘
asset = account.query_stock_asset(acc_id)
print(f"æ€»èµ„äº§: {asset.total_asset}")
print(f"å¯ç”¨èµ„é‡‘: {asset.cash}")

# 5. ä¸‹å•
# é™ä»·å•
order_id = account.order_stock(
    acc_id,
    stock_code='600000.SH',
    order_type=xttrader.ORDER_TYPE_LMT,  # é™ä»·å•
    order_volume=100,                     # æ•°é‡ï¼ˆæ‰‹ï¼‰
    price=10.50,                          # ä»·æ ¼
    strategy_name='test_strategy',
    order_remark='æµ‹è¯•ä¸‹å•'
)
print(f"è®¢å•ID: {order_id}")

# 6. æŸ¥è¯¢è®¢å•
orders = account.query_stock_orders(acc_id)
for order in orders:
    print(f"è®¢å•{order.order_id}: {order.stock_code}, "
          f"çŠ¶æ€{order.order_status}, æˆäº¤{order.traded_volume}")

# 7. æ’¤å•
account.cancel_order_stock(acc_id, order_id)
```

### â— 20.1.2 QMTè¡Œæƒ…è®¢é˜…

```python
from xtquant import xtdata

# 1. è®¢é˜…å®æ—¶è¡Œæƒ…
def on_data(datas):
    """è¡Œæƒ…å›è°ƒå‡½æ•°"""
    for stock_code, tick_data in datas.items():
        print(f"{stock_code}: æœ€æ–°ä»·{tick_data['lastPrice']}, "
              f"æˆäº¤é‡{tick_data['volume']}")

# è®¢é˜…
xtdata.subscribe_quote(
    stock_code=['600000.SH', '000001.SZ'],
    period='tick',
    callback=on_data
)

# 2. è·å–å†å²æ•°æ®
# Kçº¿æ•°æ®
kline = xtdata.get_market_data(
    stock_list=['600000.SH'],
    period='1d',
    start_time='20230101',
    end_time='20231231',
    field_list=['open', 'high', 'low', 'close', 'volume']
)

# åˆ†æ—¶æ•°æ®
tick = xtdata.get_market_data(
    stock_list=['600000.SH'],
    period='tick',
    start_time='20231201 09:30:00',
    end_time='20231201 15:00:00'
)

# 3. è·å–è‚¡ç¥¨åˆ—è¡¨
# æ²ªæ·±300æˆåˆ†è‚¡
hs300 = xtdata.get_stock_list_in_sector('æ²ªæ·±300')
print(f"æ²ªæ·±300æˆåˆ†è‚¡æ•°é‡: {len(hs300)}")

# 4. è·å–è´¢åŠ¡æ•°æ®
finance = xtdata.get_financial_data(
    stock_list=['600000.SH'],
    table_list=['Balance', 'Income', 'CashFlow'],
    start_time='20230101',
    end_time='20231231'
)
```

### â— 20.1.3 QMTç­–ç•¥æ¡†æ¶

```python
from xtquant import xttrader
import time

class QMTStrategy:
    """QMTç­–ç•¥åŸºç±»"""

    def __init__(self, account_id, session_path):
        self.account_id = account_id
        self.xt_trader = xttrader.XtQuantTrader(session_path, session_id='')
        self.xt_trader.connect()

        # æ³¨å†Œå›è°ƒ
        self.xt_trader.register_callback(self.on_order_stock_async_response)
        self.xt_trader.register_callback(self.on_trade)

    def on_order_stock_async_response(self, order):
        """å§”æ‰˜å›æŠ¥"""
        print(f"å§”æ‰˜å›æŠ¥: {order.stock_code}, {order.order_status}")

    def on_trade(self, trade):
        """æˆäº¤å›æŠ¥"""
        print(f"æˆäº¤å›æŠ¥: {trade.stock_code}, æˆäº¤ä»·{trade.traded_price}, "
              f"æˆäº¤é‡{trade.traded_volume}")

    def get_positions(self):
        """è·å–æŒä»“"""
        return self.xt_trader.query_stock_positions(self.account_id)

    def get_cash(self):
        """è·å–å¯ç”¨èµ„é‡‘"""
        asset = self.xt_trader.query_stock_asset(self.account_id)
        return asset.cash

    def buy(self, stock_code, price, volume):
        """ä¹°å…¥"""
        order_id = self.xt_trader.order_stock(
            self.account_id,
            stock_code=stock_code,
            order_type=xttrader.ORDER_TYPE_LMT,
            order_volume=volume,
            price=price,
            strategy_name='my_strategy'
        )
        return order_id

    def sell(self, stock_code, price, volume):
        """å–å‡º"""
        order_id = self.xt_trader.order_stock(
            self.account_id,
            stock_code=stock_code,
            order_type=xttrader.ORDER_TYPE_LMT,
            order_volume=-volume,  # è´Ÿæ•°è¡¨ç¤ºå–å‡º
            price=price,
            strategy_name='my_strategy'
        )
        return order_id

    def run(self):
        """ç­–ç•¥ä¸»å¾ªç¯"""
        while True:
            try:
                # ç”Ÿæˆä¿¡å·
                signals = self.generate_signals()

                # æ‰§è¡Œäº¤æ˜“
                self.execute_trades(signals)

                # ç­‰å¾…ä¸‹ä¸€æ¬¡
                time.sleep(60)  # æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡

            except Exception as e:
                print(f"ç­–ç•¥æ‰§è¡Œé”™è¯¯: {e}")

    def generate_signals(self):
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·ï¼ˆå­ç±»å®ç°ï¼‰"""
        raise NotImplementedError

    def execute_trades(self, signals):
        """æ‰§è¡Œäº¤æ˜“ï¼ˆå­ç±»å®ç°ï¼‰"""
        raise NotImplementedError

# ä½¿ç”¨ç¤ºä¾‹
class MyQMTStrategy(QMTStrategy):
    def generate_signals(self):
        # å®ç°ä¿¡å·é€»è¾‘
        return {}

    def execute_trades(self, signals):
        # å®ç°äº¤æ˜“é€»è¾‘
        pass
```

### â— 20.1.4 QMTå¸¸è§é—®é¢˜

**é—®é¢˜1ï¼šè´¦æˆ·è¿æ¥å¤±è´¥**
```python
# è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥è·¯å¾„å’Œè´¦æˆ·çŠ¶æ€
account = xttrader.XtQuantTrader(session_path, '')
result = account.connect()
if result != 0:
    print(f"è¿æ¥å¤±è´¥ï¼Œé”™è¯¯ç : {result}")
    # æ£€æŸ¥miniQMTæ˜¯å¦è¿è¡Œ
    # æ£€æŸ¥session_pathæ˜¯å¦æ­£ç¡®
```

**é—®é¢˜2ï¼šä¸‹å•å¤±è´¥**
```python
# å¸¸è§åŸå› ï¼š
# 1. èµ„é‡‘ä¸è¶³
# 2. è‚¡ç¥¨åœç‰Œæˆ–æ¶¨è·Œåœ
# 3. ä»·æ ¼è¶…å‡ºé™åˆ¶
# 4. æ•°é‡ä¸æ˜¯100çš„æ•´æ•°å€

# å¢åŠ æ£€æŸ¥
cash = account.query_stock_asset(acc_id).cash
price = 10.50
volume = 100
cost = price * volume * 100  # éœ€è¦çš„èµ„é‡‘

if cash >= cost:
    order_id = account.order_stock(...)
else:
    print("èµ„é‡‘ä¸è¶³")
```

---

## 20.2 vnpyäº¤æ˜“æ¡†æ¶

vnpyæ˜¯Pythonç¤¾åŒºæœ€æ´»è·ƒçš„å¼€æºé‡åŒ–äº¤æ˜“æ¡†æ¶ã€‚

### â— 20.2.1 vnpyå®‰è£…ä¸é…ç½®

```bash
# å®‰è£…
pip install vnpy vnpy_ctp vnpy_ctastrategy

# æˆ–ä»æºç å®‰è£…
git clone https://github.com/vnpy/vnpy.git
cd vnpy
pip install -e .
```

### â— 20.2.2 CTAç­–ç•¥å¼€å‘

```python
from vnpy.app.cta_strategy import (
    CtaTemplate,
    StopOrder,
    TickData,
    BarData,
    TradeData,
    OrderData,
    BarGenerator,
    ArrayManager,
)

class DoubleMAStrategy(CtaTemplate):
    """åŒå‡çº¿ç­–ç•¥"""

    author = "Your Name"

    # ç­–ç•¥å‚æ•°
    fast_window = 10
    slow_window = 30
    fixed_size = 1

    # ç­–ç•¥å˜é‡
    fast_ma = 0.0
    slow_ma = 0.0
    ma_trend = 0

    parameters = ["fast_window", "slow_window", "fixed_size"]
    variables = ["fast_ma", "slow_ma", "ma_trend"]

    def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
        """"""
        super().__init__(cta_engine, strategy_name, vt_symbol, setting)

        self.bg = BarGenerator(self.on_bar, 5, self.on_5min_bar)
        self.am = ArrayManager()

    def on_init(self):
        """ç­–ç•¥åˆå§‹åŒ–"""
        self.write_log("ç­–ç•¥åˆå§‹åŒ–")
        self.load_bar(10)  # åŠ è½½10å¤©å†å²æ•°æ®

    def on_start(self):
        """ç­–ç•¥å¯åŠ¨"""
        self.write_log("ç­–ç•¥å¯åŠ¨")

    def on_stop(self):
        """ç­–ç•¥åœæ­¢"""
        self.write_log("ç­–ç•¥åœæ­¢")

    def on_tick(self, tick: TickData):
        """Tickæ•°æ®æ¨é€"""
        self.bg.update_tick(tick)

    def on_bar(self, bar: BarData):
        """1åˆ†é’ŸKçº¿æ¨é€"""
        self.bg.update_bar(bar)

    def on_5min_bar(self, bar: BarData):
        """5åˆ†é’ŸKçº¿æ¨é€"""
        self.cancel_all()

        self.am.update_bar(bar)
        if not self.am.inited:
            return

        # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        fast_ma = self.am.sma(self.fast_window, array=True)
        slow_ma = self.am.sma(self.slow_window, array=True)

        # åˆ¤æ–­äº¤å‰
        cross_over = fast_ma[-1] > slow_ma[-1] and fast_ma[-2] <= slow_ma[-2]
        cross_below = fast_ma[-1] < slow_ma[-1] and fast_ma[-2] >= slow_ma[-2]

        # æ‰§è¡Œäº¤æ˜“
        if cross_over:
            if self.pos == 0:
                self.buy(bar.close_price, self.fixed_size)
            elif self.pos < 0:
                self.cover(bar.close_price, abs(self.pos))
                self.buy(bar.close_price, self.fixed_size)

        elif cross_below:
            if self.pos == 0:
                self.short(bar.close_price, self.fixed_size)
            elif self.pos > 0:
                self.sell(bar.close_price, abs(self.pos))
                self.short(bar.close_price, self.fixed_size)

        # æ›´æ–°å›¾è¡¨
        self.put_event()

    def on_order(self, order: OrderData):
        """è®¢å•çŠ¶æ€æ›´æ–°"""
        pass

    def on_trade(self, trade: TradeData):
        """æˆäº¤ä¿¡æ¯æ¨é€"""
        self.put_event()

    def on_stop_order(self, stop_order: StopOrder):
        """åœæ­¢å•æ¨é€"""
        pass
```

### â— 20.2.3 ç­–ç•¥å›æµ‹

```python
from vnpy.app.cta_strategy.backtesting import BacktestingEngine
from datetime import datetime

# åˆ›å»ºå›æµ‹å¼•æ“
engine = BacktestingEngine()

# è®¾ç½®å›æµ‹å‚æ•°
engine.set_parameters(
    vt_symbol="IF888.CFFEX",
    interval="1m",
    start=datetime(2023, 1, 1),
    end=datetime(2023, 12, 31),
    rate=0.3/10000,  # æ‰‹ç»­è´¹
    slippage=0.2,    # æ»‘ç‚¹
    size=300,        # åˆçº¦å¤§å°
    pricetick=0.2,   # æœ€å°ä»·æ ¼å˜åŠ¨
    capital=1_000_000,
)

# åŠ è½½ç­–ç•¥
engine.add_strategy(DoubleMAStrategy, {})

# åŠ è½½æ•°æ®
engine.load_data()

# è¿è¡Œå›æµ‹
engine.run_backtesting()

# è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
df = engine.calculate_result()
stats = engine.calculate_statistics()

# æ‰“å°ç»“æœ
for key, value in stats.items():
    print(f"{key}: {value}")

# ç»˜åˆ¶å›¾è¡¨
engine.show_chart()
```

---

## 20.3 äº¤æ˜“æ‰§è¡Œä¼˜åŒ–

### â— 20.3.1 è®¢å•ç±»å‹é€‰æ‹©

```python
# 1. å¸‚ä»·å• (Market Order)
# ä¼˜ç‚¹ï¼šæˆäº¤å¿«
# ç¼ºç‚¹ï¼šä»·æ ¼ä¸ç¡®å®šï¼Œå¯èƒ½æ»‘ç‚¹å¤§
order_market = {
    'type': 'MKT',
    'symbol': '600000.SH',
    'volume': 100
}

# 2. é™ä»·å• (Limit Order)
# ä¼˜ç‚¹ï¼šä»·æ ¼ç¡®å®š
# ç¼ºç‚¹ï¼šå¯èƒ½ä¸æˆäº¤
order_limit = {
    'type': 'LMT',
    'symbol': '600000.SH',
    'volume': 100,
    'price': 10.50
}

# 3. æ¡ä»¶å• (Stop Order)
# è§¦å‘æ¡ä»¶åè½¬ä¸ºå¸‚ä»·å•æˆ–é™ä»·å•
order_stop = {
    'type': 'STOP',
    'symbol': '600000.SH',
    'volume': 100,
    'trigger_price': 10.00,
    'order_type': 'MKT'
}

# 4. æ™ºèƒ½è®¢å•
# TWAP: æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼
# VWAP: æˆäº¤é‡åŠ æƒå¹³å‡ä»·æ ¼
# Iceberg: å†°å±±è®¢å•ï¼ˆåˆ†æ‰¹ä¸‹å•ï¼‰
```

### â— 20.3.2 æ»‘ç‚¹æ§åˆ¶

```python
def calculate_slippage(ideal_price, actual_price, direction):
    """
    è®¡ç®—æ»‘ç‚¹

    å‚æ•°:
        ideal_price: ç†æƒ³æˆäº¤ä»·
        actual_price: å®é™…æˆäº¤ä»·
        direction: 'buy' or 'sell'
    """
    if direction == 'buy':
        slippage = actual_price - ideal_price
    else:
        slippage = ideal_price - actual_price

    slippage_pct = slippage / ideal_price
    return slippage, slippage_pct

# æ»‘ç‚¹æ§åˆ¶ç­–ç•¥
class SlippageControl:
    """æ»‘ç‚¹æ§åˆ¶å™¨"""

    def __init__(self, max_slippage=0.002):
        self.max_slippage = max_slippage

    def adjust_price(self, target_price, direction, market_data):
        """
        è°ƒæ•´ä¸‹å•ä»·æ ¼ä»¥æ§åˆ¶æ»‘ç‚¹

        ç­–ç•¥ï¼š
        1. å¦‚æœæ˜¯ä¹°å…¥ï¼ŒæŒ‚å•ä»·ç•¥é«˜äºç›®æ ‡ä»·
        2. å¦‚æœæ˜¯å–å‡ºï¼ŒæŒ‚å•ä»·ç•¥ä½äºç›®æ ‡ä»·
        3. ä½†ä¸è¶…è¿‡æœ€å¤§æ»‘ç‚¹é™åˆ¶
        """
        if direction == 'buy':
            # ä¹°å…¥æ—¶ï¼ŒæŒ‚é«˜ä¸€ç‚¹å¢åŠ æˆäº¤æ¦‚ç‡
            adjusted_price = target_price * (1 + self.max_slippage * 0.5)
            # ä½†ä¸è¶…è¿‡å–ä¸€ä»·
            adjusted_price = min(adjusted_price, market_data['ask1'])
        else:
            # å–å‡ºæ—¶ï¼ŒæŒ‚ä½ä¸€ç‚¹
            adjusted_price = target_price * (1 - self.max_slippage * 0.5)
            # ä½†ä¸ä½äºä¹°ä¸€ä»·
            adjusted_price = max(adjusted_price, market_data['bid1'])

        return round(adjusted_price, 2)
```

### â— 20.3.3 TWAPç®—æ³•

```python
import time
from datetime import datetime, timedelta

class TWAPExecutor:
    """TWAPæ‰§è¡Œç®—æ³•"""

    def __init__(self, total_volume, duration_minutes, interval_seconds=60):
        """
        å‚æ•°:
            total_volume: æ€»äº¤æ˜“é‡
            duration_minutes: æ€»æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
            interval_seconds: ä¸‹å•é—´éš”ï¼ˆç§’ï¼‰
        """
        self.total_volume = total_volume
        self.duration = duration_minutes * 60  # è½¬ä¸ºç§’
        self.interval = interval_seconds

        # è®¡ç®—æ¯æ¬¡ä¸‹å•é‡
        self.num_orders = int(self.duration / self.interval)
        self.volume_per_order = total_volume / self.num_orders

    def execute(self, trader, symbol, direction):
        """
        æ‰§è¡ŒTWAP

        å‚æ•°:
            trader: äº¤æ˜“æ¥å£
            symbol: è‚¡ç¥¨ä»£ç 
            direction: 'buy' or 'sell'
        """
        remaining_volume = self.total_volume
        start_time = datetime.now()

        for i in range(self.num_orders):
            # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if (datetime.now() - start_time).seconds > self.duration:
                break

            # è®¡ç®—æœ¬æ¬¡ä¸‹å•é‡
            if i == self.num_orders - 1:
                # æœ€åä¸€æ¬¡ï¼Œä¸‹å®Œå‰©ä½™çš„
                volume = remaining_volume
            else:
                volume = int(self.volume_per_order)

            # è·å–æœ€æ–°ä»·æ ¼
            tick = trader.get_tick(symbol)
            if direction == 'buy':
                price = tick['ask1']
            else:
                price = tick['bid1']

            # ä¸‹å•
            if direction == 'buy':
                order_id = trader.buy(symbol, price, volume)
            else:
                order_id = trader.sell(symbol, price, volume)

            print(f"ç¬¬{i+1}æ¬¡ä¸‹å•: {volume}è‚¡ @ {price}")

            # æ›´æ–°å‰©ä½™é‡
            remaining_volume -= volume

            # ç­‰å¾…ä¸‹ä¸€æ¬¡
            if i < self.num_orders - 1:
                time.sleep(self.interval)

# ä½¿ç”¨ç¤ºä¾‹
executor = TWAPExecutor(
    total_volume=10000,      # æ€»å…±è¦ä¹°10000è‚¡
    duration_minutes=30,      # 30åˆ†é’Ÿå†…å®Œæˆ
    interval_seconds=60       # æ¯60ç§’ä¸‹ä¸€æ¬¡å•
)
# executor.execute(trader, '600000.SH', 'buy')
```

### â— 20.3.4 å»¶è¿Ÿä¼˜åŒ–

```python
"""
é™ä½äº¤æ˜“å»¶è¿Ÿçš„æ–¹æ³•
"""

# 1. ä½¿ç”¨æœ¬åœ°è¡Œæƒ…æº
# é¿å…è¿œç¨‹APIè°ƒç”¨å»¶è¿Ÿ

# 2. é¢„å…ˆè®¡ç®—
# åœ¨éäº¤æ˜“æ—¶æ®µè®¡ç®—å¥½ä¿¡å·ï¼Œäº¤æ˜“æ—¶æ®µåªéœ€æ‰§è¡Œ

# 3. å¼‚æ­¥ä¸‹å•
import asyncio

async def async_order(trader, symbol, price, volume):
    """å¼‚æ­¥ä¸‹å•"""
    loop = asyncio.get_event_loop()
    order_id = await loop.run_in_executor(
        None,
        trader.buy,
        symbol, price, volume
    )
    return order_id

# 4. æ‰¹é‡æ“ä½œ
def batch_orders(trader, orders):
    """æ‰¹é‡ä¸‹å•"""
    order_ids = []
    for order in orders:
        order_id = trader.order(
            symbol=order['symbol'],
            price=order['price'],
            volume=order['volume'],
            direction=order['direction']
        )
        order_ids.append(order_id)
    return order_ids

# 5. ä½¿ç”¨æ›´å¿«çš„æ•°æ®ç»“æ„
# ä¾‹å¦‚ï¼šç”¨numpyæ•°ç»„ä»£æ›¿pandas DataFrameè¿›è¡Œè®¡ç®—

# 6. ä»£ç ä¼˜åŒ–
# - é¿å…å¾ªç¯ä¸­çš„é‡å¤è®¡ç®—
# - ä½¿ç”¨å‘é‡åŒ–æ“ä½œ
# - é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ç­‰
```

---

## æœ¬ç« å°ç»“

æœ¬ç« ä»‹ç»äº†å®ç›˜äº¤æ˜“çš„å…³é”®æŠ€æœ¯ï¼š

### ğŸ“š æ ¸å¿ƒè¦ç‚¹

1. **QMTå¹³å°**
   - ä¸“ä¸šçš„Aè‚¡é‡åŒ–å¹³å°
   - æ”¯æŒè¡Œæƒ…è®¢é˜…å’Œç¨‹åºåŒ–äº¤æ˜“
   - é€‚åˆåˆ¸å•†é€šé“äº¤æ˜“

2. **vnpyæ¡†æ¶**
   - å¼€æºè·¨å¹³å°æ¡†æ¶
   - ä¸°å¯Œçš„ç­–ç•¥æ¨¡æ¿
   - æ”¯æŒæœŸè´§ã€è‚¡ç¥¨ç­‰å¤šå¸‚åœº

3. **äº¤æ˜“æ‰§è¡Œä¼˜åŒ–**
   - é€‰æ‹©åˆé€‚çš„è®¢å•ç±»å‹
   - æ§åˆ¶æ»‘ç‚¹æˆæœ¬
   - ä½¿ç”¨TWAPç­‰æ™ºèƒ½ç®—æ³•
   - ä¼˜åŒ–ç³»ç»Ÿå»¶è¿Ÿ

### âš ï¸ æ³¨æ„äº‹é¡¹

1. **å®ç›˜å‰å……åˆ†æµ‹è¯•**
   - å…ˆæ¨¡æ‹Ÿç›˜éªŒè¯
   - å°èµ„é‡‘è¯•é”™
   - ç›‘æ§æ‰§è¡Œåå·®

2. **é£é™©æ§åˆ¶**
   - è®¾ç½®æ­¢æŸ
   - é™åˆ¶å•æ—¥æœ€å¤§äº¤æ˜“é‡
   - å¼‚å¸¸æƒ…å†µè‡ªåŠ¨åœæ­¢

3. **åˆè§„äº¤æ˜“**
   - éµå®ˆäº¤æ˜“æ‰€è§„åˆ™
   - é¿å…å¼‚å¸¸äº¤æ˜“
   - ä¿ç•™å®Œæ•´æ—¥å¿—

---

*æœ¬ç« å®Œ*
