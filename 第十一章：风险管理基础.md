# ç¬¬åä¸€ç« ï¼šé£é™©ç®¡ç†åŸºç¡€ ğŸ›¡ï¸

> ğŸ’¡ **æœ¬ç« å¯¼è¯»**ï¼šé£é™©ç®¡ç†æ˜¯é‡åŒ–äº¤æ˜“çš„ç”Ÿå‘½çº¿ã€‚å†å¥½çš„ç­–ç•¥ï¼Œå¦‚æœæ²¡æœ‰å®Œå–„çš„é£é™©ç®¡ç†ï¼Œä¹Ÿå¯èƒ½å¯¼è‡´é‡å¤§æŸå¤±ã€‚æœ¬ç« å°†ç³»ç»Ÿä»‹ç»é£é™©ç®¡ç†çš„æ ¸å¿ƒæ¦‚å¿µã€ä»“ä½ç®¡ç†æ–¹æ³•ã€æ­¢æŸæ­¢ç›ˆæŠ€å·§ä»¥åŠå›æ’¤æ§åˆ¶ç­–ç•¥ã€‚

---

## 11.1 é£é™©ç®¡ç†æ ¸å¿ƒæ¦‚å¿µ ğŸ“Š

### 11.1.1 ä¸ºä»€ä¹ˆé£é™©ç®¡ç†å¦‚æ­¤é‡è¦ï¼Ÿ

**é‡åŒ–äº¤æ˜“çš„ä¸¤å¤§æ”¯æŸ±**ï¼š
1. **ç­–ç•¥ä¼˜åŠ¿**ï¼šæ‰¾åˆ°ç›ˆåˆ©æœºä¼š
2. **é£é™©ç®¡ç†**ï¼šä¿æŠ¤èµ„é‡‘å®‰å…¨

å³ä½¿ç­–ç•¥æœ‰æ­£æœŸæœ›æ”¶ç›Šï¼Œå¦‚æœé£é™©ç®¡ç†ä¸å½“ï¼Œä¹Ÿå¯èƒ½é¢ä¸´ï¼š
- **çˆ†ä»“é£é™©**ï¼šå•æ¬¡æˆ–è¿ç»­äºæŸå¯¼è‡´è´¦æˆ·å½’é›¶
- **å›æ’¤è¿‡å¤§**ï¼šèµ„é‡‘å¤§å¹…ç¼©æ°´ï¼Œå¿ƒç†å‹åŠ›å·¨å¤§
- **é”™å¤±æœºä¼š**ï¼šå› ä¸ºå‰æœŸæŸå¤±è¿‡å¤§ï¼Œæ— æ³•æŠŠæ¡åç»­ç›ˆåˆ©æœºä¼š

### 11.1.2 é£é™©çš„åˆ†ç±»

| é£é™©ç±»å‹ | æè¿° | åº”å¯¹æªæ–½ |
|---------|------|---------|
| **å¸‚åœºé£é™©** | å¸‚åœºæ•´ä½“æ³¢åŠ¨å¯¼è‡´çš„æŸå¤± | åˆ†æ•£æŠ•èµ„ã€å¯¹å†²ã€ä»“ä½æ§åˆ¶ |
| **æµåŠ¨æ€§é£é™©** | æ— æ³•åŠæ—¶ä»¥åˆç†ä»·æ ¼æˆäº¤ | é€‰æ‹©æµåŠ¨æ€§å¥½çš„å“ç§ã€æ§åˆ¶å•ç¬”è§„æ¨¡ |
| **æ¨¡å‹é£é™©** | ç­–ç•¥å¤±æ•ˆã€è¿‡æ‹Ÿåˆç­‰ | ä¸¥æ ¼å›æµ‹ã€æ ·æœ¬å¤–éªŒè¯ã€å®šæœŸè¯„ä¼° |
| **æŠ€æœ¯é£é™©** | ç³»ç»Ÿæ•…éšœã€ç½‘ç»œä¸­æ–­ç­‰ | å®¹é”™è®¾è®¡ã€å¤‡ç”¨ç³»ç»Ÿã€äººå·¥ç›‘æ§ |
| **æ“ä½œé£é™©** | äººä¸ºé”™è¯¯ã€å‚æ•°è®¾ç½®å¤±è¯¯ | è‡ªåŠ¨åŒ–ã€å¤æ ¸æœºåˆ¶ã€æƒé™ç®¡ç† |
| **é»‘å¤©é¹…é£é™©** | å°æ¦‚ç‡æç«¯äº‹ä»¶ | é¢„ç•™é£é™©å‡†å¤‡é‡‘ã€æç«¯æƒ…å†µåº”æ€¥é¢„æ¡ˆ |

### 11.1.3 é£é™©åº¦é‡æŒ‡æ ‡

#### 1. æ³¢åŠ¨ç‡ (Volatility)

```python
import pandas as pd
import numpy as np

def calculate_volatility(returns, period=252):
    """
    è®¡ç®—æ³¢åŠ¨ç‡

    å‚æ•°:
    returns: Series, æ”¶ç›Šç‡åºåˆ—
    period: int, å¹´åŒ–å‘¨æœŸ(é»˜è®¤252ä¸ªäº¤æ˜“æ—¥)

    è¿”å›:
    dict: åŒ…å«æ—¥æ³¢åŠ¨ç‡å’Œå¹´åŒ–æ³¢åŠ¨ç‡
    """
    daily_vol = returns.std()
    annual_vol = daily_vol * np.sqrt(period)

    return {
        'daily_volatility': daily_vol,
        'annual_volatility': annual_vol
    }

# ç¤ºä¾‹ä½¿ç”¨
# å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ”¶ç›Šç‡åºåˆ—
np.random.seed(42)
returns = pd.Series(np.random.randn(252) * 0.01)  # æ¨¡æ‹Ÿæ—¥æ”¶ç›Šç‡

vol = calculate_volatility(returns)
print(f"æ—¥æ³¢åŠ¨ç‡: {vol['daily_volatility']:.4f}")
print(f"å¹´åŒ–æ³¢åŠ¨ç‡: {vol['annual_volatility']:.4f}")
```

#### 2. VaR (Value at Risk) - é£é™©ä»·å€¼

VaRè¡¨ç¤ºåœ¨ç»™å®šç½®ä¿¡æ°´å¹³ä¸‹ï¼ŒæŸä¸€æ—¶æœŸå†…å¯èƒ½é­å—çš„æœ€å¤§æŸå¤±ã€‚

```python
def calculate_var(returns, confidence_level=0.95, method='historical'):
    """
    è®¡ç®—VaR

    å‚æ•°:
    returns: Series, æ”¶ç›Šç‡åºåˆ—
    confidence_level: float, ç½®ä¿¡æ°´å¹³(é»˜è®¤95%)
    method: str, è®¡ç®—æ–¹æ³•('historical', 'parametric')

    è¿”å›:
    float: VaRå€¼(è´Ÿæ•°è¡¨ç¤ºæŸå¤±)
    """
    if method == 'historical':
        # å†å²æ¨¡æ‹Ÿæ³•
        var = np.percentile(returns, (1 - confidence_level) * 100)
    elif method == 'parametric':
        # å‚æ•°æ³•(å‡è®¾æ­£æ€åˆ†å¸ƒ)
        mean = returns.mean()
        std = returns.std()
        z_score = np.abs(np.percentile(np.random.randn(10000), (1 - confidence_level) * 100))
        var = mean - z_score * std
    else:
        raise ValueError("method must be 'historical' or 'parametric'")

    return var

# ç¤ºä¾‹
var_95 = calculate_var(returns, confidence_level=0.95, method='historical')
var_99 = calculate_var(returns, confidence_level=0.99, method='historical')

print(f"95% VaR: {var_95:.4f} (æœ‰95%çš„æŠŠæ¡,æŸå¤±ä¸ä¼šè¶…è¿‡{abs(var_95):.2%})")
print(f"99% VaR: {var_99:.4f} (æœ‰99%çš„æŠŠæ¡,æŸå¤±ä¸ä¼šè¶…è¿‡{abs(var_99):.2%})")
```

#### 3. CVaR (Conditional VaR) - æ¡ä»¶é£é™©ä»·å€¼

CVaRä¹Ÿå«æœŸæœ›çŸ­ç¼º(Expected Shortfall)ï¼Œè¡¨ç¤ºåœ¨è¶…è¿‡VaRçš„æƒ…å†µä¸‹ï¼Œå¹³å‡æŸå¤±æ˜¯å¤šå°‘ã€‚

```python
def calculate_cvar(returns, confidence_level=0.95):
    """
    è®¡ç®—CVaR

    å‚æ•°:
    returns: Series, æ”¶ç›Šç‡åºåˆ—
    confidence_level: float, ç½®ä¿¡æ°´å¹³

    è¿”å›:
    float: CVaRå€¼
    """
    var = calculate_var(returns, confidence_level, method='historical')
    # CVaRæ˜¯æ‰€æœ‰å°äºVaRçš„æ”¶ç›Šç‡çš„å¹³å‡å€¼
    cvar = returns[returns <= var].mean()
    return cvar

# ç¤ºä¾‹
cvar_95 = calculate_cvar(returns, 0.95)
print(f"95% CVaR: {cvar_95:.4f} (è¶…è¿‡VaRæ—¶,å¹³å‡æŸå¤±ä¸º{abs(cvar_95):.2%})")
```

### 11.1.4 é£é™©ç®¡ç†çš„é»„é‡‘æ³•åˆ™

1. **æ°¸è¿œä¸è¦å­¤æ³¨ä¸€æ·**ï¼šå•ä¸ªäº¤æ˜“ä¸åº”æ‰¿æ‹…è¿‡å¤§é£é™©
2. **æ§åˆ¶æ€»ä½“é£é™©æ•å£**ï¼šæ‰€æœ‰å¤´å¯¸çš„æ€»é£é™©è¦åœ¨å¯æ‰¿å—èŒƒå›´å†…
3. **åˆ†æ•£æŠ•èµ„**ï¼šä¸è¦æŠŠæ‰€æœ‰é¸¡è›‹æ”¾åœ¨ä¸€ä¸ªç¯®å­é‡Œ
4. **ä¸¥æ ¼æ­¢æŸ**ï¼šè®¾å®šå¹¶æ‰§è¡Œæ­¢æŸè§„åˆ™
5. **ä¿æŒæµåŠ¨æ€§**ï¼šé¢„ç•™è¶³å¤Ÿçš„ç°é‡‘æˆ–æµåŠ¨èµ„äº§
6. **æŒç»­ç›‘æ§**ï¼šå®æ—¶è·Ÿè¸ªé£é™©æŒ‡æ ‡
7. **å‹åŠ›æµ‹è¯•**ï¼šå®šæœŸè¿›è¡Œæç«¯æƒ…å†µæ¨¡æ‹Ÿ

---

## 11.2 ä»“ä½ç®¡ç†æ–¹æ³• ğŸ’°

ä»“ä½ç®¡ç†å†³å®šäº†æ¯æ¬¡äº¤æ˜“æŠ•å…¥å¤šå°‘èµ„é‡‘ï¼Œæ˜¯é£é™©ç®¡ç†çš„æ ¸å¿ƒç¯èŠ‚ã€‚

### 11.2.1 å›ºå®šé‡‘é¢æ³•

**åŸç†**ï¼šæ¯æ¬¡äº¤æ˜“æŠ•å…¥å›ºå®šé‡‘é¢ï¼Œæ— è®ºè´¦æˆ·æ€»èµ„é‡‘å¤šå°‘ã€‚

```python
class FixedAmountPositionSizing:
    """å›ºå®šé‡‘é¢ä»“ä½ç®¡ç†"""

    def __init__(self, fixed_amount):
        """
        å‚æ•°:
        fixed_amount: float, æ¯æ¬¡äº¤æ˜“çš„å›ºå®šé‡‘é¢
        """
        self.fixed_amount = fixed_amount

    def calculate_position(self, account_value, price):
        """
        è®¡ç®—ä»“ä½

        å‚æ•°:
        account_value: float, è´¦æˆ·æ€»èµ„äº§
        price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        int: å¯ä¹°å…¥çš„è‚¡æ•°
        """
        shares = int(self.fixed_amount / price)
        return shares

# ç¤ºä¾‹
position_sizer = FixedAmountPositionSizing(fixed_amount=10000)
account_value = 100000
price = 50

shares = position_sizer.calculate_position(account_value, price)
print(f"å›ºå®šé‡‘é¢æ³•: ä»¥{price}å…ƒä»·æ ¼ä¹°å…¥{shares}è‚¡")
print(f"å®é™…æŠ•å…¥: {shares * price}å…ƒ")
```

**ä¼˜ç‚¹**ï¼š
- ç®€å•æ˜“æ‡‚
- é£é™©å›ºå®š

**ç¼ºç‚¹**ï¼š
- ä¸éšè´¦æˆ·è§„æ¨¡è°ƒæ•´
- è´¦æˆ·å¢é•¿æ—¶ï¼Œç›¸å¯¹é£é™©å˜å°ï¼›è´¦æˆ·ç¼©æ°´æ—¶ï¼Œç›¸å¯¹é£é™©å˜å¤§

### 11.2.2 å›ºå®šæ¯”ä¾‹æ³•

**åŸç†**ï¼šæ¯æ¬¡äº¤æ˜“æŠ•å…¥è´¦æˆ·æ€»èµ„é‡‘çš„å›ºå®šæ¯”ä¾‹ã€‚

```python
class FixedPercentagePositionSizing:
    """å›ºå®šæ¯”ä¾‹ä»“ä½ç®¡ç†"""

    def __init__(self, percentage):
        """
        å‚æ•°:
        percentage: float, æŠ•å…¥æ¯”ä¾‹(0-1ä¹‹é—´)
        """
        self.percentage = percentage

    def calculate_position(self, account_value, price):
        """
        è®¡ç®—ä»“ä½

        å‚æ•°:
        account_value: float, è´¦æˆ·æ€»èµ„äº§
        price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        int: å¯ä¹°å…¥çš„è‚¡æ•°
        """
        amount = account_value * self.percentage
        shares = int(amount / price)
        return shares

# ç¤ºä¾‹
position_sizer = FixedPercentagePositionSizing(percentage=0.2)  # æ¯æ¬¡æŠ•å…¥20%

shares = position_sizer.calculate_position(account_value, price)
print(f"å›ºå®šæ¯”ä¾‹æ³•(20%): ä»¥{price}å…ƒä»·æ ¼ä¹°å…¥{shares}è‚¡")
print(f"å®é™…æŠ•å…¥: {shares * price}å…ƒ, å æ¯”: {shares * price / account_value:.2%}")
```

**ä¼˜ç‚¹**ï¼š
- è‡ªåŠ¨éšè´¦æˆ·è§„æ¨¡è°ƒæ•´
- é£é™©ç›¸å¯¹ç¨³å®š

**ç¼ºç‚¹**ï¼š
- ä¸è€ƒè™‘ä¸åŒå“ç§çš„æ³¢åŠ¨æ€§å·®å¼‚
- ä¸è€ƒè™‘ç­–ç•¥çš„èƒœç‡å’Œç›ˆäºæ¯”

### 11.2.3 æ³¢åŠ¨ç‡è°ƒæ•´æ³•

**åŸç†**ï¼šæ ¹æ®æ ‡çš„æ³¢åŠ¨ç‡è°ƒæ•´ä»“ä½ï¼Œæ³¢åŠ¨ç‡è¶Šé«˜ï¼Œä»“ä½è¶Šå°ã€‚

```python
class VolatilityAdjustedPositionSizing:
    """æ³¢åŠ¨ç‡è°ƒæ•´ä»“ä½ç®¡ç†"""

    def __init__(self, target_volatility, max_percentage=0.3):
        """
        å‚æ•°:
        target_volatility: float, ç›®æ ‡æ³¢åŠ¨ç‡(å¹´åŒ–)
        max_percentage: float, æœ€å¤§ä»“ä½æ¯”ä¾‹
        """
        self.target_volatility = target_volatility
        self.max_percentage = max_percentage

    def calculate_position(self, account_value, price, asset_volatility):
        """
        è®¡ç®—ä»“ä½

        å‚æ•°:
        account_value: float, è´¦æˆ·æ€»èµ„äº§
        price: float, å½“å‰ä»·æ ¼
        asset_volatility: float, æ ‡çš„å¹´åŒ–æ³¢åŠ¨ç‡

        è¿”å›:
        int: å¯ä¹°å…¥çš„è‚¡æ•°
        """
        # ä»“ä½æ¯”ä¾‹ = ç›®æ ‡æ³¢åŠ¨ç‡ / æ ‡çš„æ³¢åŠ¨ç‡
        percentage = min(self.target_volatility / asset_volatility, self.max_percentage)
        amount = account_value * percentage
        shares = int(amount / price)
        return shares, percentage

# ç¤ºä¾‹
position_sizer = VolatilityAdjustedPositionSizing(target_volatility=0.15)

# ä½æ³¢åŠ¨æ ‡çš„
low_vol_shares, low_vol_pct = position_sizer.calculate_position(
    account_value, price, asset_volatility=0.2
)
print(f"ä½æ³¢åŠ¨æ ‡çš„(å¹´åŒ–æ³¢åŠ¨ç‡20%): ä¹°å…¥{low_vol_shares}è‚¡, ä»“ä½{low_vol_pct:.2%}")

# é«˜æ³¢åŠ¨æ ‡çš„
high_vol_shares, high_vol_pct = position_sizer.calculate_position(
    account_value, price, asset_volatility=0.5
)
print(f"é«˜æ³¢åŠ¨æ ‡çš„(å¹´åŒ–æ³¢åŠ¨ç‡50%): ä¹°å…¥{high_vol_shares}è‚¡, ä»“ä½{high_vol_pct:.2%}")
```

**ä¼˜ç‚¹**ï¼š
- è€ƒè™‘äº†é£é™©ç‰¹å¾
- è‡ªåŠ¨è°ƒæ•´ï¼Œé£é™©ä¸€è‡´

**ç¼ºç‚¹**ï¼š
- éœ€è¦å‡†ç¡®ä¼°è®¡æ³¢åŠ¨ç‡
- å†å²æ³¢åŠ¨ç‡å¯èƒ½ä¸ä»£è¡¨æœªæ¥

### 11.2.4 å‡¯åˆ©å…¬å¼ (Kelly Criterion)

**åŸç†**ï¼šæ ¹æ®ç­–ç•¥çš„èƒœç‡å’Œç›ˆäºæ¯”ï¼Œè®¡ç®—æœ€ä¼˜ä»“ä½æ¯”ä¾‹ï¼Œä½¿é•¿æœŸèµ„é‡‘å¢é•¿æœ€å¤§åŒ–ã€‚

**å…¬å¼**ï¼š
```
f* = (p * (b + 1) - 1) / b
```
å…¶ä¸­ï¼š
- f*: æœ€ä¼˜ä»“ä½æ¯”ä¾‹
- p: èƒœç‡
- b: ç›ˆäºæ¯” (å¹³å‡ç›ˆåˆ©/å¹³å‡äºæŸ)

```python
class KellyPositionSizing:
    """å‡¯åˆ©å…¬å¼ä»“ä½ç®¡ç†"""

    def __init__(self, win_rate, profit_loss_ratio, kelly_fraction=0.5):
        """
        å‚æ•°:
        win_rate: float, èƒœç‡(0-1)
        profit_loss_ratio: float, ç›ˆäºæ¯”(å¹³å‡ç›ˆåˆ©/å¹³å‡äºæŸ)
        kelly_fraction: float, å‡¯åˆ©åˆ†æ•°(é€šå¸¸ä½¿ç”¨0.25-0.5,é™ä½é£é™©)
        """
        self.win_rate = win_rate
        self.profit_loss_ratio = profit_loss_ratio
        self.kelly_fraction = kelly_fraction

    def calculate_kelly_percentage(self):
        """
        è®¡ç®—å‡¯åˆ©ä»“ä½æ¯”ä¾‹

        è¿”å›:
        float: æœ€ä¼˜ä»“ä½æ¯”ä¾‹
        """
        p = self.win_rate
        b = self.profit_loss_ratio

        # å®Œæ•´å‡¯åˆ©å…¬å¼
        kelly = (p * (b + 1) - 1) / b

        # åº”ç”¨å‡¯åˆ©åˆ†æ•°
        adjusted_kelly = kelly * self.kelly_fraction

        # ç¡®ä¿ä¸ä¸ºè´Ÿ
        adjusted_kelly = max(0, adjusted_kelly)

        return adjusted_kelly

    def calculate_position(self, account_value, price):
        """
        è®¡ç®—ä»“ä½

        å‚æ•°:
        account_value: float, è´¦æˆ·æ€»èµ„äº§
        price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        int: å¯ä¹°å…¥çš„è‚¡æ•°
        """
        percentage = self.calculate_kelly_percentage()
        amount = account_value * percentage
        shares = int(amount / price)
        return shares, percentage

# ç¤ºä¾‹
# å‡è®¾ç­–ç•¥èƒœç‡60%,å¹³å‡ç›ˆåˆ©æ˜¯å¹³å‡äºæŸçš„1.5å€
position_sizer = KellyPositionSizing(
    win_rate=0.6,
    profit_loss_ratio=1.5,
    kelly_fraction=0.5  # ä½¿ç”¨åŠå‡¯åˆ©
)

kelly_pct = position_sizer.calculate_kelly_percentage()
print(f"å‡¯åˆ©å…¬å¼å»ºè®®ä»“ä½: {kelly_pct:.2%}")

shares, pct = position_sizer.calculate_position(account_value, price)
print(f"åº”ä¹°å…¥{shares}è‚¡, å®é™…ä»“ä½{pct:.2%}")

# ä¸åŒèƒœç‡å’Œç›ˆäºæ¯”çš„å¯¹æ¯”
scenarios = [
    (0.55, 1.2, "ä¿å®ˆç­–ç•¥"),
    (0.60, 1.5, "å‡è¡¡ç­–ç•¥"),
    (0.65, 2.0, "æ¿€è¿›ç­–ç•¥"),
]

print("\nä¸åŒç­–ç•¥çš„å‡¯åˆ©ä»“ä½å¯¹æ¯”:")
for win_rate, pl_ratio, name in scenarios:
    ps = KellyPositionSizing(win_rate, pl_ratio, kelly_fraction=0.5)
    kelly = ps.calculate_kelly_percentage()
    print(f"{name} (èƒœç‡{win_rate:.0%}, ç›ˆäºæ¯”{pl_ratio}): å»ºè®®ä»“ä½{kelly:.2%}")
```

**é‡è¦æç¤º**ï¼š
- å®Œæ•´å‡¯åˆ©å…¬å¼è¿‡äºæ¿€è¿›ï¼Œå®è·µä¸­å¸¸ç”¨åŠå‡¯åˆ©(kelly_fraction=0.5)æˆ–å››åˆ†ä¹‹ä¸€å‡¯åˆ©
- éœ€è¦å‡†ç¡®ä¼°è®¡èƒœç‡å’Œç›ˆäºæ¯”
- é€‚ç”¨äºå¯é‡å¤å¤šæ¬¡çš„äº¤æ˜“

### 11.2.5 é£é™©å¹³ä»·æ³• (Risk Parity)

**åŸç†**ï¼šä½¿æ¯ä¸ªèµ„äº§å¯¹æŠ•èµ„ç»„åˆçš„é£é™©è´¡çŒ®ç›¸ç­‰ã€‚

```python
class RiskParityPositionSizing:
    """é£é™©å¹³ä»·ä»“ä½ç®¡ç†"""

    def __init__(self):
        pass

    def calculate_positions(self, account_value, prices, volatilities):
        """
        è®¡ç®—å„èµ„äº§çš„ä»“ä½

        å‚æ•°:
        account_value: float, è´¦æˆ·æ€»èµ„äº§
        prices: dict, å„èµ„äº§ä»·æ ¼ {asset_name: price}
        volatilities: dict, å„èµ„äº§å¹´åŒ–æ³¢åŠ¨ç‡ {asset_name: volatility}

        è¿”å›:
        dict: å„èµ„äº§çš„è‚¡æ•°å’Œé‡‘é¢
        """
        # è®¡ç®—å„èµ„äº§çš„é£é™©æƒé‡(æ³¢åŠ¨ç‡çš„å€’æ•°)
        inv_vol = {asset: 1.0 / vol for asset, vol in volatilities.items()}
        total_inv_vol = sum(inv_vol.values())

        # å½’ä¸€åŒ–å¾—åˆ°æƒé‡
        weights = {asset: iv / total_inv_vol for asset, iv in inv_vol.items()}

        # è®¡ç®—å„èµ„äº§çš„é‡‘é¢å’Œè‚¡æ•°
        positions = {}
        for asset, weight in weights.items():
            amount = account_value * weight
            price = prices[asset]
            shares = int(amount / price)
            positions[asset] = {
                'shares': shares,
                'amount': shares * price,
                'weight': weight
            }

        return positions

# ç¤ºä¾‹
position_sizer = RiskParityPositionSizing()

prices = {
    'è‚¡ç¥¨A': 100,
    'è‚¡ç¥¨B': 50,
    'è‚¡ç¥¨C': 200
}

volatilities = {
    'è‚¡ç¥¨A': 0.3,  # é«˜æ³¢åŠ¨
    'è‚¡ç¥¨B': 0.15, # ä½æ³¢åŠ¨
    'è‚¡ç¥¨C': 0.4   # å¾ˆé«˜æ³¢åŠ¨
}

positions = position_sizer.calculate_positions(account_value, prices, volatilities)

print("é£é™©å¹³ä»·é…ç½®ç»“æœ:")
for asset, pos in positions.items():
    print(f"{asset}: {pos['shares']}è‚¡, {pos['amount']:.0f}å…ƒ, æƒé‡{pos['weight']:.2%}, æ³¢åŠ¨ç‡{volatilities[asset]:.1%}")
```

**ä¼˜ç‚¹**ï¼š
- å¤šèµ„äº§ç»„åˆé£é™©æ›´å‡è¡¡
- é¿å…é«˜æ³¢åŠ¨èµ„äº§ä¸»å¯¼é£é™©

**ç¼ºç‚¹**ï¼š
- ä¸è€ƒè™‘æ”¶ç›Šé¢„æœŸ
- ä½æ³¢åŠ¨èµ„äº§å¯èƒ½è·å¾—è¿‡é«˜æƒé‡

---

## 11.3 æ­¢æŸæ­¢ç›ˆæŠ€å·§ âš¡

### 11.3.1 æ­¢æŸçš„é‡è¦æ€§

**æ­¢æŸæ˜¯ä¿å‘½çš„çº¢çº¿ï¼**

ä¸æ­¢æŸçš„åæœï¼š
- å°äºå˜å¤§äº
- å›æœ¬è¶Šæ¥è¶Šéš¾ï¼ˆäº50%éœ€è¦æ¶¨100%æ‰èƒ½å›æœ¬ï¼‰
- å¿ƒç†è´Ÿæ‹…è¶Šæ¥è¶Šé‡
- é”™å¤±å…¶ä»–æœºä¼š

### 11.3.2 æ­¢æŸæ–¹æ³•

#### 1. å›ºå®šç™¾åˆ†æ¯”æ­¢æŸ

```python
class FixedPercentageStopLoss:
    """å›ºå®šç™¾åˆ†æ¯”æ­¢æŸ"""

    def __init__(self, stop_loss_pct):
        """
        å‚æ•°:
        stop_loss_pct: float, æ­¢æŸç™¾åˆ†æ¯”(å¦‚0.05è¡¨ç¤º5%)
        """
        self.stop_loss_pct = stop_loss_pct

    def calculate_stop_price(self, entry_price):
        """
        è®¡ç®—æ­¢æŸä»·æ ¼

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼

        è¿”å›:
        float: æ­¢æŸä»·æ ¼
        """
        stop_price = entry_price * (1 - self.stop_loss_pct)
        return stop_price

    def should_stop(self, entry_price, current_price):
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥æ­¢æŸ

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼
        current_price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        bool: æ˜¯å¦æ­¢æŸ
        """
        stop_price = self.calculate_stop_price(entry_price)
        return current_price <= stop_price

# ç¤ºä¾‹
stop_loss = FixedPercentageStopLoss(stop_loss_pct=0.05)  # 5%æ­¢æŸ

entry_price = 100
stop_price = stop_loss.calculate_stop_price(entry_price)
print(f"å…¥åœºä»·æ ¼: {entry_price}å…ƒ, æ­¢æŸä»·æ ¼: {stop_price}å…ƒ")

# æ¨¡æ‹Ÿä»·æ ¼å˜åŒ–
prices = [100, 98, 96, 94, 92]
for price in prices:
    should_stop = stop_loss.should_stop(entry_price, price)
    loss_pct = (price - entry_price) / entry_price
    print(f"å½“å‰ä»·æ ¼: {price}å…ƒ, äºæŸ: {loss_pct:.2%}, æ˜¯å¦æ­¢æŸ: {should_stop}")
```

#### 2. ATRæ­¢æŸ (Average True Range)

```python
import pandas as pd

class ATRStopLoss:
    """ATRæ­¢æŸ"""

    def __init__(self, atr_multiplier=2, atr_period=14):
        """
        å‚æ•°:
        atr_multiplier: float, ATRå€æ•°
        atr_period: int, ATRè®¡ç®—å‘¨æœŸ
        """
        self.atr_multiplier = atr_multiplier
        self.atr_period = atr_period

    def calculate_atr(self, high, low, close):
        """
        è®¡ç®—ATR

        å‚æ•°:
        high: Series, æœ€é«˜ä»·
        low: Series, æœ€ä½ä»·
        close: Series, æ”¶ç›˜ä»·

        è¿”å›:
        Series: ATRå€¼
        """
        # True Range
        tr1 = high - low
        tr2 = abs(high - close.shift(1))
        tr3 = abs(low - close.shift(1))
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

        # ATR
        atr = tr.rolling(window=self.atr_period).mean()
        return atr

    def calculate_stop_price(self, entry_price, atr_value, position='long'):
        """
        è®¡ç®—æ­¢æŸä»·æ ¼

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼
        atr_value: float, å½“å‰ATRå€¼
        position: str, æŒä»“æ–¹å‘('long'æˆ–'short')

        è¿”å›:
        float: æ­¢æŸä»·æ ¼
        """
        if position == 'long':
            stop_price = entry_price - self.atr_multiplier * atr_value
        else:  # short
            stop_price = entry_price + self.atr_multiplier * atr_value

        return stop_price

# ç¤ºä¾‹
np.random.seed(42)
# æ¨¡æ‹Ÿä»·æ ¼æ•°æ®
dates = pd.date_range('2024-01-01', periods=30)
close = pd.Series(100 + np.cumsum(np.random.randn(30) * 2), index=dates)
high = close + abs(np.random.randn(30) * 1)
low = close - abs(np.random.randn(30) * 1)

stop_loss = ATRStopLoss(atr_multiplier=2, atr_period=14)
atr = stop_loss.calculate_atr(high, low, close)

entry_price = close.iloc[-1]
atr_value = atr.iloc[-1]
stop_price = stop_loss.calculate_stop_price(entry_price, atr_value, position='long')

print(f"å…¥åœºä»·æ ¼: {entry_price:.2f}å…ƒ")
print(f"å½“å‰ATR: {atr_value:.2f}")
print(f"æ­¢æŸä»·æ ¼: {stop_price:.2f}å…ƒ")
print(f"æ­¢æŸç©ºé—´: {((stop_price - entry_price) / entry_price):.2%}")
```

#### 3. ç§»åŠ¨æ­¢æŸ (Trailing Stop)

```python
class TrailingStopLoss:
    """ç§»åŠ¨æ­¢æŸ"""

    def __init__(self, trailing_pct):
        """
        å‚æ•°:
        trailing_pct: float, ç§»åŠ¨æ­¢æŸç™¾åˆ†æ¯”
        """
        self.trailing_pct = trailing_pct
        self.highest_price = None
        self.stop_price = None

    def update(self, current_price, is_first=False):
        """
        æ›´æ–°æ­¢æŸä»·æ ¼

        å‚æ•°:
        current_price: float, å½“å‰ä»·æ ¼
        is_first: bool, æ˜¯å¦é¦–æ¬¡(å…¥åœºæ—¶)

        è¿”å›:
        dict: åŒ…å«æœ€é«˜ä»·å’Œæ­¢æŸä»·
        """
        if is_first or self.highest_price is None:
            # é¦–æ¬¡å…¥åœº
            self.highest_price = current_price
            self.stop_price = current_price * (1 - self.trailing_pct)
        else:
            # æ›´æ–°æœ€é«˜ä»·
            if current_price > self.highest_price:
                self.highest_price = current_price
                # æ­¢æŸä»·ä¸Šç§»
                new_stop = self.highest_price * (1 - self.trailing_pct)
                self.stop_price = max(self.stop_price, new_stop)

        return {
            'highest_price': self.highest_price,
            'stop_price': self.stop_price,
            'should_stop': current_price <= self.stop_price
        }

# ç¤ºä¾‹
trailing_stop = TrailingStopLoss(trailing_pct=0.1)  # 10%ç§»åŠ¨æ­¢æŸ

# æ¨¡æ‹Ÿä»·æ ¼èµ°åŠ¿
price_series = [100, 105, 110, 108, 112, 115, 110, 105, 100]

print("ç§»åŠ¨æ­¢æŸç¤ºä¾‹:")
for i, price in enumerate(price_series):
    result = trailing_stop.update(price, is_first=(i == 0))
    print(f"ä»·æ ¼: {price:.0f}, æœ€é«˜ä»·: {result['highest_price']:.0f}, "
          f"æ­¢æŸä»·: {result['stop_price']:.2f}, æ˜¯å¦æ­¢æŸ: {result['should_stop']}")

    if result['should_stop']:
        print("è§¦å‘æ­¢æŸ,é€€å‡º!")
        break
```

### 11.3.3 æ­¢ç›ˆæ–¹æ³•

#### 1. å›ºå®šç›®æ ‡æ­¢ç›ˆ

```python
class FixedTargetTakeProfit:
    """å›ºå®šç›®æ ‡æ­¢ç›ˆ"""

    def __init__(self, target_pct):
        """
        å‚æ•°:
        target_pct: float, ç›®æ ‡æ”¶ç›Šç‡
        """
        self.target_pct = target_pct

    def calculate_target_price(self, entry_price):
        """
        è®¡ç®—ç›®æ ‡ä»·æ ¼

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼

        è¿”å›:
        float: ç›®æ ‡ä»·æ ¼
        """
        target_price = entry_price * (1 + self.target_pct)
        return target_price

    def should_take_profit(self, entry_price, current_price):
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥æ­¢ç›ˆ

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼
        current_price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        bool: æ˜¯å¦æ­¢ç›ˆ
        """
        target_price = self.calculate_target_price(entry_price)
        return current_price >= target_price

# ç¤ºä¾‹
take_profit = FixedTargetTakeProfit(target_pct=0.15)  # 15%æ­¢ç›ˆ

entry_price = 100
target_price = take_profit.calculate_target_price(entry_price)
print(f"å…¥åœºä»·æ ¼: {entry_price}å…ƒ, ç›®æ ‡ä»·æ ¼: {target_price}å…ƒ")
```

#### 2. åˆ†æ‰¹æ­¢ç›ˆ

```python
class PartialTakeProfit:
    """åˆ†æ‰¹æ­¢ç›ˆ"""

    def __init__(self, targets):
        """
        å‚æ•°:
        targets: list of tuples, [(ä»·æ ¼ç™¾åˆ†æ¯”, å¹³ä»“æ¯”ä¾‹), ...]
        """
        self.targets = sorted(targets, key=lambda x: x[0])
        self.executed_targets = set()

    def check_targets(self, entry_price, current_price, current_position):
        """
        æ£€æŸ¥æ˜¯å¦è§¦è¾¾æ­¢ç›ˆç›®æ ‡

        å‚æ•°:
        entry_price: float, å…¥åœºä»·æ ¼
        current_price: float, å½“å‰ä»·æ ¼
        current_position: int, å½“å‰æŒä»“

        è¿”å›:
        dict: æ­¢ç›ˆå»ºè®®
        """
        suggestions = []

        for i, (pct, close_ratio) in enumerate(self.targets):
            if i in self.executed_targets:
                continue

            target_price = entry_price * (1 + pct)

            if current_price >= target_price:
                close_amount = int(current_position * close_ratio)
                suggestions.append({
                    'target_index': i,
                    'target_pct': pct,
                    'target_price': target_price,
                    'close_ratio': close_ratio,
                    'close_amount': close_amount
                })
                self.executed_targets.add(i)

        return suggestions

# ç¤ºä¾‹
# å®šä¹‰åˆ†æ‰¹æ­¢ç›ˆç›®æ ‡: æ¶¨10%å¹³1/3, æ¶¨20%å¹³1/2, æ¶¨30%å…¨å¹³
take_profit = PartialTakeProfit(targets=[
    (0.10, 1/3),  # æ¶¨10%,å¹³ä»“1/3
    (0.20, 1/2),  # æ¶¨20%,å¹³ä»“1/2
    (0.30, 1.0),  # æ¶¨30%,å…¨éƒ¨å¹³ä»“
])

entry_price = 100
position = 1000  # æŒä»“1000è‚¡

# æ¨¡æ‹Ÿä»·æ ¼ä¸Šæ¶¨
prices = [100, 105, 110, 115, 120, 125, 130, 135]

print("åˆ†æ‰¹æ­¢ç›ˆç¤ºä¾‹:")
current_position = position
for price in prices:
    profit_pct = (price - entry_price) / entry_price
    print(f"\nå½“å‰ä»·æ ¼: {price}å…ƒ, æ”¶ç›Šç‡: {profit_pct:.2%}, æŒä»“: {current_position}è‚¡")

    suggestions = take_profit.check_targets(entry_price, price, current_position)

    for sug in suggestions:
        print(f"  è§¦å‘æ­¢ç›ˆç›®æ ‡: æ¶¨å¹…{sug['target_pct']:.0%}, "
              f"å»ºè®®å¹³ä»“{sug['close_amount']}è‚¡({sug['close_ratio']:.1%})")
        current_position -= sug['close_amount']
```

#### 3. åŠ¨æ€æ­¢ç›ˆ (åŸºäºæŠ€æœ¯æŒ‡æ ‡)

```python
class DynamicTakeProfit:
    """åŠ¨æ€æ­¢ç›ˆ(åŸºäºå¸ƒæ—å¸¦)"""

    def __init__(self, period=20, std_multiplier=2):
        """
        å‚æ•°:
        period: int, ç§»åŠ¨å¹³å‡å‘¨æœŸ
        std_multiplier: float, æ ‡å‡†å·®å€æ•°
        """
        self.period = period
        self.std_multiplier = std_multiplier

    def calculate_bollinger_bands(self, prices):
        """
        è®¡ç®—å¸ƒæ—å¸¦

        å‚æ•°:
        prices: Series, ä»·æ ¼åºåˆ—

        è¿”å›:
        dict: ä¸Šè½¨ã€ä¸­è½¨ã€ä¸‹è½¨
        """
        ma = prices.rolling(window=self.period).mean()
        std = prices.rolling(window=self.period).std()

        upper_band = ma + self.std_multiplier * std
        lower_band = ma - self.std_multiplier * std

        return {
            'upper': upper_band,
            'middle': ma,
            'lower': lower_band
        }

    def should_take_profit(self, prices, current_price, position='long'):
        """
        åˆ¤æ–­æ˜¯å¦æ­¢ç›ˆ

        å‚æ•°:
        prices: Series, å†å²ä»·æ ¼
        current_price: float, å½“å‰ä»·æ ¼
        position: str, æŒä»“æ–¹å‘

        è¿”å›:
        bool: æ˜¯å¦æ­¢ç›ˆ
        """
        bands = self.calculate_bollinger_bands(prices)
        current_upper = bands['upper'].iloc[-1]

        if position == 'long':
            # å¤šå¤´: ä»·æ ¼è§¦åŠæˆ–è¶…è¿‡ä¸Šè½¨æ—¶æ­¢ç›ˆ
            return current_price >= current_upper
        else:
            # ç©ºå¤´: ä»·æ ¼è§¦åŠæˆ–ä½äºä¸‹è½¨æ—¶æ­¢ç›ˆ
            current_lower = bands['lower'].iloc[-1]
            return current_price <= current_lower

# ç¤ºä¾‹
take_profit = DynamicTakeProfit(period=20, std_multiplier=2)

# æ¨¡æ‹Ÿä»·æ ¼æ•°æ®
np.random.seed(42)
prices = pd.Series(100 + np.cumsum(np.random.randn(30) * 2))

bands = take_profit.calculate_bollinger_bands(prices)
current_price = 110

should_tp = take_profit.should_take_profit(prices, current_price, position='long')

print(f"å½“å‰ä»·æ ¼: {current_price:.2f}")
print(f"å¸ƒæ—å¸¦ä¸Šè½¨: {bands['upper'].iloc[-1]:.2f}")
print(f"å¸ƒæ—å¸¦ä¸­è½¨: {bands['middle'].iloc[-1]:.2f}")
print(f"å¸ƒæ—å¸¦ä¸‹è½¨: {bands['lower'].iloc[-1]:.2f}")
print(f"æ˜¯å¦æ­¢ç›ˆ: {should_tp}")
```

#### 4. å¦–è‚¡"æ»šé›ªçƒ"æ­¢ç›ˆç­–ç•¥ ğŸ‰

**é€‚ç”¨åœºæ™¯**ï¼šé«˜æ³¢åŠ¨ä¸ªè‚¡ã€å¦–è‚¡ã€ä¸»å‡æµª

è¿™æ˜¯ä¸€å¥—ä¸“é—¨ä¸º"é«˜æ³¢åŠ¨å¦–è‚¡"é‡èº«å®šåˆ¶çš„å®Œæ•´æ­¢ç›ˆä½“ç³»ã€‚å…¶æ ¸å¿ƒä¸åœ¨äºè¿½æ±‚æ•°å­¦ä¸Šçš„åˆ©ç›Šæœ€å¤§åŒ–ï¼Œè€Œåœ¨äº**å¯¹äººæ€§çš„æè‡´æ‹¿æ**â€”â€”é€šè¿‡ä»“ä½ç®¡ç†ï¼Œå¼ºåˆ¶è®©å¿ƒæ€å§‹ç»ˆå¤„äº"èˆ’é€‚åŒº"ã€‚

##### ç­–ç•¥å››æ­¥æ³•

```
ç¬¬1æ­¥ï¼šç«‹äºä¸è´¥ï¼ˆå®‰å…¨å«ï¼‰
æ”¶ç›Š+30% â†’ åšå†³å‡ä»“1/3
å›æ”¶æœ¬é‡‘å‹åŠ›ï¼Œå»ºç«‹å¿ƒç†é˜²çº¿

ç¬¬2æ­¥ï¼šå¿ƒæ€å»ºè®¾ï¼ˆæ— æ‚”åšå¼ˆï¼‰
æ— è®ºå¹³åº¸æˆ–æˆå¦–ï¼Œå‡ä»“éƒ½æ˜¯å¯¹çš„
ä¸è¢«å¸‚åœºæƒ…ç»ªå·¦å³ï¼Œå¿ƒæ€æ— æ‚”

ç¬¬3æ­¥ï¼šé‡‘å­—å¡”ç¦»åœºï¼ˆä¸çŒœé¡¶ï¼‰
æ¯å†æ¶¨+15% â†’ å‡ä»“10%
è¾¹æ¶¨è¾¹å–ï¼Œè®©åˆ©æ¶¦å¥”è·‘ï¼Œé£é™©é€’å‡

ç¬¬4æ­¥ï¼šè¶‹åŠ¿ç†”æ–­ï¼ˆç»ˆå±€çºªå¾‹ï¼‰
ç¡®è®¤å¤§è·Œ â†’ ç›´æ¥å‡åŠï¼ï¼ˆå‰©ä½™éšç¼˜ï¼‰
ä¸¥æ ¼æ‰§è¡Œçºªå¾‹ï¼Œé¿å…ç¾éš¾æ€§å›æ’¤
```

**ç­–ç•¥å¯è§†åŒ–å›¾**ï¼š

![å¦–è‚¡"æ»šé›ªçƒ"æ­¢ç›ˆé“å¾‹](images/ç¬¬åä¸€ç« /å¦–è‚¡æ­¢ç›ˆé“å¾‹.png)

*å›¾ï¼šå¦–è‚¡"æ»šé›ªçƒ"æ­¢ç›ˆç­–ç•¥å››æ­¥æ³• - åè„†å¼±èµ„é‡‘ç®¡ç†ä½“ç³»*

---

##### æ ¸å¿ƒé€»è¾‘è¯¦è§£

**ç¬¬1æ­¥ï¼šå®‰å…¨å«æ³•åˆ™ï¼ˆ+30%å‡ä»“1/3ï¼‰**

```
æˆ˜æœ¯æ„å›¾ï¼šå›æ”¶æœ¬é‡‘ï¼Œå»ºç«‹å¿ƒç†é˜²çº¿
æ•ˆæœï¼šåªè¦è¿™ä¸€æ­¥åšåˆ°äº†ï¼Œåç»­æ— è®ºè‚¡ä»·æ€ä¹ˆè·Œï¼Œä½ éƒ½ä¸ä¼šäºæŸæœ¬é‡‘ï¼ˆæˆ–è€…äºæŸæå°ï¼‰
      è¿™æ—¶å€™ä½ ç”¨çš„å·²ç»æ˜¯å¸‚åœºçš„é’±(House Money)åœ¨åšå¼ˆï¼Œå¿ƒæ€ä¼šå‘ç”Ÿè´¨çš„é£è·ƒ
```

**ç¬¬2æ­¥ï¼šæ— æ‚”åšå¼ˆï¼ˆå¿ƒæ€å»ºè®¾ï¼‰**

```
æˆ˜æœ¯æ„å›¾ï¼šè§£å†³"å–é£"å’Œ"åè¿‡å±±è½¦"çš„çŸ›ç›¾

é€»è¾‘é—­ç¯ï¼š
- è‹¥å˜ç›˜å‘ä¸‹ï¼šå¹¸å¥½æˆ‘å‡äº†ï¼Œä¿ä½äº†æœå®
- è‹¥ç»§ç»­æˆå¦–ï¼šå¹¸å¥½æˆ‘æ²¡æ¸…ä»“ï¼Œè¿˜èƒ½äº«å—ä¸»å‡æµª

æœ¬è´¨ï¼šæ— è®ºå¸‚åœºæ€ä¹ˆèµ°ï¼Œä½ éƒ½ç»™äº†è‡ªå·±ä¸€ä¸ª"æˆ‘æ˜¯å¯¹çš„"çš„å¿ƒç†æš—ç¤º
      è¿™åœ¨äº¤æ˜“ä¸­æ˜¯ç»´æŒç†æ™ºçš„å…³é”®
```

**ç¬¬3æ­¥ï¼šé‡‘å­—å¡”å¼ç¦»åœºï¼ˆæ¯æ¶¨15%å‡10%ï¼‰**

```
æˆ˜æœ¯æ„å›¾ï¼šæ—¢ç„¶æ˜¯å¦–è‚¡ï¼Œå°±ä¸çŒœé¡¶ï¼Œè¾¹æ¶¨è¾¹å–
æ•ˆæœï¼šéšç€è‚¡ä»·å‡é«˜ï¼Œé£é™©ä¹Ÿåœ¨ç´¯ç§¯
      é€šè¿‡é€æ­¥é™ä½ä»“ä½ï¼Œä½ çš„é£é™©æ•å£åœ¨ä¸æ–­ç¼©å°ï¼Œä½†ä½ çš„åˆ©æ¶¦æ€»é¢åœ¨ä¸æ–­å¢åŠ 
      è¿™å«"åƒé±¼èº«ï¼Œåé±¼åˆº"
```

**ç¬¬4æ­¥ï¼šè¶‹åŠ¿ç†”æ–­ï¼ˆå¤§è·Œå‡åŠ+éšç¼˜ï¼‰**

```
æˆ˜æœ¯æ„å›¾ï¼šç¡®è®¤è¶‹åŠ¿åè½¬ï¼Œé”å®šèƒœå±€
æ•ˆæœï¼š"å¤§è·Œ"é€šå¸¸æ˜¯å¦–è‚¡è§é¡¶çš„ä¿¡å·ï¼ˆæ–­å¤´é“¡åˆ€ï¼‰
      è¿™æ—¶å€™å‡åŠæ˜¯æœ€åçš„çºªå¾‹
      å‰©ä¸‹çš„"éšæ„"ï¼Œæ˜¯å› ä¸ºå‰©ä¸‹çš„å…¨æ˜¯çº¯åˆ©æ¶¦ï¼ˆé›¶æˆæœ¬ç­¹ç ï¼‰
      ä½ å¯ä»¥é™ªåº„å®¶ç©åˆ°é€€å¸‚ï¼Œä¹Ÿå¯ä»¥åšä¸€ä¸ª"åŒé¡¶"åæŠ½ï¼Œå®Œå…¨æ²¡æœ‰å¿ƒç†è´Ÿæ‹…
```

##### æ¨¡æ‹Ÿæ¨æ¼”ï¼šå¦‚æœé‡åˆ°ä¸€åªç¿»å€å¦–è‚¡

å‡è®¾æ‚¨ä¹°å…¥**10,000å…ƒ**æŸå¦–è‚¡ï¼Œæˆæœ¬**10å…ƒ/è‚¡**ï¼ˆ1000è‚¡ï¼‰

| é˜¶æ®µ | è‚¡ä»·è¡¨ç° | æ“ä½œåŠ¨ä½œ | å‰©ä½™æŒä»“ | è´¦æˆ·çŠ¶æ€ | å¿ƒç†çŠ¶æ€ |
|-----|---------|---------|---------|---------|---------|
| **å¯åŠ¨** | æ¶¨åˆ°13å…ƒ<br/>(+30%) | å–å‡º333è‚¡<br/>ï¼ˆæ”¶å›çº¦4330å…ƒï¼‰ | 667è‚¡ | å·²è½è¢‹4330å…ƒ | **ç«‹äºä¸è´¥**<br/>æœ¬é‡‘é£é™©ä»…å‰©50% |
| **ä¸­ç»§** | åªæœ‰æ™®é€šæ¶¨å¹…<br/>æ­¤æ—¶å¿ƒæ€ï¼šå®ƒæ˜¯å¹³åº¸ä¹‹è¾ˆ | æŒæœ‰/å–å‡º | - | å°èµšç¦»åœº | ä¸çº ç»“ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ª |
| **æˆå¦–** | æ¶¨åˆ°15å…ƒ<br/>(+15%) | å–å‡º100è‚¡<br/>ï¼ˆæ”¶å›1500å…ƒï¼‰ | 567è‚¡ | ç´¯è®¡è½è¢‹<br/>5830å…ƒ | è¶Šæ¶¨è¶Šå¼€å¿ƒ<br/>è¶Šå–è¶Šè½»æ¾ |
| **åŠ é€Ÿ** | æ¶¨åˆ°17.25å…ƒ<br/>(+15%) | å–å‡º100è‚¡<br/>ï¼ˆæ”¶å›1725å…ƒï¼‰ | 467è‚¡ | ç´¯è®¡è½è¢‹<br/>7555å…ƒ | å·²ç»æ”¶å›75%æœ¬é‡‘ |
| **è§é¡¶** | æ¶¨åˆ°20å…ƒ | æœªè§¦åŠå¤§è·Œï¼ŒæŒæœ‰ | 467è‚¡ | å¸‚å€¼é£™å‡ | äº«å—æ³¡æ²« |
| **å´©ç›˜** | å¤§è·Œè‡³18å…ƒ | å–å‡º233è‚¡<br/>ï¼ˆæ”¶å›4194å…ƒï¼‰ | 234è‚¡ | **æœ¬é‡‘å…¨å›**<br/>ä¸”å¤§èµš | å‰©ä¸‹çš„å…¨æ˜¯åˆ©æ¶¦é€çš„ |

**æ€»ç»“æ”¶ç›Š**ï¼š
```
åˆå§‹æŠ•èµ„ï¼š10,000å…ƒ
ç´¯è®¡å–å‡ºï¼š4330 + 1500 + 1725 + 4194 = 11,749å…ƒ
å‰©ä½™æŒä»“ï¼š234è‚¡ Ã— 18å…ƒ = 4,212å…ƒ
æ€»èµ„äº§ï¼š11,749 + 4,212 = 15,961å…ƒ
æ€»æ”¶ç›Šï¼š+59.61%

å…³é”®ï¼šå³ä½¿åç»­è‚¡ä»·è…°æ–©ï¼Œä½ ä¾ç„¶ç›ˆåˆ©ï¼
```

##### Pythonä»£ç å®ç°

```python
class MonsterStockTakeProfitStrategy:
    """å¦–è‚¡"æ»šé›ªçƒ"æ­¢ç›ˆç­–ç•¥"""

    def __init__(self, initial_capital, entry_price, initial_shares):
        """
        å‚æ•°:
        initial_capital: float, åˆå§‹æŠ•èµ„é‡‘é¢
        entry_price: float, å…¥åœºä»·æ ¼
        initial_shares: int, åˆå§‹è‚¡æ•°
        """
        self.initial_capital = initial_capital
        self.entry_price = entry_price
        self.initial_shares = initial_shares
        self.current_shares = initial_shares

        # æ­¢ç›ˆé˜¶æ®µè·Ÿè¸ª
        self.stage = 'holding'  # holding, stage1, stage2, stage3, final
        self.total_sold_amount = 0  # ç´¯è®¡å–å‡ºé‡‘é¢
        self.trades = []  # äº¤æ˜“è®°å½•

        # é˜¶æ®µ3çš„è§¦å‘è®°å½•
        self.stage3_last_trigger_price = 0

    def check_and_execute(self, current_price):
        """
        æ£€æŸ¥å¹¶æ‰§è¡Œæ­¢ç›ˆç­–ç•¥

        å‚æ•°:
        current_price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        dict: æ“ä½œå»ºè®®
        """
        gain_pct = (current_price - self.entry_price) / self.entry_price

        result = {
            'current_price': current_price,
            'gain_pct': gain_pct,
            'stage': self.stage,
            'action': 'hold',
            'sell_shares': 0,
            'sell_amount': 0,
            'remaining_shares': self.current_shares,
            'message': ''
        }

        # é˜¶æ®µ1ï¼š+30%ï¼Œå‡ä»“1/3
        if self.stage == 'holding' and gain_pct >= 0.30:
            sell_shares = int(self.initial_shares * 0.333)
            sell_amount = sell_shares * current_price

            self.current_shares -= sell_shares
            self.total_sold_amount += sell_amount
            self.stage = 'stage1'

            self.trades.append({
                'price': current_price,
                'action': 'sell',
                'shares': sell_shares,
                'amount': sell_amount,
                'stage': 'é˜¶æ®µ1ï¼šå®‰å…¨å«'
            })

            result.update({
                'action': 'sell',
                'sell_shares': sell_shares,
                'sell_amount': sell_amount,
                'remaining_shares': self.current_shares,
                'message': f'ğŸ›¡ï¸ é˜¶æ®µ1è§¦å‘ï¼šæ¶¨å¹…{gain_pct:.1%}ï¼Œå–å‡º{sell_shares}è‚¡ï¼ˆ1/3ä»“ä½ï¼‰ï¼Œå›æ”¶{sell_amount:.0f}å…ƒã€‚ç«‹äºä¸è´¥ï¼'
            })

        # é˜¶æ®µ3ï¼šæ¯æ¶¨15%ï¼Œå‡ä»“10%ï¼ˆéœ€è¦å…ˆè¿‡äº†é˜¶æ®µ1ï¼‰
        elif self.stage in ['stage1', 'stage2', 'stage3']:
            # è®¡ç®—ä»æœ€åä¸€æ¬¡é˜¶æ®µ3è§¦å‘ä»¥æ¥çš„æ¶¨å¹…
            if self.stage3_last_trigger_price == 0:
                # ç¬¬ä¸€æ¬¡è¿›å…¥é˜¶æ®µ3ï¼Œä»å…¥åœºä»·+30%å¼€å§‹è®¡ç®—
                base_price = self.entry_price * 1.30
            else:
                base_price = self.stage3_last_trigger_price

            gain_from_last = (current_price - base_price) / base_price

            if gain_from_last >= 0.15:
                # å‡ä»“10%ï¼ˆåŸºäºåˆå§‹ä»“ä½ï¼‰
                sell_shares = int(self.initial_shares * 0.10)
                if sell_shares > self.current_shares:
                    sell_shares = self.current_shares

                if sell_shares > 0:
                    sell_amount = sell_shares * current_price

                    self.current_shares -= sell_shares
                    self.total_sold_amount += sell_amount
                    self.stage = 'stage3'
                    self.stage3_last_trigger_price = current_price

                    self.trades.append({
                        'price': current_price,
                        'action': 'sell',
                        'shares': sell_shares,
                        'amount': sell_amount,
                        'stage': 'é˜¶æ®µ3ï¼šé‡‘å­—å¡”ç¦»åœº'
                    })

                    result.update({
                        'action': 'sell',
                        'sell_shares': sell_shares,
                        'sell_amount': sell_amount,
                        'remaining_shares': self.current_shares,
                        'message': f'ğŸ“ˆ é˜¶æ®µ3è§¦å‘ï¼šå†æ¶¨{gain_from_last:.1%}ï¼Œå–å‡º{sell_shares}è‚¡ï¼ˆ10%ä»“ä½ï¼‰ï¼Œå›æ”¶{sell_amount:.0f}å…ƒã€‚è¾¹æ¶¨è¾¹å–ï¼'
                    })

        return result

    def check_big_drop(self, current_price, previous_close, drop_threshold=-0.07):
        """
        æ£€æŸ¥å¤§è·Œå¹¶æ‰§è¡Œé˜¶æ®µ4

        å‚æ•°:
        current_price: float, å½“å‰ä»·æ ¼
        previous_close: float, å‰ä¸€æ—¥æ”¶ç›˜ä»·
        drop_threshold: float, å¤§è·Œé˜ˆå€¼ï¼ˆé»˜è®¤-7%ï¼‰

        è¿”å›:
        dict: æ“ä½œå»ºè®®
        """
        drop_pct = (current_price - previous_close) / previous_close

        result = {
            'current_price': current_price,
            'drop_pct': drop_pct,
            'action': 'hold',
            'sell_shares': 0,
            'remaining_shares': self.current_shares,
            'message': ''
        }

        if drop_pct <= drop_threshold and self.current_shares > 0:
            # å¤§è·Œï¼Œå‡åŠ
            sell_shares = int(self.current_shares * 0.5)
            sell_amount = sell_shares * current_price

            self.current_shares -= sell_shares
            self.total_sold_amount += sell_amount
            self.stage = 'final'

            self.trades.append({
                'price': current_price,
                'action': 'sell',
                'shares': sell_shares,
                'amount': sell_amount,
                'stage': 'é˜¶æ®µ4ï¼šè¶‹åŠ¿ç†”æ–­'
            })

            result.update({
                'action': 'sell',
                'sell_shares': sell_shares,
                'sell_amount': sell_amount,
                'remaining_shares': self.current_shares,
                'message': f'âš ï¸ é˜¶æ®µ4è§¦å‘ï¼šå¤§è·Œ{drop_pct:.1%}ï¼Œç›´æ¥å‡åŠï¼å–å‡º{sell_shares}è‚¡ï¼Œå‰©ä½™{self.current_shares}è‚¡éšç¼˜ã€‚'
            })

        return result

    def get_summary(self, current_price):
        """
        è·å–ç­–ç•¥æ‰§è¡Œæ‘˜è¦

        å‚æ•°:
        current_price: float, å½“å‰ä»·æ ¼

        è¿”å›:
        dict: æ‘˜è¦ä¿¡æ¯
        """
        remaining_value = self.current_shares * current_price
        total_value = self.total_sold_amount + remaining_value
        total_profit = total_value - self.initial_capital
        profit_pct = total_profit / self.initial_capital

        return {
            'initial_capital': self.initial_capital,
            'entry_price': self.entry_price,
            'current_price': current_price,
            'total_sold_amount': self.total_sold_amount,
            'remaining_shares': self.current_shares,
            'remaining_value': remaining_value,
            'total_value': total_value,
            'total_profit': total_profit,
            'profit_pct': profit_pct,
            'trades': self.trades
        }

# ä½¿ç”¨ç¤ºä¾‹
"""
# åˆå§‹åŒ–ç­–ç•¥
strategy = MonsterStockTakeProfitStrategy(
    initial_capital=10000,
    entry_price=10.0,
    initial_shares=1000
)

# æ¨¡æ‹Ÿä»·æ ¼å˜åŒ–
prices = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.25, 18.5, 20.0, 18.0]
previous_price = 20.0

print("å¦–è‚¡æ»šé›ªçƒæ­¢ç›ˆç­–ç•¥æ¨¡æ‹Ÿ\n" + "="*50)

for price in prices:
    # æ£€æŸ¥å¸¸è§„æ­¢ç›ˆ
    result = strategy.check_and_execute(price)

    if result['action'] == 'sell':
        print(result['message'])

    # æ£€æŸ¥å¤§è·Œï¼ˆæœ€åä¸€ä¸ªä»·æ ¼ï¼‰
    if price == 18.0:
        drop_result = strategy.check_big_drop(price, previous_price)
        if drop_result['action'] == 'sell':
            print(drop_result['message'])

    previous_price = price

# æ‰“å°æ‘˜è¦
print("\n" + "="*50)
print("ç­–ç•¥æ‰§è¡Œæ‘˜è¦ï¼š")
summary = strategy.get_summary(18.0)
print(f"åˆå§‹æŠ•èµ„ï¼š{summary['initial_capital']:.0f}å…ƒ")
print(f"ç´¯è®¡å–å‡ºï¼š{summary['total_sold_amount']:.0f}å…ƒ")
print(f"å‰©ä½™æŒä»“ï¼š{summary['remaining_shares']}è‚¡ Ã— {summary['current_price']:.2f}å…ƒ = {summary['remaining_value']:.0f}å…ƒ")
print(f"æ€»èµ„äº§ï¼š{summary['total_value']:.0f}å…ƒ")
print(f"æ€»æ”¶ç›Šï¼š{summary['profit_pct']:.2%}ï¼ˆ+{summary['total_profit']:.0f}å…ƒï¼‰")

print(f"\näº¤æ˜“è®°å½•ï¼š")
for i, trade in enumerate(summary['trades'], 1):
    print(f"{i}. {trade['stage']} - ä»·æ ¼{trade['price']:.2f}å…ƒï¼Œå–å‡º{trade['shares']}è‚¡ï¼Œå›æ”¶{trade['amount']:.0f}å…ƒ")
"""
```

##### ç­–ç•¥ç²¾é«“æ€»ç»“

è¿™å¥—ç­–ç•¥çš„æ ¸å¿ƒåœ¨äºï¼š

```
âœ“ æ‰¿è®¤è‡ªå·±æ— æ³•é¢„æµ‹æœ€é«˜ç‚¹ï¼Œæ‰€ä»¥é€‰æ‹©åˆ†æ‰¹å…‘ç°
âœ“ æ‰¿è®¤è‡ªå·±ä¹Ÿæ˜¯å‡¡äººï¼Œæ‰€ä»¥é€šè¿‡è§„åˆ™å…‹æœè´ªå©ªä¸ææƒ§
âœ“ ä¸è¿½æ±‚æ•°å­¦æœ€ä¼˜ï¼Œè€Œè¿½æ±‚å¿ƒç†èˆ’é€‚
âœ“ è®©è§„åˆ™ä»£æ›¿äººæ€§ï¼Œç”¨çºªå¾‹æˆ˜èƒœè´ªå©ª
```

è¿™ä¸ä»…ä»…æ˜¯äº¤æ˜“ç­–ç•¥ï¼Œæ›´æ˜¯ä¸€ç§**"åè„†å¼±"çš„èµ„é‡‘ç®¡ç†å“²å­¦**ã€‚

**é€‚ç”¨äººç¾¤**ï¼š
- âœ“ ç»å¸¸é‡åˆ°å¤§æ¶¨åå›ååˆ©æ¶¦çš„æŠ•èµ„è€…
- âœ“ æŒæœ‰å¦–è‚¡æ—¶å¿ƒæ€å¤±è¡¡çš„æŠ•èµ„è€…
- âœ“ ä¸çŸ¥é“ä½•æ—¶æ­¢ç›ˆçš„æŠ•èµ„è€…
- âœ“ æƒ³è¦ç³»ç»ŸåŒ–ç®¡ç†é«˜æ³¢åŠ¨ä¸ªè‚¡çš„æŠ•èµ„è€…

**ä¸é€‚ç”¨åœºæ™¯**ï¼š
- âœ— ç¨³å¥è“ç­¹è‚¡ï¼ˆæ³¢åŠ¨å°ï¼Œä¸é€‚åˆåˆ†æ‰¹æ­¢ç›ˆï¼‰
- âœ— é•¿æœŸä»·å€¼æŠ•èµ„ï¼ˆè¿™æ˜¯çŸ­ä¸­æœŸäº¤æ˜“ç­–ç•¥ï¼‰
- âœ— éœ‡è¡å¸‚ï¼ˆéœ€è¦æ˜ç¡®è¶‹åŠ¿ï¼‰

âš ï¸ **é£é™©æç¤º**ï¼š
- å¦–è‚¡é£é™©æå¤§ï¼Œå¯èƒ½çªç„¶å´©ç›˜
- æ­¤ç­–ç•¥åªèƒ½é™ä½é£é™©ï¼Œä¸èƒ½æ¶ˆé™¤é£é™©
- å»ºè®®å¦–è‚¡ä»“ä½ä¸è¶…è¿‡æ€»èµ„äº§çš„10-20%
- ä¸¥æ ¼æ‰§è¡Œçºªå¾‹ï¼Œä¸è¦å› ä¸ºè´ªå©ªä¿®æ”¹è§„åˆ™

---

## 11.4 å›æ’¤æ§åˆ¶ç­–ç•¥ ğŸ“‰

### 11.4.1 ä»€ä¹ˆæ˜¯å›æ’¤ï¼Ÿ

**å›æ’¤(Drawdown)**ï¼šä»èµ„é‡‘æ›²çº¿çš„å³°å€¼åˆ°åç»­è°·å€¼çš„ä¸‹è·Œå¹…åº¦ã€‚

```python
def calculate_drawdown_series(equity_curve):
    """
    è®¡ç®—å›æ’¤åºåˆ—

    å‚æ•°:
    equity_curve: Series, èµ„é‡‘æ›²çº¿

    è¿”å›:
    DataFrame: åŒ…å«ç´¯è®¡æœ€é«˜å€¼ã€å›æ’¤é‡‘é¢ã€å›æ’¤æ¯”ä¾‹
    """
    df = pd.DataFrame()
    df['equity'] = equity_curve

    # ç´¯è®¡æœ€é«˜å€¼
    df['cumulative_max'] = df['equity'].cummax()

    # å›æ’¤é‡‘é¢
    df['drawdown_amount'] = df['equity'] - df['cumulative_max']

    # å›æ’¤æ¯”ä¾‹
    df['drawdown_pct'] = df['drawdown_amount'] / df['cumulative_max']

    return df

# ç¤ºä¾‹
np.random.seed(42)
# æ¨¡æ‹Ÿèµ„é‡‘æ›²çº¿
returns = pd.Series(np.random.randn(100) * 0.02)
equity_curve = (1 + returns).cumprod() * 100000

dd_df = calculate_drawdown_series(equity_curve)

print("å›æ’¤åˆ†æ:")
print(f"æœ€å¤§å›æ’¤: {dd_df['drawdown_pct'].min():.2%}")
print(f"å½“å‰å›æ’¤: {dd_df['drawdown_pct'].iloc[-1]:.2%}")

# å¯è§†åŒ–
import matplotlib.pyplot as plt

fig, axes = plt.subplots(2, 1, figsize=(12, 8))

# èµ„é‡‘æ›²çº¿
axes[0].plot(dd_df.index, dd_df['equity'], label='èµ„é‡‘æ›²çº¿')
axes[0].plot(dd_df.index, dd_df['cumulative_max'],
             label='ç´¯è®¡æœ€é«˜å€¼', linestyle='--', alpha=0.7)
axes[0].set_ylabel('èµ„é‡‘(å…ƒ)')
axes[0].set_title('èµ„é‡‘æ›²çº¿ä¸å›æ’¤')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# å›æ’¤æ¯”ä¾‹
axes[1].fill_between(dd_df.index, dd_df['drawdown_pct'], 0,
                     alpha=0.3, color='red', label='å›æ’¤')
axes[1].set_ylabel('å›æ’¤æ¯”ä¾‹')
axes[1].set_xlabel('æ—¶é—´')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
# plt.savefig('drawdown_analysis.png', dpi=300, bbox_inches='tight')
print("\nå›æ’¤å¯è§†åŒ–å›¾è¡¨å·²ç”Ÿæˆ")
```

### 11.4.2 å›æ’¤æ§åˆ¶æ–¹æ³•

#### 1. æœ€å¤§å›æ’¤é™åˆ¶

```python
class MaxDrawdownControl:
    """æœ€å¤§å›æ’¤æ§åˆ¶"""

    def __init__(self, max_drawdown_limit):
        """
        å‚æ•°:
        max_drawdown_limit: float, æœ€å¤§å›æ’¤é™åˆ¶(å¦‚0.2è¡¨ç¤º20%)
        """
        self.max_drawdown_limit = max_drawdown_limit
        self.peak_value = None

    def update_and_check(self, current_value):
        """
        æ›´æ–°å¹¶æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§å›æ’¤é™åˆ¶

        å‚æ•°:
        current_value: float, å½“å‰è´¦æˆ·ä»·å€¼

        è¿”å›:
        dict: åŒ…å«å›æ’¤ä¿¡æ¯å’Œæ˜¯å¦éœ€è¦åœæ­¢äº¤æ˜“
        """
        if self.peak_value is None:
            self.peak_value = current_value
        else:
            self.peak_value = max(self.peak_value, current_value)

        drawdown = (current_value - self.peak_value) / self.peak_value

        should_stop = drawdown <= -self.max_drawdown_limit

        return {
            'current_value': current_value,
            'peak_value': self.peak_value,
            'drawdown': drawdown,
            'max_limit': self.max_drawdown_limit,
            'should_stop': should_stop
        }

# ç¤ºä¾‹
dd_control = MaxDrawdownControl(max_drawdown_limit=0.15)  # 15%å›æ’¤é™åˆ¶

# æ¨¡æ‹Ÿè´¦æˆ·ä»·å€¼å˜åŒ–
values = [100000, 105000, 110000, 108000, 103000, 98000, 93000, 95000]

print("æœ€å¤§å›æ’¤æ§åˆ¶ç¤ºä¾‹:")
for value in values:
    result = dd_control.update_and_check(value)
    print(f"è´¦æˆ·ä»·å€¼: {result['current_value']:,.0f}, "
          f"å³°å€¼: {result['peak_value']:,.0f}, "
          f"å›æ’¤: {result['drawdown']:.2%}, "
          f"æ˜¯å¦åœæ­¢äº¤æ˜“: {result['should_stop']}")

    if result['should_stop']:
        print(f"\nâš ï¸ è­¦å‘Š: å›æ’¤è¶…è¿‡{result['max_limit']:.0%}é™åˆ¶,åœæ­¢äº¤æ˜“!")
        break
```

#### 2. åŠ¨æ€ä»“ä½è°ƒæ•´

**æ ¹æ®å›æ’¤è°ƒæ•´ä»“ä½**ï¼šå›æ’¤è¶Šå¤§ï¼Œä»“ä½è¶Šå°ã€‚

```python
class DynamicPositionAdjustment:
    """åŸºäºå›æ’¤çš„åŠ¨æ€ä»“ä½è°ƒæ•´"""

    def __init__(self, base_position_pct, drawdown_thresholds):
        """
        å‚æ•°:
        base_position_pct: float, åŸºå‡†ä»“ä½æ¯”ä¾‹
        drawdown_thresholds: list of tuples, [(å›æ’¤é˜ˆå€¼, ä»“ä½è°ƒæ•´ç³»æ•°), ...]
        """
        self.base_position_pct = base_position_pct
        self.drawdown_thresholds = sorted(drawdown_thresholds,
                                         key=lambda x: x[0], reverse=True)
        self.peak_value = None

    def calculate_position_pct(self, current_value):
        """
        æ ¹æ®å½“å‰å›æ’¤è®¡ç®—å»ºè®®ä»“ä½æ¯”ä¾‹

        å‚æ•°:
        current_value: float, å½“å‰è´¦æˆ·ä»·å€¼

        è¿”å›:
        dict: åŒ…å«å›æ’¤å’Œå»ºè®®ä»“ä½
        """
        if self.peak_value is None:
            self.peak_value = current_value
        else:
            self.peak_value = max(self.peak_value, current_value)

        drawdown = (current_value - self.peak_value) / self.peak_value

        # æ ¹æ®å›æ’¤ç¡®å®šä»“ä½è°ƒæ•´ç³»æ•°
        adjustment_factor = 1.0
        for dd_threshold, factor in self.drawdown_thresholds:
            if abs(drawdown) >= dd_threshold:
                adjustment_factor = factor
                break

        position_pct = self.base_position_pct * adjustment_factor

        return {
            'drawdown': drawdown,
            'adjustment_factor': adjustment_factor,
            'position_pct': position_pct
        }

# ç¤ºä¾‹
# åŸºå‡†ä»“ä½80%, å›æ’¤5%é™è‡³60%, å›æ’¤10%é™è‡³40%, å›æ’¤15%é™è‡³20%
position_adjuster = DynamicPositionAdjustment(
    base_position_pct=0.8,
    drawdown_thresholds=[
        (0.15, 0.25),  # å›æ’¤>=15%, ä»“ä½é™è‡³25%
        (0.10, 0.50),  # å›æ’¤>=10%, ä»“ä½é™è‡³50%
        (0.05, 0.75),  # å›æ’¤>=5%, ä»“ä½é™è‡³75%
    ]
)

# æ¨¡æ‹Ÿè´¦æˆ·ä»·å€¼å˜åŒ–
values = [100000, 105000, 110000, 108000, 103000, 98000, 93000, 95000, 100000, 105000]

print("åŠ¨æ€ä»“ä½è°ƒæ•´ç¤ºä¾‹:")
for value in values:
    result = position_adjuster.calculate_position_pct(value)
    print(f"è´¦æˆ·ä»·å€¼: {value:,.0f}, å›æ’¤: {result['drawdown']:>6.2%}, "
          f"è°ƒæ•´ç³»æ•°: {result['adjustment_factor']:.2f}, "
          f"å»ºè®®ä»“ä½: {result['position_pct']:.0%}")
```

#### 3. æš‚åœäº¤æ˜“æœºåˆ¶

```python
class TradingPauseControl:
    """äº¤æ˜“æš‚åœæ§åˆ¶"""

    def __init__(self, pause_drawdown, resume_recovery):
        """
        å‚æ•°:
        pause_drawdown: float, æš‚åœäº¤æ˜“çš„å›æ’¤é˜ˆå€¼
        resume_recovery: float, æ¢å¤äº¤æ˜“çš„å›æ’¤æ¢å¤æ¯”ä¾‹
        """
        self.pause_drawdown = pause_drawdown
        self.resume_recovery = resume_recovery
        self.peak_value = None
        self.is_paused = False
        self.pause_level = None  # æš‚åœæ—¶çš„è´¦æˆ·ä»·å€¼

    def update_status(self, current_value):
        """
        æ›´æ–°äº¤æ˜“çŠ¶æ€

        å‚æ•°:
        current_value: float, å½“å‰è´¦æˆ·ä»·å€¼

        è¿”å›:
        dict: åŒ…å«çŠ¶æ€ä¿¡æ¯
        """
        if self.peak_value is None:
            self.peak_value = current_value
        else:
            self.peak_value = max(self.peak_value, current_value)

        drawdown = (current_value - self.peak_value) / self.peak_value

        if not self.is_paused:
            # å½“å‰æœªæš‚åœ,æ£€æŸ¥æ˜¯å¦éœ€è¦æš‚åœ
            if abs(drawdown) >= self.pause_drawdown:
                self.is_paused = True
                self.pause_level = current_value
                status = "æš‚åœäº¤æ˜“"
        else:
            # å½“å‰å·²æš‚åœ,æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¢å¤
            recovery_from_pause = (current_value - self.pause_level) / self.pause_level
            if recovery_from_pause >= self.resume_recovery:
                self.is_paused = False
                self.pause_level = None
                status = "æ¢å¤äº¤æ˜“"
            else:
                status = "ç»§ç»­æš‚åœ"

        return {
            'current_value': current_value,
            'peak_value': self.peak_value,
            'drawdown': drawdown,
            'is_paused': self.is_paused,
            'status': status,
            'can_trade': not self.is_paused
        }

# ç¤ºä¾‹
# å›æ’¤20%æš‚åœäº¤æ˜“,ä»æš‚åœä½ç½®æ¢å¤10%æ—¶æ¢å¤äº¤æ˜“
pause_control = TradingPauseControl(
    pause_drawdown=0.20,
    resume_recovery=0.10
)

# æ¨¡æ‹Ÿè´¦æˆ·ä»·å€¼å˜åŒ–
values = [100000, 95000, 90000, 85000, 80000,  # ä¸‹è·Œ20%
          82000, 85000, 88000, 90000]           # æ¢å¤

print("äº¤æ˜“æš‚åœæ§åˆ¶ç¤ºä¾‹:")
for value in values:
    result = pause_control.update_status(value)
    print(f"è´¦æˆ·ä»·å€¼: {result['current_value']:,.0f}, "
          f"å›æ’¤: {result['drawdown']:>6.2%}, "
          f"çŠ¶æ€: {result['status']}, "
          f"å¯å¦äº¤æ˜“: {'âœ“' if result['can_trade'] else 'âœ—'}")
```

### 11.4.3 å‹åŠ›æµ‹è¯•

**å‹åŠ›æµ‹è¯•**ï¼šæ¨¡æ‹Ÿæç«¯å¸‚åœºæƒ…å†µï¼Œè¯„ä¼°ç­–ç•¥çš„æŠ—é£é™©èƒ½åŠ›ã€‚

```python
class StressTest:
    """å‹åŠ›æµ‹è¯•"""

    def __init__(self, initial_capital):
        """
        å‚æ•°:
        initial_capital: float, åˆå§‹èµ„é‡‘
        """
        self.initial_capital = initial_capital

    def scenario_test(self, strategy_returns, scenarios):
        """
        åœºæ™¯æµ‹è¯•

        å‚æ•°:
        strategy_returns: Series, ç­–ç•¥æ”¶ç›Šç‡
        scenarios: dict, å‹åŠ›åœºæ™¯ {åœºæ™¯å: å¸‚åœºæ”¶ç›Šç‡}

        è¿”å›:
        DataFrame: å„åœºæ™¯ä¸‹çš„æµ‹è¯•ç»“æœ
        """
        results = []

        for scenario_name, market_returns in scenarios.items():
            # å‡è®¾ç­–ç•¥æ”¶ç›Šç‡ä¸å¸‚åœºæ”¶ç›Šç‡æœ‰ä¸€å®šç›¸å…³æ€§
            # è¿™é‡Œç®€åŒ–å¤„ç†,å¯ä»¥æ ¹æ®å®é™…æƒ…å†µå»ºç«‹æ›´å¤æ‚çš„æ¨¡å‹
            stressed_returns = strategy_returns * (1 + market_returns)

            final_value = self.initial_capital * (1 + stressed_returns).prod()
            total_return = (final_value - self.initial_capital) / self.initial_capital

            # è®¡ç®—å›æ’¤
            equity_curve = self.initial_capital * (1 + stressed_returns).cumprod()
            dd_df = calculate_drawdown_series(equity_curve)
            max_drawdown = dd_df['drawdown_pct'].min()

            results.append({
                'scenario': scenario_name,
                'final_value': final_value,
                'total_return': total_return,
                'max_drawdown': max_drawdown
            })

        return pd.DataFrame(results)

    def monte_carlo_simulation(self, strategy_returns, n_simulations=1000,
                              n_periods=252):
        """
        è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ

        å‚æ•°:
        strategy_returns: Series, å†å²æ”¶ç›Šç‡
        n_simulations: int, æ¨¡æ‹Ÿæ¬¡æ•°
        n_periods: int, æ¨¡æ‹Ÿå‘¨æœŸæ•°

        è¿”å›:
        dict: æ¨¡æ‹Ÿç»“æœç»Ÿè®¡
        """
        mean_return = strategy_returns.mean()
        std_return = strategy_returns.std()

        final_values = []
        max_drawdowns = []

        for _ in range(n_simulations):
            # éšæœºç”Ÿæˆæ”¶ç›Šç‡åºåˆ—
            simulated_returns = np.random.normal(mean_return, std_return, n_periods)
            equity_curve = self.initial_capital * (1 + simulated_returns).cumprod()

            final_values.append(equity_curve[-1])

            # è®¡ç®—æœ€å¤§å›æ’¤
            dd_df = calculate_drawdown_series(pd.Series(equity_curve))
            max_drawdowns.append(dd_df['drawdown_pct'].min())

        final_values = np.array(final_values)
        max_drawdowns = np.array(max_drawdowns)

        return {
            'mean_final_value': final_values.mean(),
            'median_final_value': np.median(final_values),
            'worst_case_5pct': np.percentile(final_values, 5),
            'best_case_95pct': np.percentile(final_values, 95),
            'probability_of_loss': (final_values < self.initial_capital).mean(),
            'mean_max_drawdown': max_drawdowns.mean(),
            'worst_max_drawdown': max_drawdowns.min()
        }

# ç¤ºä¾‹
stress_test = StressTest(initial_capital=100000)

# æ¨¡æ‹Ÿç­–ç•¥å†å²æ”¶ç›Šç‡
np.random.seed(42)
strategy_returns = pd.Series(np.random.randn(252) * 0.015)

# å®šä¹‰å‹åŠ›åœºæ™¯
scenarios = {
    'æ­£å¸¸å¸‚åœº': 0.0,
    'æ¸©å’Œä¸‹è·Œ': -0.1,
    'ä¸¥é‡ä¸‹è·Œ': -0.3,
    'æç«¯å´©ç›˜': -0.5,
    'å¼ºåŠ²ä¸Šæ¶¨': 0.3
}

# åœºæ™¯æµ‹è¯•
scenario_results = stress_test.scenario_test(strategy_returns, scenarios)
print("å‹åŠ›åœºæ™¯æµ‹è¯•ç»“æœ:")
print(scenario_results.to_string(index=False))

# è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
print("\nè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ(1000æ¬¡):")
mc_results = stress_test.monte_carlo_simulation(strategy_returns, n_simulations=1000)
for key, value in mc_results.items():
    if 'value' in key:
        print(f"{key}: {value:,.0f}å…ƒ")
    else:
        print(f"{key}: {value:.4f}")
```

---

## 11.5 æœ¬ç« å°ç»“ ğŸ“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **é£é™©ç®¡ç†çš„é‡è¦æ€§**
   - é£é™©ç®¡ç†æ˜¯é‡åŒ–äº¤æ˜“çš„ç”Ÿå‘½çº¿
   - ä¿æŠ¤èµ„é‡‘æ¯”è¿½æ±‚æ”¶ç›Šæ›´é‡è¦
   - ä¸€æ¬¡é‡å¤§æŸå¤±å¯èƒ½æŠ¹æ‰å¤šå¹´æ”¶ç›Š

2. **ä»“ä½ç®¡ç†æ–¹æ³•**
   - å›ºå®šé‡‘é¢æ³•ï¼šç®€å•ä½†ä¸çµæ´»
   - å›ºå®šæ¯”ä¾‹æ³•ï¼šéšè´¦æˆ·è§„æ¨¡è‡ªåŠ¨è°ƒæ•´
   - æ³¢åŠ¨ç‡è°ƒæ•´æ³•ï¼šè€ƒè™‘é£é™©ç‰¹å¾
   - å‡¯åˆ©å…¬å¼ï¼šç†è®ºæœ€ä¼˜,å®è·µä¸­éœ€æ‰“æŠ˜æ‰£
   - é£é™©å¹³ä»·ï¼šå¤šèµ„äº§ç»„åˆé£é™©å‡è¡¡

3. **æ­¢æŸæ­¢ç›ˆ**
   - æ­¢æŸæ˜¯ä¿å‘½çº¢çº¿,å¿…é¡»ä¸¥æ ¼æ‰§è¡Œ
   - æ­¢ç›ˆè¦æœ‰çºªå¾‹æ€§,é¿å…è´ªå©ª
   - å¯ä»¥é‡‡ç”¨å›ºå®šã€ç§»åŠ¨ã€åŠ¨æ€ç­‰å¤šç§æ–¹å¼
   - åˆ†æ‰¹æ­¢ç›ˆå¯ä»¥å¹³è¡¡æ”¶ç›Šå’Œé£é™©

4. **å›æ’¤æ§åˆ¶**
   - ç›‘æ§æœ€å¤§å›æ’¤,è®¾å®šå®¹å¿é™åº¦
   - å›æ’¤è¿‡å¤§æ—¶é™ä½ä»“ä½æˆ–æš‚åœäº¤æ˜“
   - å®šæœŸè¿›è¡Œå‹åŠ›æµ‹è¯•,è¯„ä¼°æç«¯æƒ…å†µ
   - ä¿æŒå¿ƒç†å’Œèµ„é‡‘çš„éŸ§æ€§

### é£é™©ç®¡ç†æ¸…å• âœ…

- [ ] æ˜ç¡®è‡ªå·±çš„é£é™©æ‰¿å—èƒ½åŠ›
- [ ] åˆ¶å®šä¹¦é¢çš„é£é™©ç®¡ç†è§„åˆ™
- [ ] è®¾å®šå•ç¬”äº¤æ˜“æœ€å¤§æŸå¤±é™é¢
- [ ] è®¾å®šè´¦æˆ·æœ€å¤§å›æ’¤é™é¢
- [ ] é€‰æ‹©åˆé€‚çš„ä»“ä½ç®¡ç†æ–¹æ³•
- [ ] ä¸ºæ¯ç¬”äº¤æ˜“è®¾å®šæ­¢æŸ
- [ ] åˆ¶å®šæ­¢ç›ˆç­–ç•¥
- [ ] å»ºç«‹äº¤æ˜“æš‚åœæœºåˆ¶
- [ ] å®šæœŸè¿›è¡Œå‹åŠ›æµ‹è¯•
- [ ] è®°å½•å¹¶åˆ†ææ¯æ¬¡é£é™©äº‹ä»¶

### å®ç”¨å»ºè®® ğŸ’¡

1. **ä»ä¿å®ˆå¼€å§‹**
   - æ–°æ‰‹å»ºè®®ä½¿ç”¨è¾ƒå°ä»“ä½(å¦‚10-20%)
   - éšç€ç»éªŒç§¯ç´¯é€æ­¥æé«˜
   - çœŸé‡‘ç™½é“¶çš„å‹åŠ›ä¸æ¨¡æ‹Ÿå®Œå…¨ä¸åŒ

2. **ä¸è¦è¿‡åº¦ä¼˜åŒ–**
   - é£é™©ç®¡ç†è§„åˆ™åº”ç®€å•æ˜äº†
   - è¿‡äºå¤æ‚éš¾ä»¥æ‰§è¡Œ
   - å…³é”®æ˜¯æŒç»­æ‰§è¡Œ,ä¸æ˜¯å®Œç¾è®¾è®¡

3. **æƒ…ç»ªç®¡ç†**
   - é¢„å…ˆåˆ¶å®šè§„åˆ™,é¿å…ä¸´åœºæƒ…ç»ªåŒ–å†³ç­–
   - äºæŸåä¸è¦æ€¥äºç¿»æœ¬
   - ç›ˆåˆ©åä¸è¦è¿‡åº¦è‡ªä¿¡

4. **æŒç»­å­¦ä¹ **
   - æ¯æ¬¡æŸå¤±éƒ½æ˜¯å­¦ä¹ æœºä¼š
   - å®šæœŸå›é¡¾é£é™©äº‹ä»¶
   - ä¸æ–­å®Œå–„é£é™©ç®¡ç†ä½“ç³»

---

**ä¸‹ä¸€ç« é¢„å‘Š** ğŸ‘‰

ç¬¬åäºŒç« ã€Šå›æµ‹ä¸å®ç›˜ã€‹å°†ä»‹ç»å¦‚ä½•å¯¹ç­–ç•¥è¿›è¡Œç§‘å­¦çš„å›æµ‹éªŒè¯,è¯†åˆ«å›æµ‹ä¸­çš„å¸¸è§é™·é˜±,ä»¥åŠå¦‚ä½•å¹³ç¨³åœ°ä»å›æµ‹è¿‡æ¸¡åˆ°å®ç›˜äº¤æ˜“ã€‚å›æµ‹æ˜¯ç­–ç•¥ä¸Šçº¿å‰çš„å¿…ç»ä¹‹è·¯,æŒæ¡æ­£ç¡®çš„å›æµ‹æ–¹æ³•è‡³å…³é‡è¦ï¼
