# ç¬¬åå…­ç« ï¼šç®€å•ç­–ç•¥å®ç°

**é€‚åˆäººç¾¤**: æŒæ¡PythonåŸºç¡€å’Œæ•°æ®è·å–çš„æŠ•èµ„è€…
**å­¦ä¹ æ—¶é—´**: 3-4å¤©ï¼ˆè¾¹å­¦è¾¹ç»ƒï¼‰
**ç›®æ ‡**: èƒ½å¤Ÿç‹¬ç«‹å®ç°ç»å…¸é‡åŒ–ç­–ç•¥ï¼Œç†è§£ç­–ç•¥çš„å®Œæ•´å¼€å‘æµç¨‹

---

> ğŸ’¡ **æœ¬ç« å®šä½**ï¼šä»é›¶åˆ°ä¸€ï¼Œæ‰‹æŠŠæ‰‹æ•™ä½ å®ç°ä¸‰ä¸ªç»å…¸é‡åŒ–ç­–ç•¥ã€‚ä¸ä½¿ç”¨å¤æ‚æ¡†æ¶ï¼Œç”¨æœ€ç®€å•ç›´æ¥çš„æ–¹å¼ç†è§£ç­–ç•¥é€»è¾‘ã€‚æ¯ä¸ªç­–ç•¥éƒ½æœ‰å®Œæ•´å¯è¿è¡Œä»£ç ï¼Œæ”¹æ”¹å‚æ•°å°±èƒ½ç”¨ã€‚

---

## 15.1 ç­–ç•¥å¼€å‘åŸºæœ¬æµç¨‹

### é‡åŒ–ç­–ç•¥å¼€å‘çš„å®Œæ•´æ­¥éª¤

```
ç¬¬1æ­¥ï¼šç­–ç•¥æ„æ€
   â†“
   æ˜ç¡®äº¤æ˜“é€»è¾‘ï¼ˆä»€ä¹ˆæ—¶å€™ä¹°ï¼Ÿä»€ä¹ˆæ—¶å€™å–ï¼Ÿï¼‰

ç¬¬2æ­¥ï¼šæ•°æ®å‡†å¤‡
   â†“
   è·å–å†å²æ•°æ®ï¼ˆKçº¿ã€è´¢åŠ¡æ•°æ®ã€æŒ‡æ ‡ç­‰ï¼‰

ç¬¬3æ­¥ï¼šç­–ç•¥ç¼–ç 
   â†“
   å°†äº¤æ˜“é€»è¾‘è½¬åŒ–ä¸ºä»£ç ï¼ˆç”Ÿæˆä¹°å–ä¿¡å·ï¼‰

ç¬¬4æ­¥ï¼šå›æµ‹éªŒè¯
   â†“
   åœ¨å†å²æ•°æ®ä¸Šæµ‹è¯•ç­–ç•¥è¡¨ç°

ç¬¬5æ­¥ï¼šæ€§èƒ½è¯„ä¼°
   â†“
   è®¡ç®—æ”¶ç›Šç‡ã€æœ€å¤§å›æ’¤ã€å¤æ™®æ¯”ç‡ç­‰æŒ‡æ ‡

ç¬¬6æ­¥ï¼šå‚æ•°ä¼˜åŒ–
   â†“
   è°ƒæ•´å‚æ•°ï¼Œå¯»æ‰¾æœ€ä¼˜ç»„åˆ

ç¬¬7æ­¥ï¼šå®ç›˜æ¨¡æ‹Ÿ
   â†“
   å°èµ„é‡‘è¯•è¿è¡Œï¼ŒéªŒè¯å®ç›˜å¯è¡Œæ€§
```

---

### ç­–ç•¥ä»£ç çš„åŸºæœ¬ç»“æ„

ä¸€ä¸ªå®Œæ•´çš„ç­–ç•¥ä»£ç é€šå¸¸åŒ…å«ä»¥ä¸‹éƒ¨åˆ†ï¼š

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ==================== ç¬¬1éƒ¨åˆ†ï¼šæ•°æ®è·å– ====================
def get_data(symbol, start_date, end_date):
    """
    è·å–è‚¡ç¥¨å†å²æ•°æ®
    """
    # ä»æ•°æ®æºè·å–æ•°æ®
    pass

# ==================== ç¬¬2éƒ¨åˆ†ï¼šç­–ç•¥é€»è¾‘ ====================
def strategy_signal(data):
    """
    ç”Ÿæˆä¹°å–ä¿¡å·
    è¿”å›ï¼š1=ä¹°å…¥ï¼Œ-1=å–å‡ºï¼Œ0=æŒä»“ä¸åŠ¨
    """
    # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
    # ç”Ÿæˆäº¤æ˜“ä¿¡å·
    pass

# ==================== ç¬¬3éƒ¨åˆ†ï¼šå›æµ‹å¼•æ“ ====================
def backtest(data, signals, initial_capital=100000):
    """
    ç®€å•çš„å‘é‡åŒ–å›æµ‹
    """
    # è®¡ç®—æŒä»“
    # è®¡ç®—æ”¶ç›Š
    pass

# ==================== ç¬¬4éƒ¨åˆ†ï¼šæ€§èƒ½è¯„ä¼° ====================
def evaluate_performance(returns):
    """
    è®¡ç®—ç­–ç•¥è¡¨ç°æŒ‡æ ‡
    """
    # å¹´åŒ–æ”¶ç›Šç‡
    # æœ€å¤§å›æ’¤
    # å¤æ™®æ¯”ç‡
    pass

# ==================== ç¬¬5éƒ¨åˆ†ï¼šä¸»ç¨‹åº ====================
if __name__ == '__main__':
    # 1. è·å–æ•°æ®
    data = get_data('000001.SZ', '2020-01-01', '2024-01-01')

    # 2. ç”Ÿæˆä¿¡å·
    signals = strategy_signal(data)

    # 3. å›æµ‹
    results = backtest(data, signals)

    # 4. è¯„ä¼°
    performance = evaluate_performance(results)

    # 5. å¯è§†åŒ–
    plot_results(results)
```

---

### å‘é‡åŒ–å›æµ‹ vs äº‹ä»¶é©±åŠ¨å›æµ‹

**å‘é‡åŒ–å›æµ‹**ï¼ˆæœ¬ç« ä½¿ç”¨ï¼‰ï¼š
```python
# ä¸€æ¬¡æ€§è®¡ç®—æ‰€æœ‰ä¿¡å·
data['signal'] = np.where(data['ma5'] > data['ma20'], 1, -1)
data['returns'] = data['close'].pct_change()
data['strategy_returns'] = data['signal'].shift(1) * data['returns']

ä¼˜ç‚¹ï¼šä»£ç ç®€å•ã€è¿è¡Œå¿«é€Ÿã€é€‚åˆå…¥é—¨
ç¼ºç‚¹ï¼šæ— æ³•æ¨¡æ‹Ÿå¤æ‚çš„è®¢å•é€»è¾‘ï¼ˆæ»‘ç‚¹ã€æ‰‹ç»­è´¹ç»†èŠ‚ç­‰ï¼‰
```

**äº‹ä»¶é©±åŠ¨å›æµ‹**ï¼ˆè¿›é˜¶ç¯‡ä½¿ç”¨ï¼‰ï¼š
```python
# é€æ¡æ¨¡æ‹Ÿå†å²è¡Œæƒ…
for bar in data:
    if should_buy(bar):
        broker.buy(size=100)
    elif should_sell(bar):
        broker.sell(size=100)

ä¼˜ç‚¹ï¼šæ›´çœŸå®ã€å¯æ¨¡æ‹Ÿå¤æ‚é€»è¾‘
ç¼ºç‚¹ï¼šä»£ç å¤æ‚ã€éœ€è¦å›æµ‹æ¡†æ¶ï¼ˆå¦‚backtraderï¼‰
```

**æœ¬ç« é€‰æ‹©**ï¼šä½¿ç”¨å‘é‡åŒ–å›æµ‹ï¼Œé‡ç‚¹ç†è§£ç­–ç•¥é€»è¾‘ï¼Œä¸çº ç»“å›æµ‹ç»†èŠ‚ã€‚

---

## 15.2 åŒå‡çº¿ç­–ç•¥å®ç°

### ç­–ç•¥åŸç†

**æ ¸å¿ƒæ€æƒ³**ï¼šçŸ­æœŸå‡çº¿ä¸Šç©¿é•¿æœŸå‡çº¿æ—¶ä¹°å…¥ï¼ˆé‡‘å‰ï¼‰ï¼Œä¸‹ç©¿æ—¶å–å‡ºï¼ˆæ­»å‰ï¼‰ã€‚

```
ä»·æ ¼è¶‹åŠ¿åˆ¤æ–­ï¼š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
       çŸ­æœŸå‡çº¿ï¼ˆå¿«é€Ÿå“åº”ä»·æ ¼å˜åŒ–ï¼‰
       â†“
    â—â—â—â—â—â—â—
   â—       â—â—â—
  â—           â—â—
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â—â—â”â”â”â”  â† é•¿æœŸå‡çº¿ï¼ˆå¹³æ»‘è¶‹åŠ¿ï¼‰

é‡‘å‰ï¼ˆä¹°å…¥ä¿¡å·ï¼‰ï¼šçŸ­å‡çº¿ä»ä¸‹æ–¹ç©¿è¶Šé•¿å‡çº¿
æ­»å‰ï¼ˆå–å‡ºä¿¡å·ï¼‰ï¼šçŸ­å‡çº¿ä»ä¸Šæ–¹ç©¿è¶Šé•¿å‡çº¿
```

**å‚æ•°è®¾ç½®**ï¼š
- çŸ­æœŸå‡çº¿ï¼š5æ—¥æˆ–10æ—¥ï¼ˆMA5/MA10ï¼‰
- é•¿æœŸå‡çº¿ï¼š20æ—¥æˆ–60æ—¥ï¼ˆMA20/MA60ï¼‰

**é€‚ç”¨å¸‚åœº**ï¼šè¶‹åŠ¿æ˜æ˜¾çš„å¸‚åœºï¼ˆç‰›å¸‚ã€ç†Šå¸‚ï¼‰ï¼Œéœ‡è¡å¸‚æ•ˆæœå·®ã€‚

---

### å®Œæ•´ä»£ç å®ç°

```python
"""
åŒå‡çº¿ç­–ç•¥ - å®Œæ•´ç‰ˆæœ¬
ç­–ç•¥ï¼šMA5ä¸Šç©¿MA20ä¹°å…¥ï¼Œä¸‹ç©¿å–å‡º
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tushare as ts

# è®¾ç½®ä¸­æ–‡æ˜¾ç¤º
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ==================== 1. æ•°æ®è·å– ====================

def get_stock_data(symbol, start_date, end_date):
    """
    è·å–è‚¡ç¥¨å†å²æ•°æ®

    å‚æ•°ï¼š
        symbol: è‚¡ç¥¨ä»£ç ï¼ˆå¦‚'000001.SZ'ï¼‰
        start_date: å¼€å§‹æ—¥æœŸï¼ˆ'20200101'ï¼‰
        end_date: ç»“æŸæ—¥æœŸï¼ˆ'20240101'ï¼‰
    """
    # åˆå§‹åŒ–Tushareï¼ˆéœ€è¦æå‰æ³¨å†Œè·å–tokenï¼‰
    ts.set_token('ä½ çš„tushare_token')
    pro = ts.pro_api()

    # è·å–æ—¥çº¿æ•°æ®
    df = pro.daily(
        ts_code=symbol,
        start_date=start_date,
        end_date=end_date
    )

    # æ•°æ®æ¸…æ´—
    df['trade_date'] = pd.to_datetime(df['trade_date'])
    df = df.sort_values('trade_date')
    df = df.reset_index(drop=True)

    # é‡å‘½ååˆ—ï¼ˆä¾¿äºç†è§£ï¼‰
    df = df.rename(columns={
        'trade_date': 'date',
        'open': 'open',
        'high': 'high',
        'low': 'low',
        'close': 'close',
        'vol': 'volume'
    })

    return df[['date', 'open', 'high', 'low', 'close', 'volume']]


# ==================== 2. ç­–ç•¥ä¿¡å·ç”Ÿæˆ ====================

def generate_ma_signals(data, short_window=5, long_window=20):
    """
    ç”ŸæˆåŒå‡çº¿äº¤æ˜“ä¿¡å·

    å‚æ•°ï¼š
        data: è‚¡ç¥¨æ•°æ®ï¼ˆDataFrameï¼‰
        short_window: çŸ­æœŸå‡çº¿å‘¨æœŸ
        long_window: é•¿æœŸå‡çº¿å‘¨æœŸ

    è¿”å›ï¼š
        æ·»åŠ äº†ä¿¡å·åˆ—çš„DataFrame
    """
    df = data.copy()

    # è®¡ç®—çŸ­æœŸå’Œé•¿æœŸå‡çº¿
    df['ma_short'] = df['close'].rolling(window=short_window).mean()
    df['ma_long'] = df['close'].rolling(window=long_window).mean()

    # ç”Ÿæˆä¿¡å·ï¼ˆ1=æŒæœ‰ï¼Œ0=ç©ºä»“ï¼‰
    df['signal'] = 0.0
    df['signal'][short_window:] = np.where(
        df['ma_short'][short_window:] > df['ma_long'][short_window:],
        1.0,
        0.0
    )

    # ç”Ÿæˆäº¤æ˜“æŒ‡ä»¤ï¼ˆ1=ä¹°å…¥ï¼Œ-1=å–å‡ºï¼Œ0=ä¸åŠ¨ï¼‰
    df['positions'] = df['signal'].diff()

    return df


# ==================== 3. ç®€å•å›æµ‹å¼•æ“ ====================

def simple_backtest(data, initial_capital=100000, commission=0.0003):
    """
    ç®€å•çš„å‘é‡åŒ–å›æµ‹

    å‚æ•°ï¼š
        data: åŒ…å«ä¿¡å·çš„è‚¡ç¥¨æ•°æ®
        initial_capital: åˆå§‹èµ„é‡‘
        commission: æ‰‹ç»­è´¹ç‡ï¼ˆåŒè¾¹ï¼Œä¹°å…¥+å–å‡ºï¼‰

    è¿”å›ï¼š
        å›æµ‹ç»“æœDataFrame
    """
    df = data.copy()

    # è®¡ç®—æ¯æ—¥æ”¶ç›Šç‡
    df['daily_return'] = df['close'].pct_change()

    # è®¡ç®—ç­–ç•¥æ”¶ç›Šï¼ˆè€ƒè™‘ä¿¡å·å»¶è¿Ÿï¼Œç”¨æ˜¨å¤©çš„ä¿¡å·äº¤æ˜“ä»Šå¤©ï¼‰
    df['strategy_return'] = df['signal'].shift(1) * df['daily_return']

    # æ‰£é™¤äº¤æ˜“æˆæœ¬ï¼ˆæ¯æ¬¡äº¤æ˜“æ‰£é™¤æ‰‹ç»­è´¹ï¼‰
    df['trade_cost'] = 0.0
    df.loc[df['positions'] != 0, 'trade_cost'] = commission
    df['strategy_return'] = df['strategy_return'] - df['trade_cost']

    # è®¡ç®—ç´¯è®¡æ”¶ç›Š
    df['cumulative_return'] = (1 + df['daily_return']).cumprod()
    df['strategy_cumulative_return'] = (1 + df['strategy_return']).cumprod()

    # è®¡ç®—èµ„é‡‘æ›²çº¿
    df['portfolio_value'] = initial_capital * df['strategy_cumulative_return']

    return df


# ==================== 4. æ€§èƒ½è¯„ä¼° ====================

def calculate_performance(data):
    """
    è®¡ç®—ç­–ç•¥æ€§èƒ½æŒ‡æ ‡
    """
    df = data.dropna()

    # åŸºç¡€æŒ‡æ ‡
    total_return = df['strategy_cumulative_return'].iloc[-1] - 1
    benchmark_return = df['cumulative_return'].iloc[-1] - 1

    # å¹´åŒ–æ”¶ç›Šç‡
    days = (df['date'].iloc[-1] - df['date'].iloc[0]).days
    annual_return = (1 + total_return) ** (365 / days) - 1

    # æœ€å¤§å›æ’¤
    cummax = df['strategy_cumulative_return'].cummax()
    drawdown = (df['strategy_cumulative_return'] - cummax) / cummax
    max_drawdown = drawdown.min()

    # å¤æ™®æ¯”ç‡ï¼ˆå‡è®¾æ— é£é™©åˆ©ç‡3%ï¼‰
    risk_free_rate = 0.03
    excess_return = df['strategy_return'].mean() * 252 - risk_free_rate
    volatility = df['strategy_return'].std() * np.sqrt(252)
    sharpe_ratio = excess_return / volatility if volatility != 0 else 0

    # èƒœç‡
    winning_trades = len(df[df['strategy_return'] > 0])
    total_trades = len(df[df['strategy_return'] != 0])
    win_rate = winning_trades / total_trades if total_trades > 0 else 0

    # æ‰“å°ç»“æœ
    print("=" * 50)
    print("ç­–ç•¥è¡¨ç°æ€»ç»“")
    print("=" * 50)
    print(f"å›æµ‹åŒºé—´: {df['date'].iloc[0].date()} è‡³ {df['date'].iloc[-1].date()}")
    print(f"åˆå§‹èµ„é‡‘: Â¥100,000")
    print(f"æœ€ç»ˆèµ„é‡‘: Â¥{df['portfolio_value'].iloc[-1]:,.2f}")
    print("-" * 50)
    print(f"ç­–ç•¥æ€»æ”¶ç›Šç‡: {total_return*100:.2f}%")
    print(f"åŸºå‡†æ”¶ç›Šç‡: {benchmark_return*100:.2f}%")
    print(f"è¶…é¢æ”¶ç›Š: {(total_return - benchmark_return)*100:.2f}%")
    print("-" * 50)
    print(f"å¹´åŒ–æ”¶ç›Šç‡: {annual_return*100:.2f}%")
    print(f"æœ€å¤§å›æ’¤: {max_drawdown*100:.2f}%")
    print(f"å¤æ™®æ¯”ç‡: {sharpe_ratio:.2f}")
    print(f"èƒœç‡: {win_rate*100:.2f}%")
    print("=" * 50)

    return {
        'total_return': total_return,
        'annual_return': annual_return,
        'max_drawdown': max_drawdown,
        'sharpe_ratio': sharpe_ratio,
        'win_rate': win_rate
    }


# ==================== 5. å¯è§†åŒ– ====================

def plot_strategy_results(data):
    """
    ç»˜åˆ¶ç­–ç•¥å›æµ‹ç»“æœå›¾è¡¨
    """
    df = data.dropna()

    # åˆ›å»ºå­å›¾
    fig, axes = plt.subplots(3, 1, figsize=(15, 12))

    # å­å›¾1ï¼šä»·æ ¼å’Œå‡çº¿
    ax1 = axes[0]
    ax1.plot(df['date'], df['close'], label='æ”¶ç›˜ä»·', linewidth=1, alpha=0.7)
    ax1.plot(df['date'], df['ma_short'], label='MA5', linewidth=1)
    ax1.plot(df['date'], df['ma_long'], label='MA20', linewidth=1)

    # æ ‡è®°ä¹°å–ç‚¹
    buy_signals = df[df['positions'] == 1]
    sell_signals = df[df['positions'] == -1]
    ax1.scatter(buy_signals['date'], buy_signals['close'],
                marker='^', color='red', s=100, label='ä¹°å…¥', zorder=5)
    ax1.scatter(sell_signals['date'], sell_signals['close'],
                marker='v', color='green', s=100, label='å–å‡º', zorder=5)

    ax1.set_title('åŒå‡çº¿ç­–ç•¥ - ä»·æ ¼ä¸äº¤æ˜“ä¿¡å·', fontsize=14, fontweight='bold')
    ax1.set_ylabel('ä»·æ ¼ï¼ˆå…ƒï¼‰')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)

    # å­å›¾2ï¼šç´¯è®¡æ”¶ç›Šå¯¹æ¯”
    ax2 = axes[1]
    ax2.plot(df['date'], (df['cumulative_return'] - 1) * 100,
             label='ä¹°å…¥æŒæœ‰', linewidth=2)
    ax2.plot(df['date'], (df['strategy_cumulative_return'] - 1) * 100,
             label='åŒå‡çº¿ç­–ç•¥', linewidth=2)
    ax2.set_title('ç´¯è®¡æ”¶ç›Šç‡å¯¹æ¯”', fontsize=14, fontweight='bold')
    ax2.set_ylabel('æ”¶ç›Šç‡ï¼ˆ%ï¼‰')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    ax2.axhline(y=0, color='black', linestyle='--', linewidth=0.5)

    # å­å›¾3ï¼šå›æ’¤æ›²çº¿
    ax3 = axes[2]
    cummax = df['strategy_cumulative_return'].cummax()
    drawdown = (df['strategy_cumulative_return'] - cummax) / cummax * 100
    ax3.fill_between(df['date'], drawdown, 0, color='red', alpha=0.3)
    ax3.plot(df['date'], drawdown, color='red', linewidth=1)
    ax3.set_title('ç­–ç•¥å›æ’¤æ›²çº¿', fontsize=14, fontweight='bold')
    ax3.set_xlabel('æ—¥æœŸ')
    ax3.set_ylabel('å›æ’¤ï¼ˆ%ï¼‰')
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


# ==================== 6. ä¸»ç¨‹åº ====================

def run_ma_strategy(symbol='000001.SZ', start='20200101', end='20240101'):
    """
    è¿è¡ŒåŒå‡çº¿ç­–ç•¥çš„ä¸»å‡½æ•°
    """
    print(f"\nå¼€å§‹å›æµ‹ï¼š{symbol}")
    print(f"å›æµ‹åŒºé—´ï¼š{start} - {end}\n")

    # 1. è·å–æ•°æ®
    print("æ­£åœ¨è·å–æ•°æ®...")
    data = get_stock_data(symbol, start, end)
    print(f"æ•°æ®è·å–å®Œæˆï¼Œå…± {len(data)} æ¡è®°å½•\n")

    # 2. ç”Ÿæˆä¿¡å·
    print("æ­£åœ¨ç”Ÿæˆäº¤æ˜“ä¿¡å·...")
    data_with_signals = generate_ma_signals(data, short_window=5, long_window=20)
    print(f"ä¿¡å·ç”Ÿæˆå®Œæˆ\n")

    # 3. å›æµ‹
    print("æ­£åœ¨æ‰§è¡Œå›æµ‹...")
    results = simple_backtest(data_with_signals, initial_capital=100000)
    print(f"å›æµ‹å®Œæˆ\n")

    # 4. æ€§èƒ½è¯„ä¼°
    performance = calculate_performance(results)

    # 5. å¯è§†åŒ–
    print("\næ­£åœ¨ç”Ÿæˆå›¾è¡¨...")
    plot_strategy_results(results)

    return results, performance


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

if __name__ == '__main__':
    # è¿è¡Œç­–ç•¥
    results, performance = run_ma_strategy(
        symbol='000001.SZ',  # å¹³å®‰é“¶è¡Œ
        start='20200101',
        end='20240101'
    )

    # æŸ¥çœ‹å‰å‡ æ¡æ•°æ®
    print("\næ•°æ®é¢„è§ˆ:")
    print(results[['date', 'close', 'ma_short', 'ma_long',
                   'signal', 'positions']].head(25))
```

---

### ç­–ç•¥ä¼˜åŒ–æ–¹å‘

**å‚æ•°ä¼˜åŒ–**ï¼š

```python
# æµ‹è¯•ä¸åŒçš„å‡çº¿ç»„åˆ
ma_combinations = [
    (5, 10),   # è¶…çŸ­æœŸ
    (5, 20),   # çŸ­æœŸ
    (10, 30),  # ä¸­æœŸ
    (20, 60),  # é•¿æœŸ
]

best_sharpe = -999
best_params = None

for short, long in ma_combinations:
    signals = generate_ma_signals(data, short, long)
    results = simple_backtest(signals)
    perf = calculate_performance(results)

    if perf['sharpe_ratio'] > best_sharpe:
        best_sharpe = perf['sharpe_ratio']
        best_params = (short, long)

print(f"æœ€ä½³å‚æ•°ç»„åˆï¼šMA{best_params[0]} / MA{best_params[1]}")
```

**ç­–ç•¥æ”¹è¿›æ€è·¯**ï¼š

1. **æ·»åŠ è¿‡æ»¤æ¡ä»¶**
   ```python
   # åªåœ¨æˆäº¤é‡æ”¾å¤§æ—¶äº¤æ˜“
   volume_ma = df['volume'].rolling(20).mean()
   df['signal'] = np.where(
       (df['ma_short'] > df['ma_long']) & (df['volume'] > volume_ma),
       1.0, 0.0
   )
   ```

2. **åŠ å…¥æ­¢æŸæ­¢ç›ˆ**
   ```python
   # äºæŸ5%æ­¢æŸï¼Œç›ˆåˆ©10%æ­¢ç›ˆ
   stop_loss = 0.95
   take_profit = 1.10
   ```

3. **å¤šè‚¡è½®åŠ¨**
   ```python
   # ä¸æ˜¯å•ä¸€è‚¡ç¥¨ï¼Œè€Œæ˜¯é€‰æ‹©ä¿¡å·æœ€å¼ºçš„Nåªè‚¡ç¥¨
   ```

---

### âš ï¸ åŒå‡çº¿ç­–ç•¥çš„å±€é™æ€§

```
ä¼˜ç‚¹ï¼š
âœ… é€»è¾‘ç®€å•ï¼Œæ˜“äºç†è§£å’Œå®ç°
âœ… é€‚åˆè¶‹åŠ¿æ˜æ˜¾çš„å¸‚åœº
âœ… å¯è‡ªåŠ¨åŒ–æ‰§è¡Œ

ç¼ºç‚¹ï¼š
âŒ éœ‡è¡å¸‚é¢‘ç¹äº¤æ˜“ï¼Œæ‰‹ç»­è´¹é«˜æ˜‚
âŒ æ»åæ€§å¼ºï¼Œé”™è¿‡è¶‹åŠ¿å‰æœŸå’ŒåæœŸ
âŒ å®¹æ˜“äº§ç”Ÿè™šå‡ä¿¡å·

é€‚ç”¨åœºæ™¯ï¼š
â­ è¶‹åŠ¿æ˜æ˜¾çš„ç‰›å¸‚æˆ–ç†Šå¸‚
â­ æµåŠ¨æ€§å¥½çš„å¤§ç›˜è‚¡
â­ ä½œä¸ºå…¶ä»–ç­–ç•¥çš„è¾…åŠ©å·¥å…·
```

---

## 15.3 æµ·é¾Ÿäº¤æ˜“æ³•åˆ™å®ç°

### ç­–ç•¥åŸç†

æµ·é¾Ÿäº¤æ˜“æ³•åˆ™æ˜¯ä¼ å¥‡äº¤æ˜“å¤§å¸ˆç†æŸ¥å¾·Â·ä¸¹å°¼æ–¯çš„ç»å…¸ç­–ç•¥ï¼Œå±äº**è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥**ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š
- ä»·æ ¼çªç ´Næ—¥æœ€é«˜ä»·æ—¶ä¹°å…¥
- ä»·æ ¼è·Œç ´Næ—¥æœ€ä½ä»·æ—¶å–å‡º
- ç”¨ATRï¼ˆçœŸå®æ³¢å¹…ï¼‰æ¥è®¾ç½®æ­¢æŸä½

```
ä»·æ ¼é€šé“çªç ´ï¼š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          â—  â† çªç ´20æ—¥æ–°é«˜ï¼ˆä¹°å…¥ï¼‰
         â—â—
        â—  â—
â—â”â”â”â”â”â—â”â”â”â—â”â”â”â”â”â”â”  â† 20æ—¥æœ€é«˜ä»·
â—      â—   â—
â—     â—    â—
â—â”â”â”â—â”â”â”â”â”â—â”â”â”â”â”â”â”  â† 20æ—¥æœ€ä½ä»·
  â—             â—  â† è·Œç ´10æ—¥æ–°ä½ï¼ˆå–å‡ºï¼‰
   â—â—â—â—â—â—â—â—â—â—â—
```

**å‚æ•°è®¾ç½®**ï¼š
- å…¥åœºç³»ç»Ÿï¼šçªç ´20æ—¥æœ€é«˜ä»·ä¹°å…¥
- å‡ºåœºç³»ç»Ÿï¼šè·Œç ´10æ—¥æœ€ä½ä»·å–å‡º
- æ­¢æŸï¼š2å€ATR

---

### å®Œæ•´ä»£ç å®ç°

```python
"""
æµ·é¾Ÿäº¤æ˜“æ³•åˆ™ - å®Œæ•´ç‰ˆæœ¬
ç­–ç•¥ï¼šçªç ´20æ—¥æ–°é«˜ä¹°å…¥ï¼Œè·Œç ´10æ—¥æ–°ä½å–å‡ºï¼ŒATRæ­¢æŸ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tushare as ts

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ==================== 1. æŠ€æœ¯æŒ‡æ ‡è®¡ç®— ====================

def calculate_atr(data, period=20):
    """
    è®¡ç®—ATRï¼ˆAverage True Rangeï¼ŒçœŸå®æ³¢å¹…ï¼‰

    ATRæ˜¯è¡¡é‡å¸‚åœºæ³¢åŠ¨æ€§çš„æŒ‡æ ‡ï¼Œç”¨äºè®¾ç½®æ­¢æŸä½
    """
    df = data.copy()

    # è®¡ç®—True Rangeï¼ˆçœŸå®æ³¢å¹…ï¼‰
    df['h-l'] = df['high'] - df['low']
    df['h-pc'] = abs(df['high'] - df['close'].shift(1))
    df['l-pc'] = abs(df['low'] - df['close'].shift(1))

    df['tr'] = df[['h-l', 'h-pc', 'l-pc']].max(axis=1)

    # è®¡ç®—ATRï¼ˆTRçš„ç§»åŠ¨å¹³å‡ï¼‰
    df['atr'] = df['tr'].rolling(window=period).mean()

    return df


def calculate_donchian_channel(data, entry_period=20, exit_period=10):
    """
    è®¡ç®—å”å¥‡å®‰é€šé“ï¼ˆDonchian Channelï¼‰

    ä¸Šè½¨ï¼šNæ—¥æœ€é«˜ä»·
    ä¸‹è½¨ï¼šNæ—¥æœ€ä½ä»·
    """
    df = data.copy()

    # å…¥åœºé€šé“ï¼ˆçªç ´20æ—¥æ–°é«˜ä¹°å…¥ï¼‰
    df['upper_band'] = df['high'].rolling(window=entry_period).max()

    # å‡ºåœºé€šé“ï¼ˆè·Œç ´10æ—¥æ–°ä½å–å‡ºï¼‰
    df['lower_band'] = df['low'].rolling(window=exit_period).min()

    return df


# ==================== 2. æµ·é¾Ÿäº¤æ˜“ä¿¡å· ====================

def generate_turtle_signals(data, entry_period=20, exit_period=10, atr_period=20):
    """
    ç”Ÿæˆæµ·é¾Ÿäº¤æ˜“ä¿¡å·
    """
    df = data.copy()

    # è®¡ç®—ATR
    df = calculate_atr(df, period=atr_period)

    # è®¡ç®—å”å¥‡å®‰é€šé“
    df = calculate_donchian_channel(df, entry_period, exit_period)

    # åˆå§‹åŒ–ä¿¡å·åˆ—
    df['signal'] = 0  # 0=ç©ºä»“, 1=æŒä»“
    df['positions'] = 0  # äº¤æ˜“æŒ‡ä»¤

    # ç”Ÿæˆä¿¡å·ï¼ˆå‘é‡åŒ–æ–¹å¼ï¼‰
    in_position = False
    entry_price = 0
    stop_loss = 0

    for i in range(1, len(df)):
        if pd.isna(df.loc[i, 'upper_band']) or pd.isna(df.loc[i, 'atr']):
            continue

        # å½“å‰ä¸æŒä»“
        if not in_position:
            # çªç ´ä¸Šè½¨ä¹°å…¥
            if df.loc[i, 'close'] > df.loc[i-1, 'upper_band']:
                df.loc[i, 'signal'] = 1
                df.loc[i, 'positions'] = 1  # ä¹°å…¥ä¿¡å·
                in_position = True
                entry_price = df.loc[i, 'close']
                stop_loss = entry_price - 2 * df.loc[i, 'atr']  # 2å€ATRæ­¢æŸ

        # å½“å‰æŒä»“
        else:
            # å‡ºåœºæ¡ä»¶1ï¼šè·Œç ´ä¸‹è½¨
            if df.loc[i, 'close'] < df.loc[i-1, 'lower_band']:
                df.loc[i, 'signal'] = 0
                df.loc[i, 'positions'] = -1  # å–å‡ºä¿¡å·
                in_position = False

            # å‡ºåœºæ¡ä»¶2ï¼šè§¦å‘æ­¢æŸ
            elif df.loc[i, 'close'] < stop_loss:
                df.loc[i, 'signal'] = 0
                df.loc[i, 'positions'] = -1  # æ­¢æŸå–å‡º
                in_position = False

            # ç»§ç»­æŒä»“
            else:
                df.loc[i, 'signal'] = 1

    return df


# ==================== 3. å›æµ‹ä¸è¯„ä¼° ====================

def backtest_turtle(data, initial_capital=100000, commission=0.0003):
    """
    æµ·é¾Ÿç­–ç•¥å›æµ‹
    """
    df = data.copy()

    # è®¡ç®—æ”¶ç›Š
    df['daily_return'] = df['close'].pct_change()
    df['strategy_return'] = df['signal'].shift(1) * df['daily_return']

    # æ‰£é™¤äº¤æ˜“æˆæœ¬
    df['trade_cost'] = 0.0
    df.loc[df['positions'] != 0, 'trade_cost'] = commission
    df['strategy_return'] = df['strategy_return'] - df['trade_cost']

    # ç´¯è®¡æ”¶ç›Š
    df['cumulative_return'] = (1 + df['daily_return']).cumprod()
    df['strategy_cumulative_return'] = (1 + df['strategy_return']).cumprod()
    df['portfolio_value'] = initial_capital * df['strategy_cumulative_return']

    return df


def evaluate_turtle_performance(data):
    """
    è¯„ä¼°æµ·é¾Ÿç­–ç•¥è¡¨ç°
    """
    df = data.dropna()

    # æ€»æ”¶ç›Š
    total_return = df['strategy_cumulative_return'].iloc[-1] - 1
    benchmark_return = df['cumulative_return'].iloc[-1] - 1

    # å¹´åŒ–æ”¶ç›Š
    days = (df['date'].iloc[-1] - df['date'].iloc[0]).days
    annual_return = (1 + total_return) ** (365 / days) - 1

    # æœ€å¤§å›æ’¤
    cummax = df['strategy_cumulative_return'].cummax()
    drawdown = (df['strategy_cumulative_return'] - cummax) / cummax
    max_drawdown = drawdown.min()

    # å¤æ™®æ¯”ç‡
    risk_free_rate = 0.03
    excess_return = df['strategy_return'].mean() * 252 - risk_free_rate
    volatility = df['strategy_return'].std() * np.sqrt(252)
    sharpe_ratio = excess_return / volatility if volatility != 0 else 0

    # äº¤æ˜“æ¬¡æ•°å’Œèƒœç‡
    trades = df[df['positions'] != 0]
    buy_trades = trades[trades['positions'] == 1]
    sell_trades = trades[trades['positions'] == -1]
    num_trades = len(sell_trades)

    # è®¡ç®—æ¯ç¬”äº¤æ˜“ç›ˆäº
    winning_trades = 0
    if num_trades > 0:
        for i in range(num_trades):
            buy_idx = buy_trades.index[i] if i < len(buy_trades) else None
            sell_idx = sell_trades.index[i]
            if buy_idx and buy_idx < sell_idx:
                trade_return = df.loc[sell_idx, 'close'] / df.loc[buy_idx, 'close'] - 1
                if trade_return > 0:
                    winning_trades += 1

    win_rate = winning_trades / num_trades if num_trades > 0 else 0

    # æ‰“å°ç»“æœ
    print("=" * 50)
    print("æµ·é¾Ÿäº¤æ˜“æ³•åˆ™ - ç­–ç•¥è¡¨ç°æ€»ç»“")
    print("=" * 50)
    print(f"å›æµ‹åŒºé—´: {df['date'].iloc[0].date()} è‡³ {df['date'].iloc[-1].date()}")
    print(f"äº¤æ˜“æ¬¡æ•°: {num_trades} æ¬¡")
    print("-" * 50)
    print(f"ç­–ç•¥æ€»æ”¶ç›Šç‡: {total_return*100:.2f}%")
    print(f"åŸºå‡†æ”¶ç›Šç‡: {benchmark_return*100:.2f}%")
    print(f"è¶…é¢æ”¶ç›Š: {(total_return - benchmark_return)*100:.2f}%")
    print("-" * 50)
    print(f"å¹´åŒ–æ”¶ç›Šç‡: {annual_return*100:.2f}%")
    print(f"æœ€å¤§å›æ’¤: {max_drawdown*100:.2f}%")
    print(f"å¤æ™®æ¯”ç‡: {sharpe_ratio:.2f}")
    print(f"èƒœç‡: {win_rate*100:.2f}%")
    print("=" * 50)

    return {
        'total_return': total_return,
        'annual_return': annual_return,
        'max_drawdown': max_drawdown,
        'sharpe_ratio': sharpe_ratio,
        'win_rate': win_rate,
        'num_trades': num_trades
    }


# ==================== 4. å¯è§†åŒ– ====================

def plot_turtle_results(data):
    """
    ç»˜åˆ¶æµ·é¾Ÿç­–ç•¥å›æµ‹ç»“æœ
    """
    df = data.dropna()

    fig, axes = plt.subplots(4, 1, figsize=(15, 16))

    # å­å›¾1ï¼šä»·æ ¼ä¸å”å¥‡å®‰é€šé“
    ax1 = axes[0]
    ax1.plot(df['date'], df['close'], label='æ”¶ç›˜ä»·', linewidth=1, alpha=0.7)
    ax1.plot(df['date'], df['upper_band'], label='20æ—¥æœ€é«˜ä»·ï¼ˆå…¥åœºï¼‰',
             linewidth=1, linestyle='--', color='red')
    ax1.plot(df['date'], df['lower_band'], label='10æ—¥æœ€ä½ä»·ï¼ˆå‡ºåœºï¼‰',
             linewidth=1, linestyle='--', color='green')

    # å¡«å……é€šé“
    ax1.fill_between(df['date'], df['upper_band'], df['lower_band'], alpha=0.1)

    # æ ‡è®°ä¹°å–ç‚¹
    buy_signals = df[df['positions'] == 1]
    sell_signals = df[df['positions'] == -1]
    ax1.scatter(buy_signals['date'], buy_signals['close'],
                marker='^', color='red', s=100, label='ä¹°å…¥', zorder=5)
    ax1.scatter(sell_signals['date'], sell_signals['close'],
                marker='v', color='green', s=100, label='å–å‡º', zorder=5)

    ax1.set_title('æµ·é¾Ÿäº¤æ˜“æ³•åˆ™ - å”å¥‡å®‰é€šé“ä¸äº¤æ˜“ä¿¡å·', fontsize=14, fontweight='bold')
    ax1.set_ylabel('ä»·æ ¼ï¼ˆå…ƒï¼‰')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)

    # å­å›¾2ï¼šATRæŒ‡æ ‡
    ax2 = axes[1]
    ax2.plot(df['date'], df['atr'], label='ATRï¼ˆçœŸå®æ³¢å¹…ï¼‰',
             linewidth=1, color='purple')
    ax2.set_title('ATRæ³¢åŠ¨æ€§æŒ‡æ ‡', fontsize=14, fontweight='bold')
    ax2.set_ylabel('ATR')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)

    # å­å›¾3ï¼šç´¯è®¡æ”¶ç›Šå¯¹æ¯”
    ax3 = axes[2]
    ax3.plot(df['date'], (df['cumulative_return'] - 1) * 100,
             label='ä¹°å…¥æŒæœ‰', linewidth=2)
    ax3.plot(df['date'], (df['strategy_cumulative_return'] - 1) * 100,
             label='æµ·é¾Ÿç­–ç•¥', linewidth=2)
    ax3.set_title('ç´¯è®¡æ”¶ç›Šç‡å¯¹æ¯”', fontsize=14, fontweight='bold')
    ax3.set_ylabel('æ”¶ç›Šç‡ï¼ˆ%ï¼‰')
    ax3.legend(loc='upper left')
    ax3.grid(True, alpha=0.3)
    ax3.axhline(y=0, color='black', linestyle='--', linewidth=0.5)

    # å­å›¾4ï¼šå›æ’¤æ›²çº¿
    ax4 = axes[3]
    cummax = df['strategy_cumulative_return'].cummax()
    drawdown = (df['strategy_cumulative_return'] - cummax) / cummax * 100
    ax4.fill_between(df['date'], drawdown, 0, color='red', alpha=0.3)
    ax4.plot(df['date'], drawdown, color='red', linewidth=1)
    ax4.set_title('ç­–ç•¥å›æ’¤æ›²çº¿', fontsize=14, fontweight='bold')
    ax4.set_xlabel('æ—¥æœŸ')
    ax4.set_ylabel('å›æ’¤ï¼ˆ%ï¼‰')
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


# ==================== 5. ä¸»ç¨‹åº ====================

def run_turtle_strategy(symbol='000001.SZ', start='20200101', end='20240101'):
    """
    è¿è¡Œæµ·é¾Ÿäº¤æ˜“ç­–ç•¥
    """
    print(f"\nå¼€å§‹å›æµ‹æµ·é¾Ÿç­–ç•¥ï¼š{symbol}")
    print(f"å›æµ‹åŒºé—´ï¼š{start} - {end}\n")

    # 1. è·å–æ•°æ®ï¼ˆä½¿ç”¨15.2ä¸­çš„å‡½æ•°ï¼‰
    from section_15_2 import get_stock_data
    data = get_stock_data(symbol, start, end)

    # 2. ç”Ÿæˆä¿¡å·
    print("æ­£åœ¨ç”Ÿæˆæµ·é¾Ÿäº¤æ˜“ä¿¡å·...")
    data_with_signals = generate_turtle_signals(data,
                                                 entry_period=20,
                                                 exit_period=10,
                                                 atr_period=20)
    print("ä¿¡å·ç”Ÿæˆå®Œæˆ\n")

    # 3. å›æµ‹
    print("æ­£åœ¨æ‰§è¡Œå›æµ‹...")
    results = backtest_turtle(data_with_signals)
    print("å›æµ‹å®Œæˆ\n")

    # 4. è¯„ä¼°
    performance = evaluate_turtle_performance(results)

    # 5. å¯è§†åŒ–
    print("\næ­£åœ¨ç”Ÿæˆå›¾è¡¨...")
    plot_turtle_results(results)

    return results, performance


if __name__ == '__main__':
    results, performance = run_turtle_strategy(
        symbol='000001.SZ',
        start='20200101',
        end='20240101'
    )
```

---

### æµ·é¾Ÿç­–ç•¥çš„ä¼˜åŒ–æ–¹å‘

**1. é‡‘å­—å¡”åŠ ä»“**
```python
# æµ·é¾Ÿæ³•åˆ™çš„ç»å…¸åšæ³•ï¼šä»·æ ¼æ¯ä¸Šæ¶¨0.5ä¸ªATRï¼ŒåŠ ä»“ä¸€æ¬¡ï¼Œæœ€å¤šåŠ 4æ¬¡
def pyramid_position_sizing(current_price, entry_price, atr, max_units=4):
    units = int((current_price - entry_price) / (0.5 * atr)) + 1
    return min(units, max_units)
```

**2. èµ„é‡‘ç®¡ç†**
```python
# æ¯æ¬¡äº¤æ˜“çš„é£é™©ä¸è¶…è¿‡è´¦æˆ·çš„2%
def calculate_position_size(capital, atr, risk_percent=0.02):
    risk_amount = capital * risk_percent
    position_size = risk_amount / (2 * atr)  # 2å€ATRæ­¢æŸ
    return position_size
```

**3. å‚æ•°ä¼˜åŒ–**
```python
# æµ‹è¯•ä¸åŒçš„é€šé“å‘¨æœŸ
entry_periods = [10, 20, 30, 55]  # 55æ˜¯æµ·é¾ŸåŸç‰ˆå‚æ•°
exit_periods = [5, 10, 15, 20]
```

---

### âš ï¸ æµ·é¾Ÿç­–ç•¥çš„æ³¨æ„äº‹é¡¹

```
ä¼˜ç‚¹ï¼š
âœ… è¶‹åŠ¿è·Ÿè¸ªèƒ½åŠ›å¼ºï¼Œé€‚åˆæ•æ‰å¤§è¡Œæƒ…
âœ… æœ‰æ˜ç¡®çš„æ­¢æŸæœºåˆ¶ï¼Œé£é™©å¯æ§
âœ… å†å²éªŒè¯æœ‰æ•ˆï¼ˆçœŸå®äº¤æ˜“æˆåŠŸæ¡ˆä¾‹ï¼‰

ç¼ºç‚¹ï¼š
âŒ éœ‡è¡å¸‚ä¼šé¢‘ç¹æ­¢æŸ
âŒ å›æ’¤å¯èƒ½è¾ƒå¤§ï¼ˆè¶‹åŠ¿ç­–ç•¥é€šç—…ï¼‰
âŒ å¯¹äº¤æ˜“çºªå¾‹è¦æ±‚æé«˜

å®æˆ˜å»ºè®®ï¼š
â­ é€‚åˆä¸­é•¿çº¿äº¤æ˜“ï¼ˆæ—¥çº¿çº§åˆ«ï¼‰
â­ éœ€è¦ä¸¥æ ¼æ‰§è¡Œæ­¢æŸï¼Œä¸èƒ½å¿ƒå­˜ä¾¥å¹¸
â­ æœ€å¥½åœ¨å¤šä¸ªå“ç§ä¸Šåˆ†æ•£åº”ç”¨
```

---

## 15.4 åŠ¨é‡ç­–ç•¥å®ç°

### ç­–ç•¥åŸç†

åŠ¨é‡ç­–ç•¥åŸºäº**åŠ¨é‡æ•ˆåº”**ï¼šè¿‡å»è¡¨ç°å¥½çš„è‚¡ç¥¨ï¼ŒçŸ­æœŸå†…ç»§ç»­è¡¨ç°å¥½çš„æ¦‚ç‡è¾ƒå¤§ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š
- è®¡ç®—è¿‡å»Nå¤©çš„æ”¶ç›Šç‡
- é€‰æ‹©æ”¶ç›Šç‡æœ€é«˜çš„è‚¡ç¥¨ä¹°å…¥
- å®šæœŸè°ƒä»“ï¼ˆå¦‚æ¯å‘¨ã€æ¯æœˆï¼‰

```
åŠ¨é‡æ•ˆåº”ç¤ºæ„å›¾ï¼š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
è‚¡ç¥¨Aï¼šè¿‡å»20å¤©æ¶¨äº†15% â­ ä¹°å…¥
è‚¡ç¥¨Bï¼šè¿‡å»20å¤©æ¶¨äº†12% â­ ä¹°å…¥
è‚¡ç¥¨Cï¼šè¿‡å»20å¤©æ¶¨äº†8%
è‚¡ç¥¨Dï¼šè¿‡å»20å¤©æ¶¨äº†3%
è‚¡ç¥¨Eï¼šè¿‡å»20å¤©è·Œäº†5%
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ç­–ç•¥ï¼šä¹°å…¥åŠ¨é‡æœ€å¼ºçš„å‰2åªï¼ŒæŒæœ‰5å¤©åé‡æ–°æ’å
```

**å‚æ•°è®¾ç½®**ï¼š
- å›çœ‹æœŸï¼š20æ—¥ï¼ˆè®¡ç®—è¿‡å»20å¤©æ”¶ç›Šç‡ï¼‰
- æŒä»“æ•°é‡ï¼š5-10åªï¼ˆåˆ†æ•£é£é™©ï¼‰
- è°ƒä»“é¢‘ç‡ï¼šæ¯å‘¨æˆ–æ¯æœˆ

---

### å®Œæ•´ä»£ç å®ç°

```python
"""
åŠ¨é‡ç­–ç•¥ - å¤šè‚¡ç¥¨ç‰ˆæœ¬
ç­–ç•¥ï¼šæ¯å‘¨é€‰æ‹©åŠ¨é‡æœ€å¼ºçš„5åªè‚¡ç¥¨ï¼ŒæŒæœ‰ä¸€å‘¨åé‡æ–°é€‰è‚¡
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tushare as ts
from datetime import datetime, timedelta

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ==================== 1. è·å–è‚¡ç¥¨æ± æ•°æ® ====================

def get_stock_pool(start_date, end_date):
    """
    è·å–æ²ªæ·±300æˆåˆ†è‚¡ä½œä¸ºè‚¡ç¥¨æ± 
    """
    ts.set_token('ä½ çš„tushare_token')
    pro = ts.pro_api()

    # è·å–æ²ªæ·±300æˆåˆ†è‚¡
    hs300 = pro.index_weight(index_code='399300.SZ',
                              start_date=start_date,
                              end_date=end_date)

    stock_list = hs300['con_code'].unique().tolist()

    return stock_list[:100]  # ä¸ºäº†æ¼”ç¤ºï¼Œåªå–å‰100åª


def get_multiple_stocks_data(stock_list, start_date, end_date):
    """
    æ‰¹é‡è·å–å¤šåªè‚¡ç¥¨çš„å†å²æ•°æ®
    """
    ts.set_token('ä½ çš„tushare_token')
    pro = ts.pro_api()

    all_data = {}

    for i, symbol in enumerate(stock_list):
        try:
            df = pro.daily(ts_code=symbol,
                          start_date=start_date,
                          end_date=end_date)

            if len(df) > 0:
                df['trade_date'] = pd.to_datetime(df['trade_date'])
                df = df.sort_values('trade_date').reset_index(drop=True)
                all_data[symbol] = df

            # é¿å…é¢‘ç¹è°ƒç”¨API
            if (i + 1) % 10 == 0:
                print(f"å·²è·å– {i+1}/{len(stock_list)} åªè‚¡ç¥¨æ•°æ®")

        except Exception as e:
            print(f"è·å– {symbol} æ•°æ®å¤±è´¥: {e}")
            continue

    return all_data


# ==================== 2. è®¡ç®—åŠ¨é‡å› å­ ====================

def calculate_momentum(data, lookback_period=20):
    """
    è®¡ç®—åŠ¨é‡å› å­ï¼ˆè¿‡å»Nå¤©çš„æ”¶ç›Šç‡ï¼‰

    å‚æ•°ï¼š
        data: è‚¡ç¥¨ä»·æ ¼æ•°æ®
        lookback_period: å›çœ‹å‘¨æœŸ
    """
    df = data.copy()

    # è®¡ç®—Næ—¥æ”¶ç›Šç‡
    df['momentum'] = df['close'].pct_change(lookback_period)

    # ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–åŠ¨é‡æŒ‡æ ‡
    # df['momentum'] = df['close'] / df['close'].shift(lookback_period) - 1

    return df


def rank_stocks_by_momentum(all_data, date, lookback_period=20):
    """
    åœ¨æŒ‡å®šæ—¥æœŸï¼Œå¯¹æ‰€æœ‰è‚¡ç¥¨æŒ‰åŠ¨é‡æ’å

    è¿”å›ï¼šæ’åºåçš„è‚¡ç¥¨åˆ—è¡¨ï¼ˆåŠ¨é‡ä»é«˜åˆ°ä½ï¼‰
    """
    momentum_dict = {}

    for symbol, data in all_data.items():
        # æ‰¾åˆ°æŒ‡å®šæ—¥æœŸçš„æ•°æ®
        data['trade_date'] = pd.to_datetime(data['trade_date'])
        target_data = data[data['trade_date'] <= date]

        if len(target_data) < lookback_period + 1:
            continue

        # è®¡ç®—åŠ¨é‡
        recent_data = target_data.tail(lookback_period + 1)
        momentum = (recent_data['close'].iloc[-1] /
                   recent_data['close'].iloc[0] - 1)

        momentum_dict[symbol] = momentum

    # æŒ‰åŠ¨é‡æ’åº
    sorted_stocks = sorted(momentum_dict.items(),
                          key=lambda x: x[1],
                          reverse=True)

    return sorted_stocks


# ==================== 3. åŠ¨é‡ç­–ç•¥å›æµ‹ ====================

def backtest_momentum_strategy(all_data, start_date, end_date,
                                top_n=5, rebalance_freq='W',
                                lookback=20, initial_capital=100000):
    """
    åŠ¨é‡ç­–ç•¥å›æµ‹

    å‚æ•°ï¼š
        all_data: æ‰€æœ‰è‚¡ç¥¨çš„æ•°æ®å­—å…¸
        start_date: å›æµ‹å¼€å§‹æ—¥æœŸ
        end_date: å›æµ‹ç»“æŸæ—¥æœŸ
        top_n: æŒä»“è‚¡ç¥¨æ•°é‡
        rebalance_freq: è°ƒä»“é¢‘ç‡ï¼ˆ'W'=æ¯å‘¨ï¼Œ'M'=æ¯æœˆï¼‰
        lookback: åŠ¨é‡è®¡ç®—å›çœ‹æœŸ
        initial_capital: åˆå§‹èµ„é‡‘
    """
    # ç”Ÿæˆè°ƒä»“æ—¥æœŸ
    date_range = pd.date_range(start=start_date, end=end_date, freq='D')
    rebalance_dates = pd.date_range(start=start_date, end=end_date,
                                    freq=rebalance_freq)

    # åˆå§‹åŒ–
    portfolio_value = [initial_capital]
    dates = [date_range[0]]
    current_holdings = {}  # {è‚¡ç¥¨ä»£ç : æŒæœ‰æ•°é‡}
    cash = initial_capital

    print(f"å¼€å§‹å›æµ‹åŠ¨é‡ç­–ç•¥...")
    print(f"æŒä»“æ•°é‡: {top_n}åª")
    print(f"è°ƒä»“é¢‘ç‡: {rebalance_freq}")
    print(f"å›çœ‹å‘¨æœŸ: {lookback}å¤©\n")

    for i, current_date in enumerate(date_range[1:], 1):
        # æ˜¯å¦éœ€è¦è°ƒä»“
        if current_date in rebalance_dates:
            print(f"\n[{current_date.date()}] è°ƒä»“æ—¥")

            # 1. æ¸…ç©ºå½“å‰æŒä»“
            for symbol, shares in current_holdings.items():
                if symbol in all_data:
                    stock_data = all_data[symbol]
                    stock_data['trade_date'] = pd.to_datetime(stock_data['trade_date'])
                    price_data = stock_data[stock_data['trade_date'] == current_date]

                    if len(price_data) > 0:
                        sell_price = price_data['close'].iloc[0]
                        cash += shares * sell_price * 0.9997  # æ‰£é™¤æ‰‹ç»­è´¹

            current_holdings = {}

            # 2. é€‰æ‹©åŠ¨é‡æœ€å¼ºçš„top_nåªè‚¡ç¥¨
            ranked_stocks = rank_stocks_by_momentum(all_data, current_date, lookback)
            selected_stocks = [s[0] for s in ranked_stocks[:top_n]]

            print(f"é€‰ä¸­è‚¡ç¥¨: {selected_stocks}")

            # 3. ç­‰æƒé‡ä¹°å…¥
            if len(selected_stocks) > 0:
                allocation_per_stock = cash / len(selected_stocks)

                for symbol in selected_stocks:
                    if symbol in all_data:
                        stock_data = all_data[symbol]
                        stock_data['trade_date'] = pd.to_datetime(stock_data['trade_date'])
                        price_data = stock_data[stock_data['trade_date'] == current_date]

                        if len(price_data) > 0:
                            buy_price = price_data['close'].iloc[0]
                            shares = int(allocation_per_stock / buy_price / 100) * 100  # æ•´æ‰‹

                            if shares > 0:
                                cost = shares * buy_price * 1.0003  # åŠ ä¸Šæ‰‹ç»­è´¹
                                current_holdings[symbol] = shares
                                cash -= cost

        # è®¡ç®—å½“æ—¥ç»„åˆä»·å€¼
        holdings_value = 0
        for symbol, shares in current_holdings.items():
            if symbol in all_data:
                stock_data = all_data[symbol]
                stock_data['trade_date'] = pd.to_datetime(stock_data['trade_date'])
                price_data = stock_data[stock_data['trade_date'] == current_date]

                if len(price_data) > 0:
                    current_price = price_data['close'].iloc[0]
                    holdings_value += shares * current_price

        total_value = cash + holdings_value
        portfolio_value.append(total_value)
        dates.append(current_date)

        # è¿›åº¦æ˜¾ç¤º
        if i % 30 == 0:
            print(f"[{current_date.date()}] ç»„åˆä»·å€¼: Â¥{total_value:,.2f}")

    # ç”Ÿæˆç»“æœDataFrame
    results = pd.DataFrame({
        'date': dates,
        'portfolio_value': portfolio_value
    })

    results['returns'] = results['portfolio_value'].pct_change()
    results['cumulative_return'] = results['portfolio_value'] / initial_capital

    return results


# ==================== 4. æ€§èƒ½è¯„ä¼° ====================

def evaluate_momentum_performance(results, benchmark_data=None):
    """
    è¯„ä¼°åŠ¨é‡ç­–ç•¥è¡¨ç°
    """
    df = results.dropna()

    # ç­–ç•¥æ”¶ç›Š
    total_return = df['cumulative_return'].iloc[-1] - 1

    # å¹´åŒ–æ”¶ç›Š
    days = (df['date'].iloc[-1] - df['date'].iloc[0]).days
    annual_return = (1 + total_return) ** (365 / days) - 1

    # æœ€å¤§å›æ’¤
    cummax = df['cumulative_return'].cummax()
    drawdown = (df['cumulative_return'] - cummax) / cummax
    max_drawdown = drawdown.min()

    # å¤æ™®æ¯”ç‡
    risk_free_rate = 0.03
    excess_return = df['returns'].mean() * 252 - risk_free_rate
    volatility = df['returns'].std() * np.sqrt(252)
    sharpe_ratio = excess_return / volatility if volatility != 0 else 0

    print("\n" + "=" * 50)
    print("åŠ¨é‡ç­–ç•¥ - å›æµ‹ç»“æœ")
    print("=" * 50)
    print(f"å›æµ‹åŒºé—´: {df['date'].iloc[0].date()} è‡³ {df['date'].iloc[-1].date()}")
    print(f"åˆå§‹èµ„é‡‘: Â¥100,000")
    print(f"æœ€ç»ˆèµ„é‡‘: Â¥{df['portfolio_value'].iloc[-1]:,.2f}")
    print("-" * 50)
    print(f"æ€»æ”¶ç›Šç‡: {total_return*100:.2f}%")
    print(f"å¹´åŒ–æ”¶ç›Šç‡: {annual_return*100:.2f}%")
    print(f"æœ€å¤§å›æ’¤: {max_drawdown*100:.2f}%")
    print(f"å¤æ™®æ¯”ç‡: {sharpe_ratio:.2f}")
    print("=" * 50)

    return {
        'total_return': total_return,
        'annual_return': annual_return,
        'max_drawdown': max_drawdown,
        'sharpe_ratio': sharpe_ratio
    }


# ==================== 5. å¯è§†åŒ– ====================

def plot_momentum_results(results):
    """
    ç»˜åˆ¶åŠ¨é‡ç­–ç•¥å›æµ‹ç»“æœ
    """
    df = results.dropna()

    fig, axes = plt.subplots(2, 1, figsize=(15, 10))

    # å­å›¾1ï¼šèµ„é‡‘æ›²çº¿
    ax1 = axes[0]
    ax1.plot(df['date'], df['portfolio_value'],
             linewidth=2, label='åŠ¨é‡ç­–ç•¥ç»„åˆä»·å€¼')
    ax1.axhline(y=100000, color='red', linestyle='--',
                linewidth=1, alpha=0.5, label='åˆå§‹èµ„é‡‘')
    ax1.set_title('åŠ¨é‡ç­–ç•¥ - èµ„é‡‘æ›²çº¿', fontsize=14, fontweight='bold')
    ax1.set_ylabel('ç»„åˆä»·å€¼ï¼ˆå…ƒï¼‰')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'Â¥{x/10000:.1f}ä¸‡'))

    # å­å›¾2ï¼šå›æ’¤
    ax2 = axes[1]
    cummax = df['cumulative_return'].cummax()
    drawdown = (df['cumulative_return'] - cummax) / cummax * 100
    ax2.fill_between(df['date'], drawdown, 0, color='red', alpha=0.3)
    ax2.plot(df['date'], drawdown, color='red', linewidth=1)
    ax2.set_title('ç­–ç•¥å›æ’¤æ›²çº¿', fontsize=14, fontweight='bold')
    ax2.set_xlabel('æ—¥æœŸ')
    ax2.set_ylabel('å›æ’¤ï¼ˆ%ï¼‰')
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


# ==================== 6. ä¸»ç¨‹åº ====================

def run_momentum_strategy():
    """
    è¿è¡ŒåŠ¨é‡ç­–ç•¥
    """
    # è®¾ç½®å‚æ•°
    start_date = '20200101'
    end_date = '20240101'

    # 1. è·å–è‚¡ç¥¨æ± 
    print("æ­£åœ¨è·å–è‚¡ç¥¨æ± ...")
    stock_pool = get_stock_pool(start_date, end_date)
    print(f"è‚¡ç¥¨æ± åŒ…å« {len(stock_pool)} åªè‚¡ç¥¨\n")

    # 2. è·å–æ•°æ®
    print("æ­£åœ¨æ‰¹é‡è·å–è‚¡ç¥¨æ•°æ®...")
    all_data = get_multiple_stocks_data(stock_pool, start_date, end_date)
    print(f"æˆåŠŸè·å– {len(all_data)} åªè‚¡ç¥¨æ•°æ®\n")

    # 3. å›æµ‹
    results = backtest_momentum_strategy(
        all_data=all_data,
        start_date=start_date,
        end_date=end_date,
        top_n=5,           # æŒä»“5åªè‚¡ç¥¨
        rebalance_freq='W', # æ¯å‘¨è°ƒä»“
        lookback=20        # 20æ—¥åŠ¨é‡
    )

    # 4. è¯„ä¼°
    performance = evaluate_momentum_performance(results)

    # 5. å¯è§†åŒ–
    plot_momentum_results(results)

    return results, performance


if __name__ == '__main__':
    results, performance = run_momentum_strategy()
```

---

### åŠ¨é‡ç­–ç•¥çš„å˜ç§

**1. åè½¬ç­–ç•¥**
```python
# ä¸åŠ¨é‡ç­–ç•¥ç›¸åï¼šä¹°å…¥è·Œå¹…æœ€å¤§çš„è‚¡ç¥¨ï¼ˆè¶…è·Œåå¼¹ï¼‰
sorted_stocks = sorted(momentum_dict.items(),
                      key=lambda x: x[1],
                      reverse=False)  # æ”¹ä¸ºFalse
```

**2. åŠ¨é‡+ä»·å€¼æ··åˆ**
```python
# åŒæ—¶è€ƒè™‘åŠ¨é‡å’Œä¼°å€¼
score = 0.6 * momentum + 0.4 * (1 / pe_ratio)
```

**3. è¡Œä¸šä¸­æ€§åŠ¨é‡**
```python
# æ¯ä¸ªè¡Œä¸šé€‰åŠ¨é‡æœ€å¼ºçš„1åªï¼Œé¿å…è¡Œä¸šé›†ä¸­
for industry in industries:
    top_stock_in_industry = select_top_momentum(industry)
    portfolio.add(top_stock_in_industry)
```

---

### âš ï¸ åŠ¨é‡ç­–ç•¥çš„æ³¨æ„äº‹é¡¹

```
ä¼˜ç‚¹ï¼š
âœ… ç®€å•ç›´è§‚ï¼Œå®¹æ˜“å®ç°
âœ… å­¦æœ¯ç ”ç©¶éªŒè¯æœ‰æ•ˆï¼ˆFama-Frenchä¸‰å› å­æ¨¡å‹ï¼‰
âœ… é€‚åˆé‡åŒ–å¤šè‚¡è½®åŠ¨

ç¼ºç‚¹ï¼š
âŒ éœ€è¦äº¤æ˜“å¤šåªè‚¡ç¥¨ï¼ˆèµ„é‡‘é—¨æ§›è¾ƒé«˜ï¼‰
âŒ æ¢æ‰‹ç‡é«˜ï¼Œæ‰‹ç»­è´¹æˆæœ¬å¤§
âŒ å®¹æ˜“åœ¨å¸‚åœºåè½¬æ—¶äºæŸ

å®æˆ˜å»ºè®®ï¼š
â­ å»ºè®®è‡³å°‘10ä¸‡èµ„é‡‘èµ·æ­¥
â­ é™ä½è°ƒä»“é¢‘ç‡ï¼ˆæœˆåº¦ä¼˜äºå‘¨åº¦ï¼‰
â­ ç»“åˆå…¶ä»–å› å­ï¼ˆå¦‚ä¼°å€¼ã€è´¨é‡ï¼‰è¿‡æ»¤
â­ é¿å…åœ¨å¸‚åœºæç«¯æƒ…ç»ªæ—¶ä½¿ç”¨
```

---

## 15.5 ç­–ç•¥æµ‹è¯•ä¸è¯„ä¼°

### æ ¸å¿ƒè¯„ä¼°æŒ‡æ ‡

**æ”¶ç›Šç±»æŒ‡æ ‡**ï¼š

1. **æ€»æ”¶ç›Šç‡**
   ```python
   total_return = (final_value - initial_value) / initial_value
   ```

2. **å¹´åŒ–æ”¶ç›Šç‡**
   ```python
   annual_return = (1 + total_return) ** (365 / days) - 1
   ```

3. **è¶…é¢æ”¶ç›Š**
   ```python
   excess_return = strategy_return - benchmark_return
   ```

**é£é™©ç±»æŒ‡æ ‡**ï¼š

1. **æœ€å¤§å›æ’¤ï¼ˆMaxDrawdownï¼‰**
   ```python
   def calculate_max_drawdown(cumulative_returns):
       """
       æœ€å¤§å›æ’¤ï¼šä»æœ€é«˜ç‚¹åˆ°æœ€ä½ç‚¹çš„æœ€å¤§è·Œå¹…
       """
       cummax = cumulative_returns.cummax()
       drawdown = (cumulative_returns - cummax) / cummax
       max_drawdown = drawdown.min()
       return max_drawdown
   ```

2. **æ³¢åŠ¨ç‡ï¼ˆVolatilityï¼‰**
   ```python
   volatility = returns.std() * np.sqrt(252)  # å¹´åŒ–æ³¢åŠ¨ç‡
   ```

3. **å¤æ™®æ¯”ç‡ï¼ˆSharpe Ratioï¼‰**
   ```python
   def calculate_sharpe_ratio(returns, risk_free_rate=0.03):
       """
       å¤æ™®æ¯”ç‡ï¼šå•ä½é£é™©çš„è¶…é¢æ”¶ç›Š

       >2.0 = ä¼˜ç§€
       1.0-2.0 = è‰¯å¥½
       <1.0 = ä¸€èˆ¬
       """
       excess_return = returns.mean() * 252 - risk_free_rate
       volatility = returns.std() * np.sqrt(252)
       sharpe = excess_return / volatility if volatility != 0 else 0
       return sharpe
   ```

4. **ç´¢æè¯ºæ¯”ç‡ï¼ˆSortino Ratioï¼‰**
   ```python
   def calculate_sortino_ratio(returns, risk_free_rate=0.03):
       """
       ç´¢æè¯ºæ¯”ç‡ï¼šåªè€ƒè™‘ä¸‹è¡Œé£é™©çš„å¤æ™®æ¯”ç‡
       """
       excess_return = returns.mean() * 252 - risk_free_rate
       downside_returns = returns[returns < 0]
       downside_volatility = downside_returns.std() * np.sqrt(252)
       sortino = excess_return / downside_volatility if downside_volatility != 0 else 0
       return sortino
   ```

**äº¤æ˜“ç±»æŒ‡æ ‡**ï¼š

1. **èƒœç‡**
   ```python
   win_rate = len(returns[returns > 0]) / len(returns[returns != 0])
   ```

2. **ç›ˆäºæ¯”**
   ```python
   avg_win = returns[returns > 0].mean()
   avg_loss = abs(returns[returns < 0].mean())
   profit_loss_ratio = avg_win / avg_loss
   ```

3. **å¡ç›æ¯”ç‡ï¼ˆCalmar Ratioï¼‰**
   ```python
   calmar_ratio = annual_return / abs(max_drawdown)
   # >3.0 = ä¼˜ç§€
   ```

---

### å®Œæ•´çš„ç­–ç•¥è¯„ä¼°å·¥å…·ç±»

```python
"""
ç­–ç•¥è¯„ä¼°å·¥å…·ç±»
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class StrategyEvaluator:
    """
    ç­–ç•¥æ€§èƒ½è¯„ä¼°å·¥å…·
    """

    def __init__(self, returns, benchmark_returns=None):
        """
        å‚æ•°ï¼š
            returns: ç­–ç•¥æ—¥æ”¶ç›Šç‡åºåˆ—ï¼ˆSeriesæˆ–arrayï¼‰
            benchmark_returns: åŸºå‡†æ”¶ç›Šç‡åºåˆ—ï¼ˆå¯é€‰ï¼‰
        """
        self.returns = pd.Series(returns).dropna()
        self.benchmark_returns = pd.Series(benchmark_returns).dropna() if benchmark_returns is not None else None

    def calculate_all_metrics(self, risk_free_rate=0.03):
        """
        è®¡ç®—æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡
        """
        metrics = {}

        # 1. æ”¶ç›ŠæŒ‡æ ‡
        cumulative_return = (1 + self.returns).cumprod()
        metrics['æ€»æ”¶ç›Šç‡'] = cumulative_return.iloc[-1] - 1

        days = len(self.returns)
        metrics['å¹´åŒ–æ”¶ç›Šç‡'] = (1 + metrics['æ€»æ”¶ç›Šç‡']) ** (252 / days) - 1

        # 2. é£é™©æŒ‡æ ‡
        metrics['æ³¢åŠ¨ç‡'] = self.returns.std() * np.sqrt(252)
        metrics['æœ€å¤§å›æ’¤'] = self._calculate_max_drawdown(cumulative_return)

        # 3. é£é™©è°ƒæ•´æ”¶ç›Š
        metrics['å¤æ™®æ¯”ç‡'] = self._calculate_sharpe(risk_free_rate)
        metrics['ç´¢æè¯ºæ¯”ç‡'] = self._calculate_sortino(risk_free_rate)
        metrics['å¡ç›æ¯”ç‡'] = metrics['å¹´åŒ–æ”¶ç›Šç‡'] / abs(metrics['æœ€å¤§å›æ’¤']) if metrics['æœ€å¤§å›æ’¤'] != 0 else 0

        # 4. äº¤æ˜“æŒ‡æ ‡
        metrics['èƒœç‡'] = len(self.returns[self.returns > 0]) / len(self.returns[self.returns != 0])

        avg_win = self.returns[self.returns > 0].mean()
        avg_loss = abs(self.returns[self.returns < 0].mean())
        metrics['ç›ˆäºæ¯”'] = avg_win / avg_loss if avg_loss != 0 else 0

        # 5. åŸºå‡†å¯¹æ¯”ï¼ˆå¦‚æœæœ‰ï¼‰
        if self.benchmark_returns is not None:
            benchmark_cumulative = (1 + self.benchmark_returns).cumprod()
            benchmark_total_return = benchmark_cumulative.iloc[-1] - 1
            metrics['åŸºå‡†æ€»æ”¶ç›Š'] = benchmark_total_return
            metrics['è¶…é¢æ”¶ç›Š'] = metrics['æ€»æ”¶ç›Šç‡'] - benchmark_total_return

            # Betaå’ŒAlpha
            covariance = np.cov(self.returns, self.benchmark_returns)[0][1]
            benchmark_variance = np.var(self.benchmark_returns)
            metrics['Beta'] = covariance / benchmark_variance if benchmark_variance != 0 else 0

            benchmark_annual_return = (1 + benchmark_total_return) ** (252 / days) - 1
            metrics['Alpha'] = metrics['å¹´åŒ–æ”¶ç›Šç‡'] - (risk_free_rate + metrics['Beta'] * (benchmark_annual_return - risk_free_rate))

        return metrics

    def _calculate_max_drawdown(self, cumulative_returns):
        """è®¡ç®—æœ€å¤§å›æ’¤"""
        cummax = cumulative_returns.cummax()
        drawdown = (cumulative_returns - cummax) / cummax
        return drawdown.min()

    def _calculate_sharpe(self, risk_free_rate):
        """è®¡ç®—å¤æ™®æ¯”ç‡"""
        excess_return = self.returns.mean() * 252 - risk_free_rate
        volatility = self.returns.std() * np.sqrt(252)
        return excess_return / volatility if volatility != 0 else 0

    def _calculate_sortino(self, risk_free_rate):
        """è®¡ç®—ç´¢æè¯ºæ¯”ç‡"""
        excess_return = self.returns.mean() * 252 - risk_free_rate
        downside_returns = self.returns[self.returns < 0]
        downside_volatility = downside_returns.std() * np.sqrt(252)
        return excess_return / downside_volatility if downside_volatility != 0 else 0

    def print_report(self):
        """
        æ‰“å°å®Œæ•´çš„ç­–ç•¥è¯„ä¼°æŠ¥å‘Š
        """
        metrics = self.calculate_all_metrics()

        print("\n" + "=" * 60)
        print("ç­–ç•¥è¯„ä¼°æŠ¥å‘Š")
        print("=" * 60)

        print("\nã€æ”¶ç›ŠæŒ‡æ ‡ã€‘")
        print(f"  æ€»æ”¶ç›Šç‡:      {metrics['æ€»æ”¶ç›Šç‡']*100:>8.2f}%")
        print(f"  å¹´åŒ–æ”¶ç›Šç‡:    {metrics['å¹´åŒ–æ”¶ç›Šç‡']*100:>8.2f}%")

        if 'åŸºå‡†æ€»æ”¶ç›Š' in metrics:
            print(f"  åŸºå‡†æ€»æ”¶ç›Š:    {metrics['åŸºå‡†æ€»æ”¶ç›Š']*100:>8.2f}%")
            print(f"  è¶…é¢æ”¶ç›Š:      {metrics['è¶…é¢æ”¶ç›Š']*100:>8.2f}%")

        print("\nã€é£é™©æŒ‡æ ‡ã€‘")
        print(f"  æ³¢åŠ¨ç‡:        {metrics['æ³¢åŠ¨ç‡']*100:>8.2f}%")
        print(f"  æœ€å¤§å›æ’¤:      {metrics['æœ€å¤§å›æ’¤']*100:>8.2f}%")

        print("\nã€é£é™©è°ƒæ•´æ”¶ç›Šã€‘")
        print(f"  å¤æ™®æ¯”ç‡:      {metrics['å¤æ™®æ¯”ç‡']:>8.2f}")
        print(f"  ç´¢æè¯ºæ¯”ç‡:    {metrics['ç´¢æè¯ºæ¯”ç‡']:>8.2f}")
        print(f"  å¡ç›æ¯”ç‡:      {metrics['å¡ç›æ¯”ç‡']:>8.2f}")

        print("\nã€äº¤æ˜“æŒ‡æ ‡ã€‘")
        print(f"  èƒœç‡:          {metrics['èƒœç‡']*100:>8.2f}%")
        print(f"  ç›ˆäºæ¯”:        {metrics['ç›ˆäºæ¯”']:>8.2f}")

        if 'Beta' in metrics:
            print("\nã€å¸‚åœºæ•å£ã€‘")
            print(f"  Beta:          {metrics['Beta']:>8.2f}")
            print(f"  Alpha:         {metrics['Alpha']*100:>8.2f}%")

        print("\n" + "=" * 60)

        # è¯„çº§
        self._print_rating(metrics)

    def _print_rating(self, metrics):
        """
        ç»™ç­–ç•¥æ‰“åˆ†
        """
        score = 0
        comments = []

        # å¹´åŒ–æ”¶ç›Šè¯„åˆ†ï¼ˆæ»¡åˆ†30åˆ†ï¼‰
        if metrics['å¹´åŒ–æ”¶ç›Šç‡'] > 0.3:
            score += 30
            comments.append("âœ… å¹´åŒ–æ”¶ç›Šç‡ä¼˜ç§€ï¼ˆ>30%ï¼‰")
        elif metrics['å¹´åŒ–æ”¶ç›Šç‡'] > 0.15:
            score += 20
            comments.append("âœ… å¹´åŒ–æ”¶ç›Šç‡è‰¯å¥½ï¼ˆ15%-30%ï¼‰")
        elif metrics['å¹´åŒ–æ”¶ç›Šç‡'] > 0:
            score += 10
            comments.append("âš ï¸ å¹´åŒ–æ”¶ç›Šç‡ä¸€èˆ¬ï¼ˆ0%-15%ï¼‰")
        else:
            comments.append("âŒ å¹´åŒ–æ”¶ç›Šç‡ä¸ºè´Ÿ")

        # å¤æ™®æ¯”ç‡è¯„åˆ†ï¼ˆæ»¡åˆ†30åˆ†ï¼‰
        if metrics['å¤æ™®æ¯”ç‡'] > 2.0:
            score += 30
            comments.append("âœ… å¤æ™®æ¯”ç‡ä¼˜ç§€ï¼ˆ>2.0ï¼‰")
        elif metrics['å¤æ™®æ¯”ç‡'] > 1.0:
            score += 20
            comments.append("âœ… å¤æ™®æ¯”ç‡è‰¯å¥½ï¼ˆ1.0-2.0ï¼‰")
        elif metrics['å¤æ™®æ¯”ç‡'] > 0:
            score += 10
            comments.append("âš ï¸ å¤æ™®æ¯”ç‡ä¸€èˆ¬ï¼ˆ0-1.0ï¼‰")
        else:
            comments.append("âŒ å¤æ™®æ¯”ç‡ä¸ºè´Ÿ")

        # æœ€å¤§å›æ’¤è¯„åˆ†ï¼ˆæ»¡åˆ†20åˆ†ï¼‰
        if abs(metrics['æœ€å¤§å›æ’¤']) < 0.1:
            score += 20
            comments.append("âœ… æœ€å¤§å›æ’¤ä¼˜ç§€ï¼ˆ<10%ï¼‰")
        elif abs(metrics['æœ€å¤§å›æ’¤']) < 0.2:
            score += 15
            comments.append("âœ… æœ€å¤§å›æ’¤è‰¯å¥½ï¼ˆ10%-20%ï¼‰")
        elif abs(metrics['æœ€å¤§å›æ’¤']) < 0.3:
            score += 10
            comments.append("âš ï¸ æœ€å¤§å›æ’¤è¾ƒå¤§ï¼ˆ20%-30%ï¼‰")
        else:
            score += 5
            comments.append("âŒ æœ€å¤§å›æ’¤è¿‡å¤§ï¼ˆ>30%ï¼‰")

        # èƒœç‡è¯„åˆ†ï¼ˆæ»¡åˆ†20åˆ†ï¼‰
        if metrics['èƒœç‡'] > 0.6:
            score += 20
            comments.append("âœ… èƒœç‡ä¼˜ç§€ï¼ˆ>60%ï¼‰")
        elif metrics['èƒœç‡'] > 0.5:
            score += 15
            comments.append("âœ… èƒœç‡è‰¯å¥½ï¼ˆ50%-60%ï¼‰")
        elif metrics['èƒœç‡'] > 0.4:
            score += 10
            comments.append("âš ï¸ èƒœç‡ä¸€èˆ¬ï¼ˆ40%-50%ï¼‰")
        else:
            comments.append("âŒ èƒœç‡è¾ƒä½ï¼ˆ<40%ï¼‰")

        print("\nã€ç­–ç•¥è¯„çº§ã€‘")
        print(f"  ç»¼åˆå¾—åˆ†: {score}/100")

        if score >= 80:
            rating = "Aï¼ˆä¼˜ç§€ï¼‰"
        elif score >= 60:
            rating = "Bï¼ˆè‰¯å¥½ï¼‰"
        elif score >= 40:
            rating = "Cï¼ˆåŠæ ¼ï¼‰"
        else:
            rating = "Dï¼ˆéœ€æ”¹è¿›ï¼‰"

        print(f"  è¯„çº§: {rating}")
        print("\nã€è¯¦ç»†è¯„ä»·ã€‘")
        for comment in comments:
            print(f"  {comment}")

    def plot_analysis(self):
        """
        ç»˜åˆ¶ç­–ç•¥åˆ†æå›¾è¡¨
        """
        cumulative_return = (1 + self.returns).cumprod()

        fig, axes = plt.subplots(2, 2, figsize=(15, 10))

        # å­å›¾1ï¼šç´¯è®¡æ”¶ç›Šæ›²çº¿
        ax1 = axes[0, 0]
        ax1.plot(cumulative_return.index, (cumulative_return - 1) * 100,
                 linewidth=2, label='ç­–ç•¥')
        if self.benchmark_returns is not None:
            benchmark_cumulative = (1 + self.benchmark_returns).cumprod()
            ax1.plot(benchmark_cumulative.index, (benchmark_cumulative - 1) * 100,
                     linewidth=2, label='åŸºå‡†', alpha=0.7)
        ax1.set_title('ç´¯è®¡æ”¶ç›Šç‡', fontsize=12, fontweight='bold')
        ax1.set_ylabel('æ”¶ç›Šç‡ï¼ˆ%ï¼‰')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # å­å›¾2ï¼šå›æ’¤æ›²çº¿
        ax2 = axes[0, 1]
        cummax = cumulative_return.cummax()
        drawdown = (cumulative_return - cummax) / cummax * 100
        ax2.fill_between(drawdown.index, drawdown, 0, color='red', alpha=0.3)
        ax2.plot(drawdown.index, drawdown, color='red', linewidth=1)
        ax2.set_title('å›æ’¤æ›²çº¿', fontsize=12, fontweight='bold')
        ax2.set_ylabel('å›æ’¤ï¼ˆ%ï¼‰')
        ax2.grid(True, alpha=0.3)

        # å­å›¾3ï¼šæ”¶ç›Šç‡åˆ†å¸ƒ
        ax3 = axes[1, 0]
        ax3.hist(self.returns * 100, bins=50, alpha=0.7, color='blue', edgecolor='black')
        ax3.axvline(x=0, color='red', linestyle='--', linewidth=1)
        ax3.set_title('æ—¥æ”¶ç›Šç‡åˆ†å¸ƒ', fontsize=12, fontweight='bold')
        ax3.set_xlabel('æ—¥æ”¶ç›Šç‡ï¼ˆ%ï¼‰')
        ax3.set_ylabel('é¢‘æ•°')
        ax3.grid(True, alpha=0.3)

        # å­å›¾4ï¼šæ»šåŠ¨å¤æ™®æ¯”ç‡
        ax4 = axes[1, 1]
        rolling_sharpe = self.returns.rolling(window=60).apply(
            lambda x: (x.mean() * 252 - 0.03) / (x.std() * np.sqrt(252)) if x.std() != 0 else 0
        )
        ax4.plot(rolling_sharpe.index, rolling_sharpe, linewidth=1.5)
        ax4.axhline(y=0, color='black', linestyle='--', linewidth=0.5)
        ax4.axhline(y=1, color='green', linestyle='--', linewidth=0.5, alpha=0.5)
        ax4.axhline(y=2, color='blue', linestyle='--', linewidth=0.5, alpha=0.5)
        ax4.set_title('60æ—¥æ»šåŠ¨å¤æ™®æ¯”ç‡', fontsize=12, fontweight='bold')
        ax4.set_ylabel('å¤æ™®æ¯”ç‡')
        ax4.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

if __name__ == '__main__':
    # å‡è®¾æˆ‘ä»¬æœ‰ç­–ç•¥æ”¶ç›Šç‡å’ŒåŸºå‡†æ”¶ç›Šç‡
    strategy_returns = pd.Series([...])  # ä»å›æµ‹ç»“æœä¸­è·å–
    benchmark_returns = pd.Series([...])  # åŸºå‡†æ”¶ç›Šç‡

    # åˆ›å»ºè¯„ä¼°å™¨
    evaluator = StrategyEvaluator(strategy_returns, benchmark_returns)

    # æ‰“å°æŠ¥å‘Š
    evaluator.print_report()

    # ç»˜åˆ¶åˆ†æå›¾è¡¨
    evaluator.plot_analysis()
```

---

### ç­–ç•¥å¯¹æ¯”åˆ†æ

```python
def compare_strategies(strategies_dict):
    """
    å¯¹æ¯”å¤šä¸ªç­–ç•¥çš„è¡¨ç°

    å‚æ•°ï¼š
        strategies_dict: {ç­–ç•¥åç§°: æ”¶ç›Šç‡åºåˆ—}
    """
    comparison_data = []

    for name, returns in strategies_dict.items():
        evaluator = StrategyEvaluator(returns)
        metrics = evaluator.calculate_all_metrics()
        metrics['ç­–ç•¥åç§°'] = name
        comparison_data.append(metrics)

    # è½¬æ¢ä¸ºDataFrame
    df = pd.DataFrame(comparison_data)
    df = df.set_index('ç­–ç•¥åç§°')

    # æ ¼å¼åŒ–è¾“å‡º
    print("\n" + "=" * 100)
    print("ç­–ç•¥å¯¹æ¯”åˆ†æ")
    print("=" * 100)
    print(df[['å¹´åŒ–æ”¶ç›Šç‡', 'æœ€å¤§å›æ’¤', 'å¤æ™®æ¯”ç‡', 'èƒœç‡']].to_string())
    print("=" * 100)

    # å¯è§†åŒ–å¯¹æ¯”
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))

    metrics_to_plot = ['å¹´åŒ–æ”¶ç›Šç‡', 'æœ€å¤§å›æ’¤', 'å¤æ™®æ¯”ç‡', 'èƒœç‡']

    for i, metric in enumerate(metrics_to_plot):
        ax = axes[i // 2, i % 2]
        df[metric].plot(kind='bar', ax=ax, color='skyblue', edgecolor='black')
        ax.set_title(metric, fontsize=12, fontweight='bold')
        ax.grid(True, alpha=0.3, axis='y')
        ax.set_xlabel('')

    plt.tight_layout()
    plt.show()


# ä½¿ç”¨ç¤ºä¾‹
strategies = {
    'åŒå‡çº¿ç­–ç•¥': ma_strategy_returns,
    'æµ·é¾Ÿç­–ç•¥': turtle_strategy_returns,
    'åŠ¨é‡ç­–ç•¥': momentum_strategy_returns
}

compare_strategies(strategies)
```

---

## 15.6 å¸¸è§é—®é¢˜ä¸å­¦ä¹ èµ„æº

### â“ å¸¸è§é—®é¢˜FAQ

**Q1: ä¸ºä»€ä¹ˆå›æµ‹è¡¨ç°å¾ˆå¥½ï¼Œå®ç›˜å´äºé’±ï¼Ÿ**

```
A: è¿™æ˜¯"è¿‡æ‹Ÿåˆ"å¯¼è‡´çš„ã€‚å¸¸è§åŸå› ï¼š

1. è¿‡åº¦ä¼˜åŒ–å‚æ•°
   - å›æµ‹æ—¶åå¤è°ƒå‚ï¼Œç›´åˆ°æ‰¾åˆ°"æœ€ä¼˜"å‚æ•°
   - å®é™…ä¸Šæ˜¯æ‹Ÿåˆäº†å†å²å™ªéŸ³ï¼Œæœªæ¥æ— æ•ˆ

   è§£å†³æ–¹æ³•ï¼š
   - ä½¿ç”¨æ ·æœ¬å¤–æµ‹è¯•ï¼ˆin-sample + out-of-sampleï¼‰
   - ä¿ç•™æœ€è¿‘1å¹´æ•°æ®ä½œä¸ºéªŒè¯é›†

2. å¿½ç•¥äº¤æ˜“æˆæœ¬
   - å›æµ‹æ²¡æ‰£æ‰‹ç»­è´¹ã€æ»‘ç‚¹ã€å†²å‡»æˆæœ¬
   - å®ç›˜äº¤æ˜“æˆæœ¬å¯èƒ½åƒæ‰å¤§éƒ¨åˆ†åˆ©æ¶¦

   è§£å†³æ–¹æ³•ï¼š
   - å›æµ‹æ—¶ä¿å®ˆä¼°è®¡äº¤æ˜“æˆæœ¬ï¼ˆåŒè¾¹0.1%-0.3%ï¼‰
   - å‡å°‘äº¤æ˜“é¢‘ç‡

3. æœªæ¥å‡½æ•°
   - ä½¿ç”¨äº†"æœªæ¥æ•°æ®"ï¼ˆå¦‚ç”¨æ”¶ç›˜ä»·åˆ¤æ–­ï¼Œå®é™…æ— æ³•åœ¨æ”¶ç›˜å‰çŸ¥é“ï¼‰
   - è´¢åŠ¡æ•°æ®å‘å¸ƒæœ‰å»¶è¿Ÿï¼Œå›æµ‹æ—¶å´ç”¨äº†"å½“å¤©"æ•°æ®

   è§£å†³æ–¹æ³•ï¼š
   - ä¿¡å·æ»åä¸€å¤©ï¼šyesterday_signal â†’ today_trade
   - è´¢åŠ¡æ•°æ®è‡³å°‘æ»å3ä¸ªæœˆ

4. å¸‚åœºç¯å¢ƒå˜åŒ–
   - å†å²æœ‰æ•ˆçš„è§„å¾‹ï¼Œæœªæ¥å¯èƒ½å¤±æ•ˆ
   - å¦‚2015å¹´ç‰›å¸‚æœ‰æ•ˆçš„ç­–ç•¥ï¼Œ2016å¹´ç†Šå¸‚æ— æ•ˆ

   è§£å†³æ–¹æ³•ï¼š
   - è·¨è¶Šå¤šä¸ªå¸‚åœºå‘¨æœŸå›æµ‹ï¼ˆè‡³å°‘5å¹´ï¼‰
   - æŒç»­ç›‘æ§ç­–ç•¥æœ‰æ•ˆæ€§
```

**Q2: è¿™ä¸‰ä¸ªç­–ç•¥å“ªä¸ªæœ€å¥½ï¼Ÿ**

```
A: æ²¡æœ‰ç»å¯¹"æœ€å¥½"çš„ç­–ç•¥ï¼Œè¦çœ‹å¸‚åœºç¯å¢ƒï¼š

åŒå‡çº¿ç­–ç•¥ï¼š
âœ… é€‚åˆï¼šè¶‹åŠ¿æ˜æ˜¾çš„å¸‚åœºï¼ˆç‰›å¸‚/ç†Šå¸‚ï¼‰
âŒ ä¸é€‚åˆï¼šæ¨ªç›˜éœ‡è¡å¸‚

æµ·é¾Ÿç­–ç•¥ï¼š
âœ… é€‚åˆï¼šå¤§æ³¢åŠ¨ã€æœ‰æ˜ç¡®è¶‹åŠ¿çš„å¸‚åœº
âŒ ä¸é€‚åˆï¼šä½æ³¢åŠ¨ã€çª„å¹…éœ‡è¡å¸‚

åŠ¨é‡ç­–ç•¥ï¼š
âœ… é€‚åˆï¼šæœ‰æ˜æ˜¾æ¿å—è½®åŠ¨çš„å¸‚åœº
âŒ ä¸é€‚åˆï¼šæ™®è·Œ/æ™®æ¶¨çš„å¸‚åœº

å»ºè®®ï¼š
â­ ç»„åˆä½¿ç”¨ï¼ˆå¦‚60%åŠ¨é‡ + 40%åŒå‡çº¿ï¼‰
â­ æ ¹æ®å¸‚åœºçŠ¶æ€åˆ‡æ¢ç­–ç•¥
â­ æˆ–è€…å¹²è„†è·Ÿå•æˆç†Ÿç­–ç•¥ï¼ˆè§ç¬¬4ç« ï¼‰
```

**Q3: åˆå­¦è€…åº”è¯¥ä»å“ªä¸ªç­–ç•¥å¼€å§‹ï¼Ÿ**

```
A: æ¨èé¡ºåºï¼š

ç¬¬1é˜¶æ®µï¼šåŒå‡çº¿ç­–ç•¥
- æœ€ç®€å•ï¼Œ1å°æ—¶èƒ½å®ç°
- å¿«é€Ÿå»ºç«‹ä¿¡å¿ƒ
- ç†è§£ç­–ç•¥å¼€å‘æµç¨‹

ç¬¬2é˜¶æ®µï¼šæµ·é¾Ÿç­–ç•¥
- å¼•å…¥ATRæ³¢åŠ¨ç‡æ¦‚å¿µ
- å­¦ä¹ æ­¢æŸç®¡ç†
- ç†è§£è¶‹åŠ¿è·Ÿè¸ªé€»è¾‘

ç¬¬3é˜¶æ®µï¼šåŠ¨é‡ç­–ç•¥
- å¤šè‚¡ç¥¨è½®åŠ¨
- å­¦ä¹ å› å­é€‰è‚¡
- ä¸ºåç»­å› å­ç ”ç©¶æ‰“åŸºç¡€

å¾ªåºæ¸è¿›ï¼Œä¸è¦è·³çº§ï¼
```

**Q4: 10ä¸‡å…ƒèµ„é‡‘èƒ½åšåŠ¨é‡ç­–ç•¥å—ï¼Ÿ**

```
A: å‹‰å¼ºå¯ä»¥ï¼Œä½†ä¸æ¨èï¼š

èµ„é‡‘åˆ†é…ç¤ºä¾‹ï¼ˆæŒä»“5åªï¼‰ï¼š
- æ¯åªè‚¡ç¥¨: 20,000å…ƒ
- ä¹°å…¥ä»·: 20å…ƒ/è‚¡
- å¯ä¹°æ•°é‡: 1000è‚¡ = 10æ‰‹

é—®é¢˜ï¼š
âŒ ä»“ä½å¤ªå°ï¼Œæ‰‹ç»­è´¹å æ¯”é«˜
âŒ æ— æ³•æœ‰æ•ˆåˆ†æ•£é£é™©
âŒ è°ƒä»“æ—¶å®¹æ˜“ä¹°ä¸æ»¡/å–ä¸å®Œ

å»ºè®®ï¼š
â­ 10ä¸‡ä»¥ä¸‹ï¼šåšå•è‚¡ç¥¨ç­–ç•¥ï¼ˆåŒå‡çº¿/æµ·é¾Ÿï¼‰
â­ 10-50ä¸‡ï¼šåš3-5åªè‚¡ç¥¨è½®åŠ¨
â­ 50ä¸‡ä»¥ä¸Šï¼šåš10åªä»¥ä¸Šè‚¡ç¥¨è½®åŠ¨
```

**Q5: ç­–ç•¥å¤±æ•ˆäº†æ€ä¹ˆåŠï¼Ÿ**

```
A: å»ºç«‹ç­–ç•¥ç›‘æ§æœºåˆ¶ï¼š

1. å®šæœŸæ£€æŸ¥ï¼ˆæ¯æœˆï¼‰
   - æœ€è¿‘30å¤©æ”¶ç›Š vs å†å²å¹³å‡
   - æœ€å¤§å›æ’¤æ˜¯å¦è¶…å‡ºå†å²èŒƒå›´
   - èƒœç‡æ˜¯å¦æ˜æ˜¾ä¸‹é™

2. è§¦å‘é¢„è­¦ï¼ˆæš‚åœç­–ç•¥ï¼‰
   - è¿ç»­äºæŸè¶…è¿‡å†å²æœ€å¤§è¿äº
   - å›æ’¤è¶…è¿‡å†å²æœ€å¤§å›æ’¤çš„1.5å€
   - 3ä¸ªæœˆæ”¶ç›Šä¸ºè´Ÿ

3. ç­–ç•¥æ›´æ–°
   - é‡æ–°ä¼˜åŒ–å‚æ•°ï¼ˆç”¨æœ€è¿‘2å¹´æ•°æ®ï¼‰
   - åŠ å…¥æ–°çš„è¿‡æ»¤æ¡ä»¶
   - æˆ–è€…æ›¿æ¢ä¸ºå…¶ä»–ç­–ç•¥

ç­–ç•¥æœ‰ç”Ÿå‘½å‘¨æœŸï¼Œå¤±æ•ˆæ˜¯æ­£å¸¸çš„ï¼
```

---

### ğŸ“š å­¦ä¹ èµ„æºæ¨è

**åœ¨çº¿è¯¾ç¨‹**ï¼š

1. **Coursera - é‡‘èå·¥ç¨‹ä¸é£é™©ç®¡ç†**
   - å“¥ä¼¦æ¯”äºšå¤§å­¦å‡ºå“
   - ç³»ç»Ÿå­¦ä¹ é‡åŒ–é‡‘èç†è®º

2. **Bç«™ - é‡åŒ–äº¤æ˜“å…¥é—¨ç³»åˆ—**
   - æœç´¢"Pythoné‡åŒ–äº¤æ˜“"
   - å…è´¹ï¼Œé€‚åˆå…¥é—¨

**ç»å…¸ä¹¦ç±**ï¼š

1. **ã€Šæµ·é¾Ÿäº¤æ˜“æ³•åˆ™ã€‹** - æŸ¯è’‚æ–¯Â·è´¹æ€
   - æœ¬ç« æµ·é¾Ÿç­–ç•¥çš„åŸå§‹æ–‡çŒ®
   - è®²è¿°çœŸå®çš„äº¤æ˜“æ•…äº‹
   - â­â­â­â­â­ å¼ºçƒˆæ¨è

2. **ã€Šé‡åŒ–æŠ•èµ„ï¼šä»¥Pythonä¸ºå·¥å…·ã€‹** - è”¡ç«‹è€‘
   - ä¸­æ–‡ä¹¦ï¼Œé€‚åˆå›½å†…å¸‚åœº
   - åŒ…å«å®Œæ•´ä»£ç ç¤ºä¾‹

3. **ã€Šæ‰“å¼€é‡åŒ–æŠ•èµ„çš„é»‘ç®±ã€‹** - é‡Œä»€Â·çº³å…°
   - é€šä¿—æ˜“æ‡‚ï¼Œæ— éœ€ç¼–ç¨‹åŸºç¡€
   - ç†è§£é‡åŒ–äº¤æ˜“çš„æœ¬è´¨

**å¼€æºä»£ç **ï¼š

1. **GitHubä¼˜ç§€é¡¹ç›®**
   ```
   - vnpy/vnpyï¼šå®Œæ•´çš„é‡åŒ–äº¤æ˜“æ¡†æ¶
   - quantopian/ziplineï¼šPythonå›æµ‹æ¡†æ¶
   - microsoft/qlibï¼šå¾®è½¯Qlibï¼ˆä¸‹ä¸€ç« é‡ç‚¹ï¼‰
   ```

2. **ç­–ç•¥ç¤ºä¾‹åº“**
   - https://github.com/topics/quantitative-trading
   - æœç´¢å…³é”®è¯ï¼šmoving-average, turtle-trading, momentum

**ç¤¾åŒºè®ºå›**ï¼š

1. **é›ªçƒç½‘** - é›ªçƒé‡åŒ–ä¸“åŒº
   - å›½å†…æœ€å¤§çš„é‡åŒ–ç¤¾åŒº
   - å¯ä»¥çœ‹åˆ°å…¶ä»–äººçš„ç­–ç•¥åˆ†äº«

2. **é›†æ€å½•** - é‡åŒ–æ¿å—
   - åå‘å¥—åˆ©å’Œä½é£é™©ç­–ç•¥
   - é«˜è´¨é‡è®¨è®º

3. **çŸ¥ä¹** - é‡åŒ–äº¤æ˜“è¯é¢˜
   - æœç´¢"é‡åŒ–äº¤æ˜“"ã€"Pythoné‡åŒ–"
   - é€‚åˆæ–°æ‰‹æé—®

---

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„

```
å®Œæˆæœ¬ç« åï¼Œä½ å·²ç»æŒæ¡ï¼š
âœ… ç­–ç•¥å¼€å‘çš„å®Œæ•´æµç¨‹
âœ… ä¸‰ä¸ªç»å…¸ç­–ç•¥çš„å®ç°
âœ… ç­–ç•¥è¯„ä¼°çš„æ ¸å¿ƒæŒ‡æ ‡

æ¥ä¸‹æ¥çš„å­¦ä¹ è·¯å¾„ï¼š

è·¯å¾„Aï¼šç»§ç»­æ·±å…¥æŠ€æœ¯ï¼ˆé€‚åˆè‡ªä¸»å¼€å‘ï¼‰
  â†“
ç¬¬16ç« ï¼šå­¦ä¹ è·¯å¾„è§„åˆ’
  â†“
è¿›é˜¶ç¯‡ï¼ˆç¬¬17-22ç« ï¼‰ï¼š
- å®Œæ•´çš„ç­–ç•¥å¼€å‘æµç¨‹
- å› å­æŒ–æ˜ä¸ç ”ç©¶
- å›æµ‹æ¡†æ¶æ·±åº¦åº”ç”¨ï¼ˆbacktrader, vectorbt, Qlibï¼‰
- æœºå™¨å­¦ä¹ é‡åŒ–åº”ç”¨

è·¯å¾„Bï¼šç›´æ¥å®æˆ˜ï¼ˆé€‚åˆå¿«é€Ÿä¸Šæ‰‹ï¼‰
  â†“
ç¬¬23-26ç«  å®æˆ˜ç¯‡ï¼š
- å®ç›˜éƒ¨ç½²æŒ‡å—
- å®æˆ˜è¿è¥ç®¡ç†
- é£é™©ç›‘æ§ä¸åº”å¯¹

è·¯å¾„Cï¼šä½¿ç”¨æˆç†Ÿå·¥å…·ï¼ˆé€‚åˆä¸æƒ³æ·±å…¥ç¼–ç¨‹ï¼‰
  â†“
å›é¡¾ç¬¬4ç« ï¼šé‡åŒ–è·Ÿå•å¹³å°
å›é¡¾ç¬¬5ç« ï¼šå…ç¼–ç¨‹é‡åŒ–å·¥å…·
```

---

### ğŸ’¬ ç»“è¯­

æ­å–œä½ å®Œæˆäº†ç¬¬åäº”ç« çš„å­¦ä¹ ï¼

ä½ å·²ç»ä»é›¶å¼€å§‹å®ç°äº†ä¸‰ä¸ªç»å…¸é‡åŒ–ç­–ç•¥ï¼Œè¿™æ˜¯ä»"å­¦ä¹ è€…"åˆ°"å®è·µè€…"çš„å…³é”®ä¸€æ­¥ã€‚

**é‡è¦æé†’**ï¼š

```
âš ï¸ é‡åŒ–äº¤æ˜“ä¸æ˜¯"åœ£æ¯"
   - æ²¡æœ‰æ°¸è¿œèµšé’±çš„ç­–ç•¥
   - å›æµ‹è¡¨ç°â‰ å®ç›˜è¡¨ç°
   - é£é™©ç®¡ç†æ°¸è¿œç¬¬ä¸€ä½

âœ… ä½†é‡åŒ–äº¤æ˜“æ˜¯ç³»ç»Ÿæ€§æ–¹æ³•
   - æœ‰çºªå¾‹ï¼Œä¸å—æƒ…ç»ªå½±å“
   - å¯å›æµ‹ï¼ŒçŸ¥é“å†å²è¡¨ç°
   - å¯ä¼˜åŒ–ï¼ŒæŒç»­æ”¹è¿›

ğŸ¯ åˆå­¦è€…å»ºè®®ï¼š
   - å…ˆç”¨å°èµ„é‡‘å®ç›˜ï¼ˆ1-5ä¸‡ï¼‰
   - è¿è¡Œè‡³å°‘3ä¸ªæœˆè§‚å¯Ÿ
   - ç¡®è®¤æœ‰æ•ˆå†åŠ å¤§èµ„é‡‘
   - æˆ–è€…ç›´æ¥è·Ÿå•æˆç†Ÿç­–ç•¥
```

è®°ä½ï¼š**é‡åŒ–äº¤æ˜“æ˜¯å·¥å…·ï¼Œä¸æ˜¯é­”æ³•ã€‚** çœŸæ­£èµšé’±çš„å…³é”®åœ¨äºï¼š
1. ä¸¥æ ¼çš„é£é™©ç®¡ç†
2. æŒç»­çš„å­¦ä¹ æ”¹è¿›
3. è‰¯å¥½çš„å¿ƒæ€å’Œçºªå¾‹

ç¥ä½ åœ¨é‡åŒ–äº¤æ˜“çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼ğŸš€

---

**æœ¬ç« å®Œ**

ä¸‹ä¸€ç« ï¼šã€Šç¬¬åå…­ç« ï¼šå­¦ä¹ è·¯å¾„è§„åˆ’ã€‹
