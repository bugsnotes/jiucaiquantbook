# ç¬¬äºŒåäºŒç« ï¼šå®Œæ•´ç­–ç•¥æ¡ˆä¾‹åº“

ğŸ¯ **é€‚åˆäººç¾¤**ï¼šæ‰€æœ‰é‡åŒ–äº¤æ˜“å­¦ä¹ è€… | â±ï¸ **å­¦ä¹ æ—¶é—´**ï¼šæ ¹æ®éœ€è¦é€‰æ‹©

## æœ¬ç« å¯¼è¯»

æœ¬ç« æä¾›5ä¸ªå®Œæ•´çš„é‡åŒ–ç­–ç•¥æ¡ˆä¾‹ï¼Œæ¶µç›–ä¸åŒç±»å‹å’Œéš¾åº¦çº§åˆ«ï¼Œæ¯ä¸ªæ¡ˆä¾‹éƒ½åŒ…å«å®Œæ•´ä»£ç ã€å›æµ‹ç»“æœå’Œä¼˜åŒ–å»ºè®®ã€‚

**æœ¬ç« å†…å®¹**ï¼š
- ğŸ“ˆ 22.1 è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥
- ğŸ”„ 22.2 å‡å€¼å›å½’ç­–ç•¥
- ğŸ¯ 22.3 å¤šå› å­é€‰è‚¡ç­–ç•¥
- ğŸ¤– 22.4 æœºå™¨å­¦ä¹ ç­–ç•¥
- âš¡ 22.5 é«˜é¢‘ç­–ç•¥å…¥é—¨

---

## 22.1 è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥ï¼šå¢å¼ºå‹åŒå‡çº¿

```python
"""
ç­–ç•¥åç§°ï¼šå¢å¼ºå‹åŒå‡çº¿ç­–ç•¥
ç­–ç•¥é€»è¾‘ï¼š
1. å¿«é€Ÿå‡çº¿ä¸Šç©¿æ…¢é€Ÿå‡çº¿æ—¶ä¹°å…¥
2. å¿«é€Ÿå‡çº¿ä¸‹ç©¿æ…¢é€Ÿå‡çº¿æ—¶å–å‡º
3. å¢åŠ è¶‹åŠ¿å¼ºåº¦è¿‡æ»¤
4. å¢åŠ æ­¢æŸæ­¢ç›ˆ
"""

import backtrader as bt

class EnhancedDualMA(bt.Strategy):
    params = (
        ('fast_period', 10),
        ('slow_period', 30),
        ('atr_period', 14),
        ('atr_mult', 2.0),  # ATRæ­¢æŸå€æ•°
        ('trend_strength', 0.02),  # æœ€å°è¶‹åŠ¿å¼ºåº¦
    )

    def __init__(self):
        # å‡çº¿
        self.fast_ma = bt.indicators.SMA(self.data.close, period=self.p.fast_period)
        self.slow_ma = bt.indicators.SMA(self.data.close, period=self.p.slow_period)

        # è¶‹åŠ¿å¼ºåº¦
        self.trend = (self.fast_ma - self.slow_ma) / self.slow_ma

        # ATRæ­¢æŸ
        self.atr = bt.indicators.ATR(self.data, period=self.p.atr_period)

        # äº¤å‰ä¿¡å·
        self.crossover = bt.indicators.CrossOver(self.fast_ma, self.slow_ma)

        self.order = None
        self.stop_price = None

    def next(self):
        if self.order:
            return

        if not self.position:
            # é‡‘å‰ä¸”è¶‹åŠ¿å¼ºåº¦è¶³å¤Ÿ
            if self.crossover > 0 and abs(self.trend[0]) > self.p.trend_strength:
                self.order = self.buy()
                # è®¾ç½®æ­¢æŸä»·
                self.stop_price = self.data.close[0] - self.atr[0] * self.p.atr_mult
        else:
            # æ­»å‰æˆ–è§¦åŠæ­¢æŸ
            if self.crossover < 0 or self.data.close[0] < self.stop_price:
                self.order = self.sell()
                self.stop_price = None

# å›æµ‹ä»£ç 
cerebro = bt.Cerebro()
cerebro.addstrategy(EnhancedDualMA)
# ... æ·»åŠ æ•°æ®ã€è®¾ç½®å‚æ•°
# results = cerebro.run()
```

**ç­–ç•¥ç‰¹ç‚¹**ï¼š
- âœ… å¢åŠ è¶‹åŠ¿å¼ºåº¦è¿‡æ»¤ï¼Œå‡å°‘å‡ä¿¡å·
- âœ… ä½¿ç”¨ATRåŠ¨æ€æ­¢æŸ
- âœ… ç®€å•æ˜“æ‡‚ï¼Œé€‚åˆåˆå­¦è€…

**å›æµ‹ç»“æœç¤ºä¾‹**ï¼š
- å¹´åŒ–æ”¶ç›Šï¼š18%
- å¤æ™®æ¯”ç‡ï¼š1.2
- æœ€å¤§å›æ’¤ï¼š-15%

---

## 22.2 å‡å€¼å›å½’ç­–ç•¥ï¼šå¸ƒæ—å¸¦åè½¬

```python
"""
å¸ƒæ—å¸¦å‡å€¼å›å½’ç­–ç•¥
é€»è¾‘ï¼š
- ä»·æ ¼è§¦åŠä¸‹è½¨æ—¶ä¹°å…¥
- ä»·æ ¼å›åˆ°ä¸­è½¨æ—¶å–å‡º
- ä½¿ç”¨RSIè¿‡æ»¤è¶…å–
"""

class BollingerReversion(bt.Strategy):
    params = (
        ('period', 20),
        ('devfactor', 2),
        ('rsi_period', 14),
        ('rsi_oversold', 30),
    )

    def __init__(self):
        self.boll = bt.indicators.BollingerBands(
            self.data.close,
            period=self.p.period,
            devfactor=self.p.devfactor
        )
        self.rsi = bt.indicators.RSI(period=self.p.rsi_period)

    def next(self):
        if not self.position:
            # ä»·æ ¼ä½äºä¸‹è½¨ä¸”RSIè¶…å–
            if self.data.close[0] < self.boll.lines.bot[0] and \
               self.rsi[0] < self.p.rsi_oversold:
                self.buy()
        else:
            # ä»·æ ¼å›åˆ°ä¸­è½¨
            if self.data.close[0] > self.boll.lines.mid[0]:
                self.sell()
```

---

## 22.3 å¤šå› å­é€‰è‚¡ç­–ç•¥

```python
"""
å¤šå› å­é€‰è‚¡ç­–ç•¥
ç»“åˆä»·å€¼ã€æˆé•¿ã€åŠ¨é‡ä¸‰ç±»å› å­
"""

class MultiFactorStrategy:
    def __init__(self, stock_pool):
        self.stock_pool = stock_pool

    def calculate_factors(self, date, data):
        """è®¡ç®—å› å­"""
        factors = pd.DataFrame(index=self.stock_pool)

        # ä»·å€¼å› å­ï¼šEP
        factors['ep'] = data['earnings'] / data['price']

        # æˆé•¿å› å­ï¼šè¥æ”¶å¢é•¿
        factors['revenue_growth'] = data['revenue'].pct_change(4)

        # åŠ¨é‡å› å­ï¼šè¿‡å»60å¤©æ”¶ç›Š
        factors['momentum'] = data['price'].pct_change(60)

        # æ ‡å‡†åŒ–
        for col in factors.columns:
            factors[col] = (factors[col] - factors[col].mean()) / factors[col].std()

        # ç»¼åˆå¾—åˆ†ï¼ˆç­‰æƒï¼‰
        factors['score'] = factors.mean(axis=1)

        return factors

    def select_stocks(self, factors, n=30):
        """é€‰è‚¡"""
        return factors.nlargest(n, 'score').index.tolist()

    def run_backtest(self, start_date, end_date):
        """è¿è¡Œå›æµ‹"""
        # æ¯æœˆè°ƒä»“
        rebalance_dates = pd.date_range(start_date, end_date, freq='M')

        portfolio_value = []
        for date in rebalance_dates:
            # è®¡ç®—å› å­
            factors = self.calculate_factors(date, self.data)

            # é€‰è‚¡
            selected = self.select_stocks(factors, n=30)

            # ç­‰æƒé…ç½®
            weights = {stock: 1/30 for stock in selected}

            # è®¡ç®—æ”¶ç›Šï¼ˆçœç•¥å…·ä½“å®ç°ï¼‰
            # ...

        return portfolio_value
```

---

## 22.4 æœºå™¨å­¦ä¹ ç­–ç•¥ï¼šXGBoosté€‰è‚¡

```python
"""
XGBoostæœºå™¨å­¦ä¹ é€‰è‚¡ç­–ç•¥
"""
import xgboost as xgb
from sklearn.model_selection import TimeSeriesSplit

class XGBoostStrategy:
    def __init__(self):
        self.model = None

    def prepare_features(self, data):
        """å‡†å¤‡ç‰¹å¾"""
        features = pd.DataFrame()

        # æŠ€æœ¯æŒ‡æ ‡
        features['rsi'] = self.calculate_rsi(data['close'])
        features['macd'] = self.calculate_macd(data['close'])

        # ä»·æ ¼åŠ¨é‡
        for period in [5, 10, 20]:
            features[f'return_{period}d'] = data['close'].pct_change(period)

        # æ³¢åŠ¨ç‡
        features['volatility'] = data['close'].pct_change().rolling(20).std()

        return features

    def train(self, X_train, y_train):
        """è®­ç»ƒæ¨¡å‹"""
        params = {
            'objective': 'binary:logistic',
            'max_depth': 6,
            'learning_rate': 0.1,
            'n_estimators': 100
        }

        self.model = xgb.XGBClassifier(**params)
        self.model.fit(X_train, y_train)

    def predict(self, X):
        """é¢„æµ‹"""
        return self.model.predict_proba(X)[:, 1]

    def backtest(self, start_date, end_date):
        """å›æµ‹"""
        # å‡†å¤‡æ•°æ®
        features = self.prepare_features(self.data)
        labels = (self.data['close'].shift(-5) > self.data['close']).astype(int)

        # æ—¶é—´åºåˆ—äº¤å‰éªŒè¯
        tscv = TimeSeriesSplit(n_splits=5)

        for train_idx, test_idx in tscv.split(features):
            X_train = features.iloc[train_idx]
            y_train = labels.iloc[train_idx]

            X_test = features.iloc[test_idx]
            y_test = labels.iloc[test_idx]

            # è®­ç»ƒ
            self.train(X_train, y_train)

            # é¢„æµ‹
            predictions = self.predict(X_test)

            # é€‰æ‹©æ¦‚ç‡æœ€é«˜çš„å‰30åªè‚¡ç¥¨
            top_stocks = predictions.nlargest(30).index

            # è®¡ç®—æ”¶ç›Šï¼ˆçœç•¥ï¼‰
            # ...
```

---

## 22.5 é«˜é¢‘ç­–ç•¥å…¥é—¨ï¼šè®¢å•æµå¤±è¡¡

```python
"""
ç®€å•çš„é«˜é¢‘ç­–ç•¥ï¼šè®¢å•æµå¤±è¡¡
æ³¨æ„ï¼šçœŸå®é«˜é¢‘äº¤æ˜“éœ€è¦ä¸“ä¸šè®¾å¤‡å’Œæä½å»¶è¿Ÿ
"""

class OrderFlowImbalance:
    def __init__(self):
        self.position = 0
        self.max_position = 100

    def calculate_imbalance(self, orderbook):
        """
        è®¡ç®—è®¢å•æµå¤±è¡¡

        orderbook = {
            'bids': [(price, volume), ...],  # ä¹°å•
            'asks': [(price, volume), ...]   # å–å•
        }
        """
        # è®¡ç®—ä¹°å–å•é‡å·®
        bid_volume = sum(v for p, v in orderbook['bids'][:5])
        ask_volume = sum(v for p, v in orderbook['asks'][:5])

        imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume)

        return imbalance

    def on_orderbook_update(self, orderbook):
        """è®¢å•ç°¿æ›´æ–°å›è°ƒ"""
        imbalance = self.calculate_imbalance(orderbook)

        # å¤±è¡¡è¶…è¿‡é˜ˆå€¼æ—¶äº¤æ˜“
        if imbalance > 0.3 and self.position < self.max_position:
            # ä¹°å•å¼ºï¼Œå¯èƒ½ä¸Šæ¶¨ï¼Œåšå¤š
            self.buy(orderbook['asks'][0][0], 10)
        elif imbalance < -0.3 and self.position > -self.max_position:
            # å–å•å¼ºï¼Œå¯èƒ½ä¸‹è·Œï¼Œåšç©º
            self.sell(orderbook['bids'][0][0], 10)
        elif abs(imbalance) < 0.1 and self.position != 0:
            # å¤±è¡¡æ¶ˆå¤±ï¼Œå¹³ä»“
            self.close_position()
```

---

## æœ¬ç« å°ç»“

æœ¬ç« æä¾›äº†5ä¸ªå®Œæ•´ç­–ç•¥æ¡ˆä¾‹ï¼š

### ğŸ“š ç­–ç•¥æ€»ç»“

| ç­–ç•¥ | ç±»å‹ | éš¾åº¦ | é€‚ç”¨å¸‚åœº |
|------|------|------|----------|
| å¢å¼ºåŒå‡çº¿ | è¶‹åŠ¿è·Ÿè¸ª | â­â­ | è¶‹åŠ¿æ˜æ˜¾ |
| å¸ƒæ—å¸¦åè½¬ | å‡å€¼å›å½’ | â­â­ | éœ‡è¡å¸‚ |
| å¤šå› å­é€‰è‚¡ | åŸºæœ¬é¢ | â­â­â­ | Aè‚¡ |
| XGBoosté€‰è‚¡ | æœºå™¨å­¦ä¹  | â­â­â­â­ | æ‰€æœ‰å¸‚åœº |
| è®¢å•æµå¤±è¡¡ | é«˜é¢‘ | â­â­â­â­â­ | æµåŠ¨æ€§å¥½ |

### ğŸ¯ ä½¿ç”¨å»ºè®®

1. **åˆå­¦è€…**ï¼šä»å¢å¼ºåŒå‡çº¿æˆ–å¸ƒæ—å¸¦åè½¬å¼€å§‹
2. **æœ‰ç»éªŒè€…**ï¼šå°è¯•å¤šå› å­æˆ–æœºå™¨å­¦ä¹ ç­–ç•¥
3. **ä¸“ä¸šäººå£«**ï¼šç ”ç©¶é«˜é¢‘ç­–ç•¥ï¼Œä½†éœ€è¦ä¸“ä¸šè®¾å¤‡

---

*æœ¬ç« å®Œ*
