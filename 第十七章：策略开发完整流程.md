# ç¬¬åä¸ƒç« ï¼šç­–ç•¥å¼€å‘å®Œæ•´æµç¨‹

ğŸ¯ **é€‚åˆäººç¾¤**ï¼šæœ‰ç¼–ç¨‹èƒ½åŠ›çš„ä¸“ä¸šç”¨æˆ· | â±ï¸ **å­¦ä¹ å‘¨æœŸ**ï¼š2-3å‘¨

## æœ¬ç« å¯¼è¯»

åœ¨å‰é¢çš„æŠ€æœ¯ç¯‡ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†é‡åŒ–äº¤æ˜“çš„ç¼–ç¨‹åŸºç¡€ã€æ•°æ®å¤„ç†å’Œç®€å•ç­–ç•¥å®ç°ã€‚ä»æœ¬ç« å¼€å§‹ï¼Œæˆ‘ä»¬è¿›å…¥è¿›é˜¶ç¯‡ï¼Œå°†å­¦ä¹ å¦‚ä½•åƒä¸“ä¸šé‡åŒ–å›¢é˜Ÿä¸€æ ·å¼€å‘å’Œç®¡ç†é‡åŒ–ç­–ç•¥ã€‚

æœ¬ç« å°†å…¨é¢ä»‹ç»ç­–ç•¥å¼€å‘çš„å®Œæ•´å·¥ä½œæµç¨‹ï¼Œä»ideaäº§ç”Ÿåˆ°æœ€ç»ˆå®ç›˜éƒ¨ç½²çš„æ¯ä¸ªç¯èŠ‚ï¼Œä»¥åŠåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦éµå¾ªçš„æœ€ä½³å®è·µå’Œç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†æ–¹æ³•ã€‚é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å°†å»ºç«‹èµ·ä¸“ä¸šçš„ç­–ç•¥ç ”å‘ä½“ç³»ã€‚

**æœ¬ç« å†…å®¹**ï¼š
- ğŸ’¡ 17.1 é‡åŒ–ç ”ç©¶å·¥ä½œæµï¼ˆä»æƒ³æ³•åˆ°å®ç›˜çš„6ä¸ªæ­¥éª¤ï¼‰
- ğŸ¯ 17.2 ç­–ç•¥å¼€å‘æœ€ä½³å®è·µï¼ˆä¸“ä¸šå¼€å‘è§„èŒƒï¼‰
- ğŸ”„ 17.3 ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆç­–ç•¥çš„å…¨ç”Ÿå‘½å‘¨æœŸï¼‰

---

## 17.1 é‡åŒ–ç ”ç©¶å·¥ä½œæµ

ä¸“ä¸šçš„é‡åŒ–ç­–ç•¥å¼€å‘ä¸æ˜¯éšæ„ç¼–å†™ä»£ç ï¼Œè€Œæ˜¯éµå¾ªä¸€å¥—ä¸¥è°¨çš„ç ”ç©¶å·¥ä½œæµã€‚è¿™ä¸ªå·¥ä½œæµç¡®ä¿äº†ç­–ç•¥çš„ç§‘å­¦æ€§ã€å¯é æ€§å’Œå¯å¤ç°æ€§ã€‚

### â— 17.1.1 å®Œæ•´å·¥ä½œæµæ¦‚è§ˆ

ä¸€ä¸ªå®Œæ•´çš„é‡åŒ–ç ”ç©¶å·¥ä½œæµé€šå¸¸åŒ…æ‹¬ä»¥ä¸‹6ä¸ªé˜¶æ®µï¼š

```
Ideaäº§ç”Ÿ â†’ å‡è®¾éªŒè¯ â†’ ç­–ç•¥è®¾è®¡ â†’ ç¼–ç å®ç° â†’ å›æµ‹ä¼˜åŒ– â†’ å®ç›˜éƒ¨ç½²
   â†“          â†“          â†“          â†“          â†“          â†“
 çµæ„Ÿæ¥æº    æ•°æ®åˆ†æ    è¯¦ç»†è®¾è®¡    ä»£ç å¼€å‘    å‚æ•°è°ƒä¼˜    ä¸Šçº¿è¿è¥
   â†“          â†“          â†“          â†“          â†“          â†“
  è®°å½•       éªŒè¯å‡è®¾    æ–‡æ¡£ç¼–å†™    å•å…ƒæµ‹è¯•    æ ·æœ¬å¤–æµ‹è¯•   ç›‘æ§ç»´æŠ¤
```

**å„é˜¶æ®µè€—æ—¶å æ¯”ï¼ˆç»éªŒå€¼ï¼‰**ï¼š
- Ideaäº§ç”Ÿä¸å‡è®¾éªŒè¯ï¼š10-20%
- ç­–ç•¥è®¾è®¡ä¸ç¼–ç å®ç°ï¼š20-30%
- å›æµ‹ä¼˜åŒ–ï¼š30-40%
- å®ç›˜éƒ¨ç½²ä¸è°ƒä¼˜ï¼š20-30%

**é‡è¦åŸåˆ™**ï¼š
1. âš ï¸ ä¸è¦è·³è¿‡ä»»ä½•ç¯èŠ‚ï¼ˆç‰¹åˆ«æ˜¯å‡è®¾éªŒè¯å’Œæ ·æœ¬å¤–æµ‹è¯•ï¼‰
2. ğŸ“ æ¯ä¸ªé˜¶æ®µéƒ½è¦è¯¦ç»†è®°å½•
3. ğŸ”„ å…è®¸è¿­ä»£å›é€€ï¼ˆå‘ç°é—®é¢˜åŠæ—¶å›åˆ°å‰ä¸€é˜¶æ®µï¼‰
4. ğŸ¯ å§‹ç»ˆä¿æŒå®¢è§‚ï¼Œä¸è¦ä¸ºäº†å¥½çœ‹çš„å›æµ‹ç»“æœè€Œæ‰­æ›²ç­–ç•¥é€»è¾‘

### â— 17.1.2 Ideaäº§ç”Ÿ

**ç­–ç•¥Ideaçš„æ¥æº**ï¼š

**1. å­¦æœ¯è®ºæ–‡**
```python
# è®ºæ–‡æ¥æºæ¸ é“
PAPER_SOURCES = {
    'é¡¶çº§æœŸåˆŠ': [
        'Journal of Finance',
        'Journal of Financial Economics',
        'Review of Financial Studies',
        'Management Science'
    ],
    'é‡åŒ–ä¸“ä¸šæœŸåˆŠ': [
        'Journal of Portfolio Management',
        'Journal of Quantitative Finance',
        'Quantitative Finance'
    ],
    'ä¸­æ–‡æœŸåˆŠ': [
        'é‡‘èç ”ç©¶',
        'ç»æµç ”ç©¶',
        'ç®¡ç†ç§‘å­¦å­¦æŠ¥'
    ],
    'é¢„å°æœ¬': [
        'SSRN (ssrn.com)',
        'arXiv (arxiv.org)',
        'ResearchGate'
    ]
}

# æ¨èçš„é‡åŒ–ç­–ç•¥å…³é”®è¯
KEYWORDS = [
    'momentum', 'reversal', 'value', 'quality',
    'low volatility', 'factor investing', 'smart beta',
    'machine learning', 'deep learning', 'reinforcement learning',
    'high frequency', 'market microstructure',
    'åŠ¨é‡', 'åè½¬', 'ä»·å€¼', 'è´¨é‡', 'ä½æ³¢åŠ¨'
]
```

**2. å¸‚åœºè§‚å¯Ÿ**
- è§‚å¯Ÿå¸‚åœºå¼‚å¸¸ç°è±¡ï¼ˆå¦‚æŸäº›è‚¡ç¥¨åœ¨ç‰¹å®šæ—¶é—´æ®µè¡¨ç°å¼‚å¸¸ï¼‰
- åˆ†æè¡Œä¸šè½®åŠ¨è§„å¾‹
- ç ”ç©¶æ”¿ç­–å˜åŒ–å¯¹å¸‚åœºçš„å½±å“
- å…³æ³¨å­£èŠ‚æ€§æ•ˆåº”ï¼ˆå¦‚"æ˜¥å­£èºåŠ¨"ã€"äº”ç©·å…­ç»ä¸ƒç¿»èº«"ï¼‰

**3. æ•°æ®æŒ–æ˜**
```python
# ç¤ºä¾‹ï¼šå¯»æ‰¾ä»·æ ¼ä¸æˆäº¤é‡çš„å¼‚å¸¸å…³ç³»
import pandas as pd
import numpy as np

def find_volume_price_anomaly(stock_data):
    """
    å¯»æ‰¾æˆäº¤é‡ä¸ä»·æ ¼å˜åŠ¨çš„å¼‚å¸¸å…³ç³»
    """
    df = stock_data.copy()

    # è®¡ç®—ä»·æ ¼å˜åŠ¨ç‡å’Œæˆäº¤é‡å˜åŠ¨ç‡
    df['price_change'] = df['close'].pct_change()
    df['volume_change'] = df['volume'].pct_change()

    # å¯»æ‰¾å¼‚å¸¸ï¼šæˆäº¤é‡å¤§å¹…æ”¾å¤§ä½†ä»·æ ¼å˜åŠ¨ä¸å¤§
    df['anomaly_score'] = abs(df['volume_change']) / (abs(df['price_change']) + 0.0001)

    # æ ‡è®°å¼‚å¸¸ç‚¹ï¼ˆæˆäº¤é‡å˜åŠ¨æ˜¯ä»·æ ¼å˜åŠ¨çš„10å€ä»¥ä¸Šï¼‰
    anomalies = df[df['anomaly_score'] > 10].copy()

    # è§‚å¯Ÿå¼‚å¸¸åçš„èµ°åŠ¿
    for idx in anomalies.index:
        future_return = df.loc[idx:].head(20)['close'].pct_change().sum()
        anomalies.loc[idx, 'future_20d_return'] = future_return

    return anomalies

# è¿™ç§åˆ†æå¯èƒ½å‘ç°ï¼šå¤§æˆäº¤é‡æ— ä»·æ ¼å˜åŠ¨å¯èƒ½é¢„ç¤ºç€åç»­çš„çªç ´
```

**4. ç­–ç•¥æ”¹è¿›**
- å¯¹ç°æœ‰ç­–ç•¥è¿›è¡Œä¼˜åŒ–
- ç»„åˆå¤šä¸ªç­–ç•¥
- æ·»åŠ è¿‡æ»¤æ¡ä»¶
- æ”¹è¿›å…¥åœº/å‡ºåœºé€»è¾‘

**5. ç«èµ›ä¸ç¤¾åŒº**
- å‚åŠ Kaggleç­‰æ•°æ®ç§‘å­¦ç«èµ›
- ç ”ç©¶ä¼˜ç§€å¼€æºç­–ç•¥
- å‚ä¸é‡åŒ–ç¤¾åŒºè®¨è®ºï¼ˆèšå®½ã€ä¼˜çŸ¿ã€é›ªçƒï¼‰

**ğŸ’¡ Ideaè®°å½•æ¨¡æ¿**ï¼š

```markdown
# ç­–ç•¥Ideaè®°å½•

## åŸºæœ¬ä¿¡æ¯
- **Ideaç¼–å·**: IDEA-2024-001
- **æå‡ºæ—¥æœŸ**: 2024-01-15
- **æå‡ºäºº**: å¼ ä¸‰
- **æ¥æº**: å­¦æœ¯è®ºæ–‡ã€ŠMomentum Crashesã€‹

## æ ¸å¿ƒå‡è®¾
å°å¸‚å€¼åŠ¨é‡è‚¡ç¥¨åœ¨å¸‚åœºä¸‹è·Œæ—¶ä¼šç»å†ä¸¥é‡çš„momentum crashï¼Œ
å¦‚æœåœ¨å¸‚åœºå‹åŠ›æŒ‡æ ‡ï¼ˆå¦‚VIXï¼‰å‡é«˜æ—¶é™ä½åŠ¨é‡ç­–ç•¥çš„ä»“ä½ï¼Œ
å¯ä»¥æ˜¾è‘—é™ä½å›æ’¤ã€‚

## åˆæ­¥æƒ³æ³•
1. æ„å»ºä¼ ç»ŸåŠ¨é‡å› å­ï¼ˆè¿‡å»12ä¸ªæœˆæ”¶ç›Šç‡ï¼Œè·³è¿‡æœ€è¿‘1ä¸ªæœˆï¼‰
2. è®¡ç®—å¸‚åœºå‹åŠ›æŒ‡æ ‡ï¼ˆå¦‚æ²ªæ·±300æ³¢åŠ¨ç‡ã€åŒ—å‘èµ„é‡‘æµå‘ï¼‰
3. æ ¹æ®å¸‚åœºå‹åŠ›åŠ¨æ€è°ƒæ•´åŠ¨é‡ç­–ç•¥çš„ä»“ä½
4. é«˜å‹åŠ›æ—¶é™ä½ä»“ä½è‡³20-30%ï¼Œä½å‹åŠ›æ—¶æé«˜è‡³80-100%

## é¢„æœŸä¼˜åŠ¿
- é™ä½ç­–ç•¥æœ€å¤§å›æ’¤
- æé«˜å¤æ™®æ¯”ç‡
- å‡å°‘å°¾éƒ¨é£é™©

## æ½œåœ¨é£é™©
- å¸‚åœºå‹åŠ›æŒ‡æ ‡çš„æœ‰æ•ˆæ€§éœ€è¦éªŒè¯
- å¯èƒ½é”™è¿‡éƒ¨åˆ†åå¼¹æœºä¼š
- ä»“ä½åˆ‡æ¢å¯èƒ½å¢åŠ äº¤æ˜“æˆæœ¬

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨
1. æ”¶é›†å†å²æ•°æ®
2. æ„å»ºå¸‚åœºå‹åŠ›æŒ‡æ ‡
3. è¿›è¡Œåˆæ­¥æ•°æ®åˆ†æï¼ŒéªŒè¯å‡è®¾
```

### â— 17.1.3 å‡è®¾éªŒè¯

åœ¨æŠ•å…¥å¤§é‡æ—¶é—´ç¼–ç ä¹‹å‰ï¼Œå¿…é¡»å…ˆéªŒè¯ç­–ç•¥çš„æ ¸å¿ƒå‡è®¾æ˜¯å¦æˆç«‹ã€‚è¿™ä¸€æ­¥å¯ä»¥èŠ‚çœå¤§é‡æ—¶é—´ã€‚

**éªŒè¯æ–¹æ³•1ï¼šç®€å•ç»Ÿè®¡åˆ†æ**

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def verify_momentum_hypothesis(stock_data, lookback=120, holding=20):
    """
    éªŒè¯åŠ¨é‡å‡è®¾ï¼šè¿‡å»è¡¨ç°å¥½çš„è‚¡ç¥¨åœ¨æœªæ¥æ˜¯å¦ç»§ç»­è¡¨ç°å¥½

    å‚æ•°:
        stock_data: DataFrame, åŒ…å«å¤šåªè‚¡ç¥¨çš„æ—¥æ”¶ç›Šç‡æ•°æ®
        lookback: int, å›çœ‹æœŸï¼ˆå¤©ï¼‰
        holding: int, æŒæœ‰æœŸï¼ˆå¤©ï¼‰
    """
    results = []

    # è®¡ç®—è¿‡å»lookbackå¤©çš„æ”¶ç›Šç‡
    past_return = stock_data.rolling(lookback).apply(lambda x: (1 + x).prod() - 1)

    # è®¡ç®—æœªæ¥holdingå¤©çš„æ”¶ç›Šç‡
    future_return = stock_data.shift(-holding).rolling(holding).apply(
        lambda x: (1 + x).prod() - 1
    )

    # å°†æ‰€æœ‰æ•°æ®å±•å¹³æˆä¸€ç»´
    past_flat = past_return.values.flatten()
    future_flat = future_return.values.flatten()

    # å»é™¤NaNå€¼
    mask = ~(np.isnan(past_flat) | np.isnan(future_flat))
    past_clean = past_flat[mask]
    future_clean = future_flat[mask]

    # æŒ‰è¿‡å»æ”¶ç›Šç‡åˆ†æˆ10ç»„
    df = pd.DataFrame({
        'past_return': past_clean,
        'future_return': future_clean
    })

    df['decile'] = pd.qcut(df['past_return'], 10, labels=False, duplicates='drop')

    # è®¡ç®—æ¯ç»„çš„å¹³å‡æœªæ¥æ”¶ç›Šç‡
    group_stats = df.groupby('decile')['future_return'].agg(['mean', 'std', 'count'])

    # å¯è§†åŒ–
    plt.figure(figsize=(12, 5))

    # å­å›¾1ï¼šæ¯ç»„çš„å¹³å‡æœªæ¥æ”¶ç›Šç‡
    plt.subplot(1, 2, 1)
    plt.bar(group_stats.index, group_stats['mean'])
    plt.xlabel('Past Return Decile (0=Lowest, 9=Highest)')
    plt.ylabel('Average Future Return')
    plt.title('Momentum Effect Verification')
    plt.axhline(y=0, color='r', linestyle='--')
    plt.grid(True, alpha=0.3)

    # å­å›¾2ï¼šæ•£ç‚¹å›¾
    plt.subplot(1, 2, 2)
    plt.scatter(df['past_return'], df['future_return'], alpha=0.1, s=1)
    plt.xlabel('Past Return')
    plt.ylabel('Future Return')
    plt.title('Past vs Future Returns')
    plt.axhline(y=0, color='r', linestyle='--', alpha=0.5)
    plt.axvline(x=0, color='r', linestyle='--', alpha=0.5)
    plt.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('momentum_verification.png', dpi=300, bbox_inches='tight')
    plt.show()

    # è®¡ç®—ç›¸å…³ç³»æ•°
    correlation = df['past_return'].corr(df['future_return'])

    # è®¡ç®—å¤šç©ºç»„åˆæ”¶ç›Šï¼ˆæœ€é«˜ç»„ - æœ€ä½ç»„ï¼‰
    long_short_return = group_stats.loc[9, 'mean'] - group_stats.loc[0, 'mean']

    print(f"ç›¸å…³ç³»æ•°: {correlation:.4f}")
    print(f"å¤šç©ºç»„åˆæ”¶ç›Š: {long_short_return:.4f}")
    print(f"\nå„ç»„ç»Ÿè®¡ï¼š")
    print(group_stats)

    # åˆ¤æ–­å‡è®¾æ˜¯å¦æˆç«‹
    if long_short_return > 0 and correlation > 0:
        print("\nâœ… åŠ¨é‡å‡è®¾åˆæ­¥éªŒè¯é€šè¿‡ï¼")
        return True
    else:
        print("\nâŒ åŠ¨é‡å‡è®¾æœªé€šè¿‡éªŒè¯ï¼Œéœ€è¦é‡æ–°è€ƒè™‘ç­–ç•¥ã€‚")
        return False
```

**éªŒè¯æ–¹æ³•2ï¼šICåˆ†æï¼ˆä¿¡æ¯ç³»æ•°ï¼‰**

```python
def calculate_ic(factor_data, return_data, periods=[5, 10, 20]):
    """
    è®¡ç®—å› å­ICï¼ˆä¿¡æ¯ç³»æ•°ï¼‰

    IC = å› å­å€¼ä¸æœªæ¥æ”¶ç›Šç‡çš„ç›¸å…³ç³»æ•°
    å¥½çš„å› å­é€šå¸¸ICç»å¯¹å€¼ > 0.03ï¼Œä¸”ç¨³å®š
    """
    results = {}

    for period in periods:
        # è®¡ç®—æœªæ¥periodå¤©çš„æ”¶ç›Šç‡
        future_return = return_data.shift(-period).rolling(period).apply(
            lambda x: (1 + x).prod() - 1
        )

        # è®¡ç®—æ¯ä¸ªæ—¶é—´ç‚¹çš„IC
        ic_series = []
        for date in factor_data.index:
            if date in future_return.index:
                factor_values = factor_data.loc[date]
                return_values = future_return.loc[date]

                # å»é™¤NaN
                mask = ~(factor_values.isna() | return_values.isna())
                if mask.sum() > 10:  # è‡³å°‘10ä¸ªæœ‰æ•ˆæ ·æœ¬
                    ic = factor_values[mask].corr(return_values[mask])
                    ic_series.append({'date': date, 'ic': ic})

        ic_df = pd.DataFrame(ic_series).set_index('date')

        # ç»Ÿè®¡IC
        results[f'{period}d'] = {
            'mean_ic': ic_df['ic'].mean(),
            'std_ic': ic_df['ic'].std(),
            'ir': ic_df['ic'].mean() / ic_df['ic'].std(),  # IC/stdï¼Œç±»ä¼¼å¤æ™®æ¯”ç‡
            'ic_positive_rate': (ic_df['ic'] > 0).mean(),
            'ic_series': ic_df
        }

    # å¯è§†åŒ–
    fig, axes = plt.subplots(len(periods), 1, figsize=(12, 4*len(periods)))
    if len(periods) == 1:
        axes = [axes]

    for i, period in enumerate(periods):
        ic_series = results[f'{period}d']['ic_series']

        axes[i].plot(ic_series.index, ic_series['ic'], label='IC', alpha=0.7)
        axes[i].axhline(y=0, color='r', linestyle='--', alpha=0.5)
        axes[i].axhline(y=ic_series['ic'].mean(), color='g', linestyle='--',
                       label=f'Mean IC: {ic_series["ic"].mean():.4f}')
        axes[i].set_title(f'IC Time Series ({period} days)')
        axes[i].set_ylabel('IC')
        axes[i].legend()
        axes[i].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('ic_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

    # æ‰“å°ç»Ÿè®¡ç»“æœ
    print("\nICç»Ÿè®¡ç»“æœ:")
    print("-" * 70)
    for period in periods:
        stats = results[f'{period}d']
        print(f"\n{period}å¤©æŒæœ‰æœŸ:")
        print(f"  å¹³å‡IC: {stats['mean_ic']:.4f}")
        print(f"  ICæ ‡å‡†å·®: {stats['std_ic']:.4f}")
        print(f"  ICIR: {stats['ir']:.4f}")
        print(f"  ICèƒœç‡: {stats['ic_positive_rate']:.2%}")

    print("\n" + "=" * 70)
    print("è¯„åˆ¤æ ‡å‡†:")
    print("  ä¼˜ç§€å› å­: |IC| > 0.05, ICIR > 0.5, ICèƒœç‡ > 55%")
    print("  åˆæ ¼å› å­: |IC| > 0.03, ICIR > 0.3, ICèƒœç‡ > 52%")
    print("  éœ€è¦æ”¹è¿›: |IC| < 0.03")
    print("=" * 70)

    return results
```

**éªŒè¯æ–¹æ³•3ï¼šåˆ†ç»„å›æµ‹**

```python
def group_backtest(factor_data, return_data, n_groups=10, holding_period=20):
    """
    åˆ†ç»„å›æµ‹ï¼šæŒ‰å› å­å€¼åˆ†ç»„ï¼Œè§‚å¯Ÿå„ç»„çš„è¡¨ç°
    """
    # åˆå§‹åŒ–ç»“æœ
    group_returns = {i: [] for i in range(n_groups)}

    # éå†æ¯ä¸ªè°ƒä»“æ—¥
    rebalance_dates = factor_data.index[::holding_period]

    for date in rebalance_dates:
        if date not in factor_data.index:
            continue

        # è·å–å½“æ—¥å› å­å€¼
        factors = factor_data.loc[date].dropna()

        if len(factors) < n_groups:
            continue

        # åˆ†ç»„
        factor_groups = pd.qcut(factors, n_groups, labels=False, duplicates='drop')

        # è®¡ç®—æ¯ç»„åœ¨æŒæœ‰æœŸå†…çš„æ”¶ç›Š
        end_date_idx = factor_data.index.get_loc(date) + holding_period
        if end_date_idx >= len(factor_data.index):
            break

        period_returns = return_data.iloc[
            factor_data.index.get_loc(date):end_date_idx
        ]

        # æ¯ç»„çš„æ”¶ç›Š
        for group_id in range(n_groups):
            stocks_in_group = factor_groups[factor_groups == group_id].index
            if len(stocks_in_group) > 0:
                group_return = period_returns[stocks_in_group].mean(axis=1).sum()
                group_returns[group_id].append(group_return)

    # ç»Ÿè®¡æ¯ç»„çš„è¡¨ç°
    group_stats = pd.DataFrame({
        f'Group_{i}': {
            'mean_return': np.mean(group_returns[i]),
            'std_return': np.std(group_returns[i]),
            'sharpe': np.mean(group_returns[i]) / (np.std(group_returns[i]) + 1e-6) * np.sqrt(252/holding_period),
            'count': len(group_returns[i])
        }
        for i in range(n_groups)
    }).T

    # å¯è§†åŒ–
    plt.figure(figsize=(12, 5))

    # å­å›¾1ï¼šå„ç»„å¹³å‡æ”¶ç›Š
    plt.subplot(1, 2, 1)
    plt.bar(range(n_groups), group_stats['mean_return'])
    plt.xlabel('Group (0=Lowest Factor, 9=Highest Factor)')
    plt.ylabel('Average Return per Period')
    plt.title('Average Return by Factor Group')
    plt.axhline(y=0, color='r', linestyle='--')
    plt.grid(True, alpha=0.3)

    # å­å›¾2ï¼šå„ç»„å¤æ™®æ¯”ç‡
    plt.subplot(1, 2, 2)
    plt.bar(range(n_groups), group_stats['sharpe'])
    plt.xlabel('Group (0=Lowest Factor, 9=Highest Factor)')
    plt.ylabel('Sharpe Ratio')
    plt.title('Sharpe Ratio by Factor Group')
    plt.axhline(y=0, color='r', linestyle='--')
    plt.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('group_backtest.png', dpi=300, bbox_inches='tight')
    plt.show()

    print("\nåˆ†ç»„å›æµ‹ç»“æœ:")
    print(group_stats)

    # å¤šç©ºç»„åˆ
    long_short_return = group_stats.loc[f'Group_{n_groups-1}', 'mean_return'] - \
                       group_stats.loc['Group_0', 'mean_return']
    long_short_sharpe = long_short_return / \
                       np.sqrt(group_stats.loc[f'Group_{n_groups-1}', 'std_return']**2 +
                              group_stats.loc['Group_0', 'std_return']**2)

    print(f"\nå¤šç©ºç»„åˆï¼ˆæœ€é«˜ç»„-æœ€ä½ç»„ï¼‰:")
    print(f"  å¹³å‡æ”¶ç›Š: {long_short_return:.4f}")
    print(f"  å¤æ™®æ¯”ç‡: {long_short_sharpe:.4f}")

    return group_stats

```

**å‡è®¾éªŒè¯çš„åˆ¤æ–­æ ‡å‡†**ï¼š

| æŒ‡æ ‡ | ä¼˜ç§€ | åˆæ ¼ | éœ€æ”¹è¿› |
|------|------|------|--------|
| ICå‡å€¼ | \|IC\| > 0.05 | \|IC\| > 0.03 | \|IC\| < 0.03 |
| ICIR | > 0.5 | > 0.3 | < 0.3 |
| ICèƒœç‡ | > 55% | > 52% | < 52% |
| å¤šç©ºæ”¶ç›Š | > 5% | > 2% | < 2% |
| å•è°ƒæ€§ | å®Œå…¨å•è°ƒ | åŸºæœ¬å•è°ƒ | ä¸å•è°ƒ |

âš ï¸ **å¦‚æœå‡è®¾éªŒè¯æœªé€šè¿‡ï¼Œä¸è¦å¼ºè¡Œç»§ç»­ï¼åº”è¯¥å›åˆ°Ideaé˜¶æ®µé‡æ–°æ€è€ƒã€‚**

### â— 17.1.4 ç­–ç•¥è®¾è®¡

å‡è®¾éªŒè¯é€šè¿‡åï¼Œè¿›å…¥è¯¦ç»†çš„ç­–ç•¥è®¾è®¡é˜¶æ®µã€‚è¿™ä¸ªé˜¶æ®µéœ€è¦è®¾è®¡ç­–ç•¥çš„æ¯ä¸ªç»†èŠ‚ã€‚

**ç­–ç•¥è®¾è®¡æ–‡æ¡£æ¨¡æ¿**ï¼š

```markdown
# ç­–ç•¥è®¾è®¡æ–‡æ¡£

## 1. ç­–ç•¥æ¦‚è¿°
- **ç­–ç•¥åç§°**: åŠ¨é‡+å¸‚åœºå‹åŠ›è‡ªé€‚åº”ç­–ç•¥
- **ç­–ç•¥ç±»å‹**: å¤šå› å­é€‰è‚¡ç­–ç•¥
- **ç›®æ ‡å¸‚åœº**: æ²ªæ·±300æˆåˆ†è‚¡
- **é¢„æœŸå¹´åŒ–æ”¶ç›Š**: 20-30%
- **é¢„æœŸæœ€å¤§å›æ’¤**: < 20%
- **é¢„æœŸå¤æ™®æ¯”ç‡**: > 1.5

## 2. æ ¸å¿ƒé€»è¾‘

### 2.1 å› å­æ„å»º
**åŠ¨é‡å› å­**:
- è®¡ç®—è¿‡å»12ä¸ªæœˆæ”¶ç›Šç‡ï¼ˆ252ä¸ªäº¤æ˜“æ—¥ï¼‰
- è·³è¿‡æœ€è¿‘1ä¸ªæœˆï¼ˆ20ä¸ªäº¤æ˜“æ—¥ï¼‰
- å…¬å¼: `momentum = (close[-20] / close[-252]) - 1`

**å¸‚åœºå‹åŠ›æŒ‡æ ‡**:
- ä½¿ç”¨æ²ªæ·±300æŒ‡æ•°çš„20æ—¥å†å²æ³¢åŠ¨ç‡
- å…¬å¼: `market_stress = std(hs300_return, 20) * sqrt(252)`
- å½’ä¸€åŒ–åˆ°0-1åŒºé—´

### 2.2 ä»“ä½ç®¡ç†
æ ¹æ®å¸‚åœºå‹åŠ›åŠ¨æ€è°ƒæ•´æ€»ä»“ä½:
```
if market_stress < 0.15:      # ä½å‹åŠ›
    target_position = 1.0      # æ»¡ä»“
elif market_stress < 0.25:    # ä¸­ç­‰å‹åŠ›
    target_position = 0.6      # 60%ä»“ä½
else:                          # é«˜å‹åŠ›
    target_position = 0.3      # 30%ä»“ä½
```

### 2.3 é€‰è‚¡è§„åˆ™
1. ä»æ²ªæ·±300æˆåˆ†è‚¡ä¸­ç­›é€‰
2. å‰”é™¤ä»¥ä¸‹è‚¡ç¥¨:
   - STè‚¡ç¥¨
   - åœç‰Œè‚¡ç¥¨
   - ä¸Šå¸‚ä¸æ»¡1å¹´çš„è‚¡ç¥¨
   - è¿‡å»20å¤©æ—¥å‡æˆäº¤é¢ < 1000ä¸‡
3. æŒ‰åŠ¨é‡å› å­æ’åºï¼Œé€‰æ‹©å‰30åª
4. ç­‰æƒé‡é…ç½®

### 2.4 è°ƒä»“è§„åˆ™
- **è°ƒä»“é¢‘ç‡**: æ¯æœˆç¬¬ä¸€ä¸ªäº¤æ˜“æ—¥
- **è°ƒä»“æ–¹å¼**:
  1. å–å‡ºä¸åœ¨æ–°æŒä»“åˆ—è¡¨ä¸­çš„è‚¡ç¥¨
  2. ä¹°å…¥æ–°è‚¡ç¥¨
  3. è°ƒæ•´ç°æœ‰æŒä»“æƒé‡
- **ä¸‹å•æ—¶é—´**: å¼€ç›˜å9:35-9:45ï¼ˆé¿å¼€é›†åˆç«ä»·æ³¢åŠ¨ï¼‰
- **ä¸‹å•æ–¹å¼**: é™ä»·å•ï¼Œä»·æ ¼=æœ€æ–°ä»· * (1 Â± 0.001)

## 3. é£æ§è®¾ç½®

### 3.1 ä¸ªè‚¡é£æ§
- å•ç¥¨æœ€å¤§ä»“ä½: 5%
- å•ç¥¨æ­¢æŸ: -15%
- æ—¥å†…æ¶¨è·Œåœä¸äº¤æ˜“

### 3.2 ç»„åˆé£æ§
- æœ€å¤§å›æ’¤é¢„è­¦é˜ˆå€¼: -15%
- æœ€å¤§å›æ’¤å¼ºåˆ¶å‡ä»“é˜ˆå€¼: -20%ï¼ˆå‡è‡³30%ä»“ä½ï¼‰
- è¿ç»­äºæŸé¢„è­¦: è¿ç»­3ä¸ªæœˆäºæŸ

### 3.3 é£é™©é™åˆ¶
- å•æ—¥æ¢æ‰‹ç‡ä¸Šé™: 50%
- æœˆåº¦æ¢æ‰‹ç‡ä¸Šé™: 200%
- ç¦æ­¢æ æ†

## 4. äº¤æ˜“æˆæœ¬å‡è®¾
- ä½£é‡‘: ä¸‡åˆ†ä¹‹2.5ï¼ˆåŒå‘ï¼‰
- å°èŠ±ç¨: åƒåˆ†ä¹‹1ï¼ˆå–å‡ºï¼‰
- æ»‘ç‚¹: ä¸‡åˆ†ä¹‹5ï¼ˆåŒå‘ï¼‰
- æ€»æˆæœ¬: çº¦0.15%ï¼ˆå•è¾¹ï¼‰

## 5. æ•°æ®éœ€æ±‚
- æ—¥çº¿æ•°æ®: å¼€é«˜ä½æ”¶ã€æˆäº¤é‡ã€æˆäº¤é¢
- æŒ‡æ•°æ•°æ®: æ²ªæ·±300æŒ‡æ•°æ—¥çº¿
- åŸºæœ¬ä¿¡æ¯: STæ ‡è®°ã€ä¸Šå¸‚æ—¥æœŸã€åœç‰Œä¿¡æ¯
- æ•°æ®é¢‘ç‡: æ—¥é¢‘
- å†å²æ•°æ®: è‡³å°‘5å¹´

## 6. æŠ€æœ¯å®ç°

### 6.1 å¼€å‘è¯­è¨€
Python 3.8+

### 6.2 æ ¸å¿ƒåº“
- pandas: æ•°æ®å¤„ç†
- numpy: æ•°å€¼è®¡ç®—
- backtrader: å›æµ‹æ¡†æ¶

### 6.3 æ¨¡å—è®¾è®¡
```
strategy/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ data_loader.py      # æ•°æ®åŠ è½½
â”‚   â””â”€â”€ data_cleaner.py     # æ•°æ®æ¸…æ´—
â”œâ”€â”€ factors/
â”‚   â”œâ”€â”€ momentum.py         # åŠ¨é‡å› å­
â”‚   â””â”€â”€ market_stress.py    # å¸‚åœºå‹åŠ›
â”œâ”€â”€ strategy/
â”‚   â”œâ”€â”€ position_manager.py # ä»“ä½ç®¡ç†
â”‚   â””â”€â”€ signal_generator.py # ä¿¡å·ç”Ÿæˆ
â”œâ”€â”€ backtest/
â”‚   â”œâ”€â”€ backtest_engine.py  # å›æµ‹å¼•æ“
â”‚   â””â”€â”€ analyzer.py         # ç»“æœåˆ†æ
â””â”€â”€ main.py                 # ä¸»ç¨‹åº
```

## 7. å›æµ‹è®¡åˆ’
1. æ ·æœ¬å†…å›æµ‹: 2019-2021
2. æ ·æœ¬å¤–å›æµ‹: 2022-2023
3. å‚æ•°æ•æ„Ÿæ€§æµ‹è¯•
4. ç¨³å¥æ€§æ£€éªŒï¼ˆä¸åŒå¸‚åœºç¯å¢ƒï¼‰

## 8. é¢„æœŸä¸Šçº¿æ—¶é—´
2024å¹´Q2

## 9. è´£ä»»äºº
- ç­–ç•¥è®¾è®¡: å¼ ä¸‰
- ä»£ç å¼€å‘: æå››
- å›æµ‹éªŒè¯: ç‹äº”
```

### â— 17.1.5 ç¼–ç å®ç°

è®¾è®¡æ–‡æ¡£å®Œæˆåï¼Œè¿›å…¥ç¼–ç å®ç°é˜¶æ®µã€‚

**ä»£ç ç»“æ„æœ€ä½³å®è·µ**ï¼š

```python
# 1. é…ç½®æ–‡ä»¶ï¼ˆconfig.pyï¼‰
class StrategyConfig:
    """ç­–ç•¥é…ç½®"""

    # å› å­å‚æ•°
    MOMENTUM_LOOKBACK = 252  # åŠ¨é‡å›çœ‹æœŸ
    MOMENTUM_SKIP = 20       # è·³è¿‡æœ€è¿‘Nå¤©
    STRESS_WINDOW = 20       # å¸‚åœºå‹åŠ›è®¡ç®—çª—å£

    # é€‰è‚¡å‚æ•°
    UNIVERSE = 'hs300'       # è‚¡ç¥¨æ± 
    N_STOCKS = 30            # é€‰è‚¡æ•°é‡
    MIN_LISTING_DAYS = 252   # æœ€å°ä¸Šå¸‚å¤©æ•°
    MIN_AVG_AMOUNT = 10000000  # æœ€å°æ—¥å‡æˆäº¤é¢

    # ä»“ä½å‚æ•°
    POSITION_LOW_STRESS = 1.0
    POSITION_MED_STRESS = 0.6
    POSITION_HIGH_STRESS = 0.3
    STRESS_THRESHOLD_LOW = 0.15
    STRESS_THRESHOLD_HIGH = 0.25

    # è°ƒä»“å‚æ•°
    REBALANCE_FREQ = 'M'     # æœˆåº¦è°ƒä»“

    # é£æ§å‚æ•°
    MAX_SINGLE_POSITION = 0.05
    STOP_LOSS_THRESHOLD = -0.15
    MAX_DRAWDOWN_ALERT = -0.15
    MAX_DRAWDOWN_REDUCE = -0.20

    # äº¤æ˜“æˆæœ¬
    COMMISSION = 0.00025     # ä½£é‡‘ä¸‡2.5
    TAX = 0.001             # å°èŠ±ç¨åƒ1
    SLIPPAGE = 0.0005       # æ»‘ç‚¹ä¸‡5

# 2. æ•°æ®åŠ è½½æ¨¡å—ï¼ˆdata_loader.pyï¼‰
import pandas as pd
import tushare as ts

class DataLoader:
    """æ•°æ®åŠ è½½å™¨"""

    def __init__(self, token):
        self.pro = ts.pro_api(token)

    def load_stock_data(self, ts_code, start_date, end_date):
        """åŠ è½½è‚¡ç¥¨æ•°æ®"""
        df = self.pro.daily(
            ts_code=ts_code,
            start_date=start_date,
            end_date=end_date
        )
        df = df.sort_values('trade_date')
        df['trade_date'] = pd.to_datetime(df['trade_date'])
        df = df.set_index('trade_date')
        return df

    def load_index_data(self, ts_code, start_date, end_date):
        """åŠ è½½æŒ‡æ•°æ•°æ®"""
        df = self.pro.index_daily(
            ts_code=ts_code,
            start_date=start_date,
            end_date=end_date
        )
        df = df.sort_values('trade_date')
        df['trade_date'] = pd.to_datetime(df['trade_date'])
        df = df.set_index('trade_date')
        return df

    def load_stock_basic(self):
        """åŠ è½½è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯"""
        df = self.pro.stock_basic(
            exchange='',
            list_status='L',
            fields='ts_code,symbol,name,area,industry,list_date'
        )
        df['list_date'] = pd.to_datetime(df['list_date'])
        return df

# 3. å› å­è®¡ç®—æ¨¡å—ï¼ˆfactors.pyï¼‰
import numpy as np
import pandas as pd

class MomentumFactor:
    """åŠ¨é‡å› å­"""

    def __init__(self, lookback=252, skip=20):
        self.lookback = lookback
        self.skip = skip

    def calculate(self, price_data):
        """
        è®¡ç®—åŠ¨é‡å› å­

        å‚æ•°:
            price_data: DataFrame, indexä¸ºæ—¥æœŸï¼Œcolumnsä¸ºè‚¡ç¥¨ä»£ç ï¼Œvaluesä¸ºæ”¶ç›˜ä»·

        è¿”å›:
            DataFrame, åŠ¨é‡å› å­å€¼
        """
        # å½“å‰ä»·æ ¼ / lookbackå¤©å‰çš„ä»·æ ¼ - 1
        momentum = price_data / price_data.shift(self.lookback) - 1

        # è·³è¿‡æœ€è¿‘skipå¤©
        if self.skip > 0:
            momentum = momentum.shift(self.skip)

        return momentum

class MarketStressFactor:
    """å¸‚åœºå‹åŠ›å› å­"""

    def __init__(self, window=20):
        self.window = window

    def calculate(self, index_price):
        """
        è®¡ç®—å¸‚åœºå‹åŠ›ï¼ˆæ³¢åŠ¨ç‡ï¼‰

        å‚æ•°:
            index_price: Series, æŒ‡æ•°ä»·æ ¼

        è¿”å›:
            Series, å¸‚åœºå‹åŠ›å€¼
        """
        # è®¡ç®—æ”¶ç›Šç‡
        returns = index_price.pct_change()

        # è®¡ç®—æ»šåŠ¨æ³¢åŠ¨ç‡ï¼ˆå¹´åŒ–ï¼‰
        volatility = returns.rolling(self.window).std() * np.sqrt(252)

        return volatility

# 4. ç­–ç•¥æ ¸å¿ƒé€»è¾‘ï¼ˆstrategy.pyï¼‰
class AdaptiveMomentumStrategy:
    """è‡ªé€‚åº”åŠ¨é‡ç­–ç•¥"""

    def __init__(self, config):
        self.config = config
        self.momentum_factor = MomentumFactor(
            lookback=config.MOMENTUM_LOOKBACK,
            skip=config.MOMENTUM_SKIP
        )
        self.stress_factor = MarketStressFactor(
            window=config.STRESS_WINDOW
        )

    def calculate_target_position(self, market_stress):
        """æ ¹æ®å¸‚åœºå‹åŠ›è®¡ç®—ç›®æ ‡ä»“ä½"""
        if market_stress < self.config.STRESS_THRESHOLD_LOW:
            return self.config.POSITION_LOW_STRESS
        elif market_stress < self.config.STRESS_THRESHOLD_HIGH:
            return self.config.POSITION_MED_STRESS
        else:
            return self.config.POSITION_HIGH_STRESS

    def select_stocks(self, momentum_values, n_stocks):
        """é€‰è‚¡"""
        # å»é™¤NaN
        valid_stocks = momentum_values.dropna()

        # æŒ‰åŠ¨é‡å› å­é™åºæ’åº
        sorted_stocks = valid_stocks.sort_values(ascending=False)

        # é€‰æ‹©å‰nåª
        selected = sorted_stocks.head(n_stocks)

        return list(selected.index)

    def generate_signals(self, date, price_data, index_data, stock_basic):
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        # è®¡ç®—åŠ¨é‡å› å­
        momentum = self.momentum_factor.calculate(price_data)

        # è®¡ç®—å¸‚åœºå‹åŠ›
        stress = self.stress_factor.calculate(index_data['close'])

        # è·å–å½“æ—¥çš„å€¼
        current_momentum = momentum.loc[date]
        current_stress = stress.loc[date]

        # è¿‡æ»¤è‚¡ç¥¨æ± 
        filtered_momentum = self.filter_universe(
            current_momentum, date, price_data, stock_basic
        )

        # é€‰è‚¡
        selected_stocks = self.select_stocks(
            filtered_momentum, self.config.N_STOCKS
        )

        # è®¡ç®—ç›®æ ‡ä»“ä½
        target_position = self.calculate_target_position(current_stress)

        # ç­‰æƒé‡
        if len(selected_stocks) > 0:
            weight_per_stock = target_position / len(selected_stocks)
            weights = {stock: weight_per_stock for stock in selected_stocks}
        else:
            weights = {}

        return weights

    def filter_universe(self, momentum, date, price_data, stock_basic):
        """è¿‡æ»¤è‚¡ç¥¨æ± """
        filtered = momentum.copy()

        # è¿‡æ»¤STè‚¡ç¥¨ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦STåˆ—è¡¨ï¼‰
        # filtered = filtered[~filtered.index.str.contains('ST')]

        # è¿‡æ»¤ä¸Šå¸‚æ—¶é—´ä¸è¶³çš„è‚¡ç¥¨
        min_list_date = date - pd.Timedelta(days=self.config.MIN_LISTING_DAYS)
        valid_stocks = stock_basic[stock_basic['list_date'] <= min_list_date]['ts_code']
        filtered = filtered[filtered.index.isin(valid_stocks)]

        # è¿‡æ»¤æˆäº¤é¢ä¸è¶³çš„è‚¡ç¥¨ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…éœ€è¦æˆäº¤é¢æ•°æ®ï¼‰

        return filtered

# 5. ä¸»ç¨‹åºï¼ˆmain.pyï¼‰
def main():
    # 1. åŠ è½½é…ç½®
    config = StrategyConfig()

    # 2. åŠ è½½æ•°æ®
    loader = DataLoader(token='your_tushare_token')

    # åŠ è½½æ²ªæ·±300æˆåˆ†è‚¡
    # ... çœç•¥æ•°æ®åŠ è½½ä»£ç  ...

    # 3. åˆå§‹åŒ–ç­–ç•¥
    strategy = AdaptiveMomentumStrategy(config)

    # 4. è¿è¡Œå›æµ‹
    # ... çœç•¥å›æµ‹ä»£ç  ...

    print("ç­–ç•¥å¼€å‘å®Œæˆï¼")

if __name__ == '__main__':
    main()
```

**ç¼–ç è§„èŒƒ**ï¼š

1. **å‘½åè§„èŒƒ**
   - ç±»åï¼šå¤§é©¼å³°ï¼ˆ`AdaptiveMomentumStrategy`ï¼‰
   - å‡½æ•°åï¼šå°å†™+ä¸‹åˆ’çº¿ï¼ˆ`calculate_momentum`ï¼‰
   - å¸¸é‡ï¼šå¤§å†™+ä¸‹åˆ’çº¿ï¼ˆ`MAX_POSITION`ï¼‰
   - ç§æœ‰å˜é‡ï¼šå‰ç¼€ä¸‹åˆ’çº¿ï¼ˆ`_internal_data`ï¼‰

2. **æ–‡æ¡£å­—ç¬¦ä¸²**
   ```python
   def calculate_momentum(price_data, lookback=252, skip=20):
       """
       è®¡ç®—åŠ¨é‡å› å­

       åŠ¨é‡å®šä¹‰ä¸ºè¿‡å»lookbackå¤©çš„æ”¶ç›Šç‡ï¼Œè·³è¿‡æœ€è¿‘skipå¤©ã€‚

       å‚æ•°:
           price_data (DataFrame): ä»·æ ¼æ•°æ®ï¼Œindexä¸ºæ—¥æœŸï¼Œcolumnsä¸ºè‚¡ç¥¨ä»£ç 
           lookback (int): å›çœ‹å¤©æ•°ï¼Œé»˜è®¤252
           skip (int): è·³è¿‡æœ€è¿‘å‡ å¤©ï¼Œé»˜è®¤20

       è¿”å›:
           DataFrame: åŠ¨é‡å› å­å€¼ï¼Œç»“æ„ä¸price_dataç›¸åŒ

       ç¤ºä¾‹:
           >>> momentum = calculate_momentum(prices, lookback=120, skip=10)
       """
       pass
   ```

3. **ç±»å‹æç¤º**
   ```python
   from typing import Dict, List, Tuple
   import pandas as pd

   def select_stocks(
       momentum: pd.Series,
       n_stocks: int
   ) -> List[str]:
       """é€‰æ‹©åŠ¨é‡æœ€é«˜çš„nåªè‚¡ç¥¨"""
       return list(momentum.nlargest(n_stocks).index)
   ```

### â— 17.1.6 å›æµ‹ä¼˜åŒ–

ç¼–ç å®Œæˆåï¼Œè¿›å…¥å›æµ‹å’Œä¼˜åŒ–é˜¶æ®µã€‚

**å›æµ‹æµç¨‹**ï¼š

```python
# å®Œæ•´çš„å›æµ‹æµç¨‹
class Backtester:
    """å›æµ‹å¼•æ“"""

    def __init__(self, strategy, data, config):
        self.strategy = strategy
        self.data = data
        self.config = config
        self.results = []
        self.trades = []
        self.positions = {}
        self.cash = config.INITIAL_CASH

    def run(self, start_date, end_date):
        """è¿è¡Œå›æµ‹"""
        # è·å–æ‰€æœ‰äº¤æ˜“æ—¥
        trading_days = self.data['dates']
        trading_days = trading_days[
            (trading_days >= start_date) & (trading_days <= end_date)
        ]

        # è·å–è°ƒä»“æ—¥
        rebalance_days = self.get_rebalance_days(trading_days)

        # éå†æ¯ä¸ªäº¤æ˜“æ—¥
        for date in trading_days:
            # æ›´æ–°æŒä»“å¸‚å€¼
            self.update_positions(date)

            # è®°å½•å½“æ—¥æƒç›Š
            total_value = self.cash + sum(
                pos['value'] for pos in self.positions.values()
            )
            self.results.append({
                'date': date,
                'total_value': total_value,
                'cash': self.cash,
                'position_value': total_value - self.cash
            })

            # å¦‚æœæ˜¯è°ƒä»“æ—¥ï¼Œæ‰§è¡Œè°ƒä»“
            if date in rebalance_days:
                self.rebalance(date)

        return pd.DataFrame(self.results)

    def rebalance(self, date):
        """è°ƒä»“"""
        # ç”Ÿæˆç›®æ ‡æŒä»“
        target_weights = self.strategy.generate_signals(
            date,
            self.data['price'],
            self.data['index'],
            self.data['basic']
        )

        # å½“å‰æ€»èµ„äº§
        total_value = self.cash + sum(pos['value'] for pos in self.positions.values())

        # è®¡ç®—ç›®æ ‡æŒä»“é‡‘é¢
        target_positions = {
            stock: total_value * weight
            for stock, weight in target_weights.items()
        }

        # å–å‡ºä¸åœ¨ç›®æ ‡ä¸­çš„è‚¡ç¥¨
        for stock in list(self.positions.keys()):
            if stock not in target_positions:
                self.sell(date, stock, self.positions[stock]['shares'])

        # è°ƒæ•´ç°æœ‰æŒä»“ + ä¹°å…¥æ–°è‚¡
        for stock, target_value in target_positions.items():
            current_value = self.positions.get(stock, {}).get('value', 0)
            diff_value = target_value - current_value

            if abs(diff_value) > 100:  # å·®å¼‚å¤§äº100å…ƒæ‰äº¤æ˜“
                price = self.get_price(date, stock)
                shares_to_trade = int(diff_value / price / 100) * 100  # 100è‚¡æ•´æ•°å€

                if shares_to_trade > 0:
                    self.buy(date, stock, shares_to_trade)
                elif shares_to_trade < 0:
                    self.sell(date, stock, -shares_to_trade)

    def buy(self, date, stock, shares):
        """ä¹°å…¥"""
        price = self.get_price(date, stock)
        cost = shares * price * (1 + self.config.COMMISSION + self.config.SLIPPAGE)

        if cost > self.cash:
            shares = int(self.cash / (price * (1 + self.config.COMMISSION + self.config.SLIPPAGE)) / 100) * 100
            cost = shares * price * (1 + self.config.COMMISSION + self.config.SLIPPAGE)

        if shares > 0:
            self.cash -= cost
            if stock in self.positions:
                self.positions[stock]['shares'] += shares
                self.positions[stock]['value'] += shares * price
            else:
                self.positions[stock] = {'shares': shares, 'value': shares * price}

            self.trades.append({
                'date': date,
                'stock': stock,
                'action': 'buy',
                'shares': shares,
                'price': price,
                'cost': cost
            })

    def sell(self, date, stock, shares):
        """å–å‡º"""
        if stock not in self.positions:
            return

        shares = min(shares, self.positions[stock]['shares'])
        price = self.get_price(date, stock)
        proceeds = shares * price * (1 - self.config.COMMISSION - self.config.TAX - self.config.SLIPPAGE)

        self.cash += proceeds
        self.positions[stock]['shares'] -= shares
        self.positions[stock]['value'] -= shares * price

        if self.positions[stock]['shares'] == 0:
            del self.positions[stock]

        self.trades.append({
            'date': date,
            'stock': stock,
            'action': 'sell',
            'shares': shares,
            'price': price,
            'proceeds': proceeds
        })

    def update_positions(self, date):
        """æ›´æ–°æŒä»“å¸‚å€¼"""
        for stock in self.positions:
            price = self.get_price(date, stock)
            self.positions[stock]['value'] = self.positions[stock]['shares'] * price

    def get_price(self, date, stock):
        """è·å–ä»·æ ¼ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…éœ€è¦å¤„ç†å¤æƒã€åœç‰Œç­‰ï¼‰"""
        return self.data['price'].loc[date, stock]

    def get_rebalance_days(self, trading_days):
        """è·å–è°ƒä»“æ—¥"""
        # ç®€åŒ–ï¼šæ¯æœˆç¬¬ä¸€ä¸ªäº¤æ˜“æ—¥
        return trading_days[trading_days.is_month_start]
```

**æ€§èƒ½åˆ†æ**ï¼š

```python
def analyze_performance(results, benchmark=None):
    """
    åˆ†æå›æµ‹è¡¨ç°

    å‚æ•°:
        results: DataFrame, å›æµ‹ç»“æœï¼ŒåŒ…å«dateå’Œtotal_valueåˆ—
        benchmark: Series, åŸºå‡†æŒ‡æ•°ï¼ˆå¯é€‰ï¼‰
    """
    df = results.set_index('date')

    # è®¡ç®—æ”¶ç›Šç‡
    df['return'] = df['total_value'].pct_change()
    df['cum_return'] = (1 + df['return']).cumprod() - 1

    # åŸºå‡†æ”¶ç›Šç‡ï¼ˆå¦‚æœæœ‰ï¼‰
    if benchmark is not None:
        benchmark_return = benchmark.pct_change()
        benchmark_cum_return = (1 + benchmark_return).cumprod() - 1
        df['benchmark_return'] = benchmark_return
        df['benchmark_cum_return'] = benchmark_cum_return
        df['excess_return'] = df['return'] - df['benchmark_return']
        df['excess_cum_return'] = df['cum_return'] - df['benchmark_cum_return']

    # è®¡ç®—æŒ‡æ ‡
    stats = {}

    # æ”¶ç›ŠæŒ‡æ ‡
    stats['æ€»æ”¶ç›Šç‡'] = df['cum_return'].iloc[-1]
    stats['å¹´åŒ–æ”¶ç›Šç‡'] = (1 + stats['æ€»æ”¶ç›Šç‡']) ** (252 / len(df)) - 1

    # é£é™©æŒ‡æ ‡
    stats['æ”¶ç›Šæ³¢åŠ¨ç‡'] = df['return'].std() * np.sqrt(252)
    stats['æœ€å¤§å›æ’¤'] = (df['total_value'] / df['total_value'].cummax() - 1).min()

    # é£é™©è°ƒæ•´æ”¶ç›Š
    stats['å¤æ™®æ¯”ç‡'] = (stats['å¹´åŒ–æ”¶ç›Šç‡'] - 0.03) / stats['æ”¶ç›Šæ³¢åŠ¨ç‡']  # å‡è®¾æ— é£é™©åˆ©ç‡3%
    stats['å¡ç›æ¯”ç‡'] = stats['å¹´åŒ–æ”¶ç›Šç‡'] / abs(stats['æœ€å¤§å›æ’¤'])

    # äº¤æ˜“æŒ‡æ ‡
    stats['èƒœç‡'] = (df['return'] > 0).mean()
    stats['ç›ˆäºæ¯”'] = abs(df[df['return'] > 0]['return'].mean()) / abs(df[df['return'] < 0]['return'].mean())

    # å¦‚æœæœ‰åŸºå‡†
    if benchmark is not None:
        stats['è¶…é¢æ”¶ç›Š'] = df['excess_cum_return'].iloc[-1]
        stats['å¹´åŒ–è¶…é¢æ”¶ç›Š'] = (1 + stats['è¶…é¢æ”¶ç›Š']) ** (252 / len(df)) - 1
        stats['ä¿¡æ¯æ¯”ç‡'] = df['excess_return'].mean() / df['excess_return'].std() * np.sqrt(252)
        stats['Beta'] = df['return'].cov(df['benchmark_return']) / df['benchmark_return'].var()
        stats['Alpha'] = stats['å¹´åŒ–æ”¶ç›Šç‡'] - (0.03 + stats['Beta'] * (df['benchmark_cum_return'].iloc[-1] ** (252/len(df)) - 1 - 0.03))

    # æ‰“å°ç»“æœ
    print("\n" + "="*70)
    print(" "*20 + "å›æµ‹æ€§èƒ½åˆ†æ")
    print("="*70)

    for key, value in stats.items():
        if 'ç‡' in key or 'æ¯”' in key:
            print(f"{key:20s}: {value:>10.2%}")
        else:
            print(f"{key:20s}: {value:>10.4f}")

    print("="*70)

    # å¯è§†åŒ–
    fig, axes = plt.subplots(3, 1, figsize=(14, 10))

    # å­å›¾1ï¼šç´¯è®¡æ”¶ç›Šæ›²çº¿
    axes[0].plot(df.index, (1 + df['cum_return']) * 100, label='ç­–ç•¥', linewidth=2)
    if benchmark is not None:
        axes[0].plot(df.index, (1 + df['benchmark_cum_return']) * 100,
                    label='åŸºå‡†', linewidth=2, alpha=0.7)
    axes[0].set_ylabel('ç´¯è®¡å‡€å€¼')
    axes[0].set_title('ç­–ç•¥å‡€å€¼æ›²çº¿')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)

    # å­å›¾2ï¼šå›æ’¤æ›²çº¿
    drawdown = df['total_value'] / df['total_value'].cummax() - 1
    axes[1].fill_between(df.index, 0, drawdown * 100, alpha=0.3, color='red')
    axes[1].plot(df.index, drawdown * 100, color='red', linewidth=1)
    axes[1].set_ylabel('å›æ’¤ (%)')
    axes[1].set_title('ç­–ç•¥å›æ’¤æ›²çº¿')
    axes[1].grid(True, alpha=0.3)

    # å­å›¾3ï¼šå¹´åº¦æ”¶ç›Š
    yearly_returns = df['return'].resample('Y').apply(lambda x: (1 + x).prod() - 1)
    colors = ['green' if x > 0 else 'red' for x in yearly_returns]
    axes[2].bar(range(len(yearly_returns)), yearly_returns * 100, color=colors)
    axes[2].set_xticks(range(len(yearly_returns)))
    axes[2].set_xticklabels([d.year for d in yearly_returns.index])
    axes[2].set_ylabel('å¹´åº¦æ”¶ç›Š (%)')
    axes[2].set_title('å¹´åº¦æ”¶ç›Šåˆ†å¸ƒ')
    axes[2].axhline(y=0, color='black', linestyle='--', linewidth=0.8)
    axes[2].grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig('backtest_performance.png', dpi=300, bbox_inches='tight')
    plt.show()

    return stats, df
```

**å‚æ•°ä¼˜åŒ–**ï¼š

```python
from itertools import product

def parameter_optimization(strategy_class, param_grid, data):
    """
    å‚æ•°ä¼˜åŒ–ï¼ˆç½‘æ ¼æœç´¢ï¼‰

    å‚æ•°:
        strategy_class: ç­–ç•¥ç±»
        param_grid: dict, å‚æ•°ç½‘æ ¼ï¼Œå¦‚ {'lookback': [120, 180, 252], 'n_stocks': [20, 30, 40]}
        data: æ•°æ®
    """
    # ç”Ÿæˆæ‰€æœ‰å‚æ•°ç»„åˆ
    keys = param_grid.keys()
    values = param_grid.values()
    param_combinations = [dict(zip(keys, v)) for v in product(*values)]

    print(f"æ€»å…±éœ€è¦æµ‹è¯• {len(param_combinations)} ç»„å‚æ•°...\n")

    results = []

    for i, params in enumerate(param_combinations, 1):
        print(f"[{i}/{len(param_combinations)}] æµ‹è¯•å‚æ•°: {params}")

        # åˆ›å»ºç­–ç•¥å®ä¾‹
        config = StrategyConfig()
        for key, value in params.items():
            setattr(config, key.upper(), value)

        strategy = strategy_class(config)

        # è¿è¡Œå›æµ‹
        backtester = Backtester(strategy, data, config)
        backtest_results = backtester.run(
            start_date=data['start_date'],
            end_date=data['end_date']
        )

        # è®¡ç®—å…³é”®æŒ‡æ ‡
        returns = backtest_results['total_value'].pct_change()
        cum_return = (1 + returns).prod() - 1
        annual_return = (1 + cum_return) ** (252 / len(returns)) - 1
        volatility = returns.std() * np.sqrt(252)
        sharpe = (annual_return - 0.03) / volatility
        max_dd = (backtest_results['total_value'] / backtest_results['total_value'].cummax() - 1).min()

        results.append({
            **params,
            'å¹´åŒ–æ”¶ç›Š': annual_return,
            'æ³¢åŠ¨ç‡': volatility,
            'å¤æ™®æ¯”ç‡': sharpe,
            'æœ€å¤§å›æ’¤': max_dd
        })

    # è½¬æ¢ä¸ºDataFrame
    results_df = pd.DataFrame(results)

    # æ’åºï¼ˆæŒ‰å¤æ™®æ¯”ç‡ï¼‰
    results_df = results_df.sort_values('å¤æ™®æ¯”ç‡', ascending=False)

    print("\n" + "="*80)
    print("å‚æ•°ä¼˜åŒ–ç»“æœï¼ˆæŒ‰å¤æ™®æ¯”ç‡æ’åºï¼‰:")
    print("="*80)
    print(results_df.head(10).to_string(index=False))
    print("="*80)

    # å¯è§†åŒ–
    if len(param_grid) == 2:
        # å¦‚æœæ˜¯2ç»´å‚æ•°ï¼Œç»˜åˆ¶çƒ­åŠ›å›¾
        param1, param2 = list(param_grid.keys())
        pivot_table = results_df.pivot(param1, param2, 'å¤æ™®æ¯”ç‡')

        plt.figure(figsize=(10, 8))
        sns.heatmap(pivot_table, annot=True, fmt='.2f', cmap='RdYlGn', center=0)
        plt.title('å‚æ•°ä¼˜åŒ–çƒ­åŠ›å›¾ï¼ˆå¤æ™®æ¯”ç‡ï¼‰')
        plt.tight_layout()
        plt.savefig('parameter_optimization.png', dpi=300, bbox_inches='tight')
        plt.show()

    return results_df

# ä½¿ç”¨ç¤ºä¾‹
param_grid = {
    'momentum_lookback': [120, 180, 252],
    'n_stocks': [20, 30, 40],
    'stress_threshold_low': [0.12, 0.15, 0.18]
}

optimization_results = parameter_optimization(
    AdaptiveMomentumStrategy,
    param_grid,
    data
)
```

âš ï¸ **å‚æ•°ä¼˜åŒ–çš„æ³¨æ„äº‹é¡¹**ï¼š

1. **é˜²æ­¢è¿‡æ‹Ÿåˆ**ï¼š
   - ä½¿ç”¨æ ·æœ¬å¤–æµ‹è¯•éªŒè¯æœ€ä¼˜å‚æ•°
   - ä¸è¦åœ¨åŒä¸€æ•°æ®é›†ä¸Šåå¤ä¼˜åŒ–
   - å‚æ•°æ•æ„Ÿæ€§ä¸åº”å¤ªé«˜ï¼ˆå‘¨å›´å‚æ•°è¡¨ç°ä¹Ÿåº”è¯¥ä¸é”™ï¼‰

2. **è®¡ç®—æˆæœ¬**ï¼š
   - å‚æ•°ç»„åˆæ•°é‡ = æ‰€æœ‰å‚æ•°é€‰é¡¹æ•°é‡çš„ä¹˜ç§¯
   - ä¾‹å¦‚ï¼š3ä¸ªå‚æ•°ï¼Œæ¯ä¸ª3ä¸ªé€‰é¡¹ = 3Â³ = 27æ¬¡å›æµ‹
   - å¯ä»¥ä½¿ç”¨éšæœºæœç´¢æˆ–è´å¶æ–¯ä¼˜åŒ–å‡å°‘è®¡ç®—é‡

3. **å¤šç›®æ ‡ä¼˜åŒ–**ï¼š
   - ä¸è¦åªçœ‹æ”¶ç›Šç‡ï¼Œè¿˜è¦çœ‹å¤æ™®ã€æœ€å¤§å›æ’¤
   - ä½¿ç”¨å¸•ç´¯æ‰˜å‰æ²¿æ‰¾åˆ°æ”¶ç›Š-é£é™©çš„å¹³è¡¡ç‚¹

### â— 17.1.7 å®ç›˜éƒ¨ç½²

å›æµ‹æ»¡æ„åï¼Œè¿›å…¥æœ€å…³é”®çš„å®ç›˜éƒ¨ç½²é˜¶æ®µã€‚

**å®ç›˜å‰æ£€æŸ¥æ¸…å•**ï¼š

```markdown
# å®ç›˜éƒ¨ç½²æ£€æŸ¥æ¸…å•

## ä»£ç æ£€æŸ¥
- [ ] æ‰€æœ‰ä»£ç å·²ç»è¿‡ä»£ç å®¡æŸ¥
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] æ— æœªæ¥å‡½æ•°
- [ ] å¤„ç†äº†åœç‰Œã€æ¶¨è·Œåœã€STç­‰ç‰¹æ®Šæƒ…å†µ
- [ ] äº¤æ˜“æˆæœ¬è®¾ç½®åˆç†
- [ ] æ—¥å¿—è®°å½•å®Œå–„

## æ•°æ®æ£€æŸ¥
- [ ] æ•°æ®æºç¨³å®šå¯é 
- [ ] æ•°æ®æ›´æ–°åŠæ—¶ï¼ˆå»¶è¿Ÿ < 5åˆ†é’Ÿï¼‰
- [ ] æ•°æ®å¤‡ä»½æ–¹æ¡ˆå·²éƒ¨ç½²
- [ ] æ•°æ®å¼‚å¸¸å¤„ç†æœºåˆ¶å·²æµ‹è¯•

## é£æ§æ£€æŸ¥
- [ ] æ­¢æŸæœºåˆ¶å·²æµ‹è¯•
- [ ] ä»“ä½é™åˆ¶å·²è®¾ç½®
- [ ] å›æ’¤é¢„è­¦å·²é…ç½®
- [ ] åº”æ€¥æ­¢æŸæŒ‰é’®å·²å‡†å¤‡

## äº¤æ˜“æ¥å£æ£€æŸ¥
- [ ] äº¤æ˜“æ¥å£ç¨³å®šæ€§æµ‹è¯•é€šè¿‡
- [ ] ä¸‹å•é€Ÿåº¦æµ‹è¯•é€šè¿‡
- [ ] æ’¤å•åŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] å¼‚å¸¸æƒ…å†µå¤„ç†æµ‹è¯•é€šè¿‡

## ç›‘æ§æ£€æŸ¥
- [ ] å®æ—¶ç›‘æ§é¢æ¿å·²éƒ¨ç½²
- [ ] å‘Šè­¦ç³»ç»Ÿå·²é…ç½®ï¼ˆé‚®ä»¶/çŸ­ä¿¡/é’‰é’‰ï¼‰
- [ ] æ—¥å¿—ç³»ç»Ÿå·²éƒ¨ç½²
- [ ] æ¯æ—¥æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ

## å…¶ä»–
- [ ] åº”æ€¥é¢„æ¡ˆå·²å‡†å¤‡
- [ ] è”ç³»äººåˆ—è¡¨å·²æ›´æ–°
- [ ] å°èµ„é‡‘æµ‹è¯•è®¡åˆ’å·²åˆ¶å®š
```

**å®ç›˜éƒ¨ç½²æµç¨‹**ï¼š

```python
# å®ç›˜äº¤æ˜“ç³»ç»Ÿæ¡†æ¶
class LiveTradingSystem:
    """å®ç›˜äº¤æ˜“ç³»ç»Ÿ"""

    def __init__(self, strategy, trader, risk_manager, monitor):
        self.strategy = strategy
        self.trader = trader
        self.risk_manager = risk_manager
        self.monitor = monitor
        self.is_running = False
        self.positions = {}

    def start(self):
        """å¯åŠ¨å®ç›˜äº¤æ˜“"""
        self.is_running = True
        print("å®ç›˜äº¤æ˜“ç³»ç»Ÿå·²å¯åŠ¨")

        # å¯åŠ¨ç›‘æ§çº¿ç¨‹
        self.monitor.start()

        # ä¸»å¾ªç¯
        while self.is_running:
            try:
                # æ£€æŸ¥æ˜¯å¦äº¤æ˜“æ—¶é—´
                if not self.is_trading_time():
                    time.sleep(60)
                    continue

                # æ£€æŸ¥æ˜¯å¦è°ƒä»“æ—¥
                if self.is_rebalance_day():
                    self.rebalance()

                # æ£€æŸ¥é£æ§
                self.risk_manager.check()

                # æ›´æ–°ç›‘æ§
                self.monitor.update(self.positions)

                time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

            except Exception as e:
                self.monitor.alert(f"ç³»ç»Ÿé”™è¯¯: {e}", level='ERROR')
                self.log_error(e)

    def rebalance(self):
        """æ‰§è¡Œè°ƒä»“"""
        try:
            # 1. è·å–å½“å‰æŒä»“
            current_positions = self.trader.get_positions()

            # 2. è·å–å½“å‰èµ„é‡‘
            cash = self.trader.get_cash()

            # 3. ç”Ÿæˆç›®æ ‡æŒä»“
            target_positions = self.strategy.generate_signals()

            # 4. é£æ§æ£€æŸ¥
            if not self.risk_manager.approve(target_positions):
                self.monitor.alert("ç›®æ ‡æŒä»“æœªé€šè¿‡é£æ§æ£€æŸ¥", level='WARNING')
                return

            # 5. è®¡ç®—äº¤æ˜“æŒ‡ä»¤
            orders = self.calculate_orders(current_positions, target_positions, cash)

            # 6. æ‰§è¡Œäº¤æ˜“
            for order in orders:
                if order['action'] == 'sell':
                    # å…ˆå–å‡º
                    self.trader.sell(
                        order['stock'],
                        order['shares'],
                        order['price']
                    )

            # ç­‰å¾…å–å•æˆäº¤
            time.sleep(10)

            for order in orders:
                if order['action'] == 'buy':
                    # å†ä¹°å…¥
                    self.trader.buy(
                        order['stock'],
                        order['shares'],
                        order['price']
                    )

            # 7. è®°å½•æ—¥å¿—
            self.log_rebalance(orders)

            # 8. å‘é€é€šçŸ¥
            self.monitor.notify_rebalance(orders)

        except Exception as e:
            self.monitor.alert(f"è°ƒä»“å¤±è´¥: {e}", level='ERROR')
            self.log_error(e)

    def stop(self):
        """åœæ­¢äº¤æ˜“ç³»ç»Ÿ"""
        self.is_running = False
        self.monitor.stop()
        print("å®ç›˜äº¤æ˜“ç³»ç»Ÿå·²åœæ­¢")
```

**å°èµ„é‡‘è¯•é”™ç­–ç•¥**ï¼š

1. **ç¬¬1é˜¶æ®µï¼ˆ1-3ä¸ªæœˆï¼‰**ï¼š1ä¸‡å…ƒ
   - ç›®çš„ï¼šéªŒè¯ç­–ç•¥åœ¨çœŸå®å¸‚åœºçš„è¡¨ç°
   - å…³æ³¨ï¼šæ‰§è¡Œåå·®ã€æ»‘ç‚¹ã€æˆäº¤ç‡
   - æ¥å—ï¼šå¯èƒ½çš„å°é¢äºæŸ

2. **ç¬¬2é˜¶æ®µï¼ˆ3-6ä¸ªæœˆï¼‰**ï¼š5-10ä¸‡å…ƒ
   - ç›®çš„ï¼šéªŒè¯ç­–ç•¥çš„ç¨³å®šæ€§
   - å…³æ³¨ï¼šæ˜¯å¦ç¬¦åˆå›æµ‹é¢„æœŸ
   - æ ‡å‡†ï¼šå¤æ™®æ¯”ç‡ > å›æµ‹çš„70%

3. **ç¬¬3é˜¶æ®µï¼ˆ6-12ä¸ªæœˆï¼‰**ï¼šé€æ­¥æ”¾å¤§åˆ°ç›®æ ‡è§„æ¨¡
   - ç›®çš„ï¼šè¾¾åˆ°ç­–ç•¥å®¹é‡ä¸Šé™
   - å…³æ³¨ï¼šè§„æ¨¡æ•ˆåº”ã€æµåŠ¨æ€§å½±å“
   - ç­–ç•¥ï¼šæ¯æœˆå¢åŠ 10-20%èµ„é‡‘

âš ï¸ **åƒä¸‡ä¸è¦ä¸€ä¸Šæ¥å°±æŠ•å…¥å¤§é¢èµ„é‡‘ï¼**

---

## 17.2 ç­–ç•¥å¼€å‘æœ€ä½³å®è·µ

ä¸“ä¸šçš„ç­–ç•¥å¼€å‘ä¸ä»…ä»…æ˜¯å†™ä»£ç ï¼Œè¿˜éœ€è¦éµå¾ªä¸€ç³»åˆ—æœ€ä½³å®è·µï¼Œç¡®ä¿ä»£ç çš„è´¨é‡ã€å¯ç»´æŠ¤æ€§å’Œå›¢é˜Ÿåä½œæ•ˆç‡ã€‚

### â— 17.2.1 ä»£ç è§„èŒƒ

**1. é¡¹ç›®ç»“æ„**

```
quantitative_strategy/
â”œâ”€â”€ README.md                 # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ requirements.txt          # ä¾èµ–åˆ—è¡¨
â”œâ”€â”€ .gitignore               # Gitå¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ strategy_config.py   # ç­–ç•¥é…ç½®
â”‚   â””â”€â”€ env_config.py        # ç¯å¢ƒé…ç½®
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ loader.py            # æ•°æ®åŠ è½½
â”‚   â”œâ”€â”€ cleaner.py           # æ•°æ®æ¸…æ´—
â”‚   â””â”€â”€ storage.py           # æ•°æ®å­˜å‚¨
â”œâ”€â”€ factors/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py              # å› å­åŸºç±»
â”‚   â”œâ”€â”€ momentum.py          # åŠ¨é‡å› å­
â”‚   â”œâ”€â”€ value.py             # ä»·å€¼å› å­
â”‚   â””â”€â”€ quality.py           # è´¨é‡å› å­
â”œâ”€â”€ strategies/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py              # ç­–ç•¥åŸºç±»
â”‚   â””â”€â”€ adaptive_momentum.py # å…·ä½“ç­–ç•¥
â”œâ”€â”€ backtest/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ engine.py            # å›æµ‹å¼•æ“
â”‚   â”œâ”€â”€ analyzer.py          # æ€§èƒ½åˆ†æ
â”‚   â””â”€â”€ visualizer.py        # å¯è§†åŒ–
â”œâ”€â”€ risk/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ position.py          # ä»“ä½ç®¡ç†
â”‚   â””â”€â”€ risk_control.py      # é£æ§
â”œâ”€â”€ trade/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ trader.py            # äº¤æ˜“æ¥å£
â”‚   â””â”€â”€ execution.py         # æ‰§è¡Œç®—æ³•
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ logger.py            # æ—¥å¿—å·¥å…·
â”‚   â”œâ”€â”€ metrics.py           # æŒ‡æ ‡è®¡ç®—
â”‚   â””â”€â”€ helpers.py           # è¾…åŠ©å‡½æ•°
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_factors.py
â”‚   â”œâ”€â”€ test_strategies.py
â”‚   â””â”€â”€ test_backtest.py
â”œâ”€â”€ notebooks/
â”‚   â”œâ”€â”€ research_momentum.ipynb
â”‚   â””â”€â”€ parameter_optimization.ipynb
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ run_backtest.py      # è¿è¡Œå›æµ‹
â”‚   â”œâ”€â”€ run_live.py          # è¿è¡Œå®ç›˜
â”‚   â””â”€â”€ generate_report.py   # ç”ŸæˆæŠ¥å‘Š
â””â”€â”€ logs/
    â””â”€â”€ .gitkeep
```

**2. ç¼–ç é£æ ¼ï¼ˆéµå¾ªPEP 8ï¼‰**

```python
# å¥½çš„ç¤ºä¾‹
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple

class MomentumFactor:
    """
    åŠ¨é‡å› å­è®¡ç®—ç±»

    Attributes:
        lookback (int): å›çœ‹æœŸ
        skip (int): è·³è¿‡å¤©æ•°
    """

    def __init__(self, lookback: int = 252, skip: int = 20):
        """
        åˆå§‹åŒ–åŠ¨é‡å› å­

        Args:
            lookback: å›çœ‹å¤©æ•°ï¼Œé»˜è®¤252
            skip: è·³è¿‡æœ€è¿‘å‡ å¤©ï¼Œé»˜è®¤20
        """
        self.lookback = lookback
        self.skip = skip

    def calculate(self, price_data: pd.DataFrame) -> pd.DataFrame:
        """
        è®¡ç®—åŠ¨é‡å› å­

        Args:
            price_data: ä»·æ ¼æ•°æ®ï¼Œindexä¸ºæ—¥æœŸï¼Œcolumnsä¸ºè‚¡ç¥¨ä»£ç 

        Returns:
            åŠ¨é‡å› å­å€¼

        Raises:
            ValueError: å¦‚æœæ•°æ®é•¿åº¦ä¸è¶³
        """
        if len(price_data) < self.lookback:
            raise ValueError(f"æ•°æ®é•¿åº¦{len(price_data)}å°äºå›çœ‹æœŸ{self.lookback}")

        # è®¡ç®—åŠ¨é‡
        momentum = price_data / price_data.shift(self.lookback) - 1

        # è·³è¿‡æœ€è¿‘å‡ å¤©
        if self.skip > 0:
            momentum = momentum.shift(self.skip)

        return momentum

    def __repr__(self) -> str:
        return f"MomentumFactor(lookback={self.lookback}, skip={self.skip})"


# å·®çš„ç¤ºä¾‹
def calc_mom(p, l=252, s=20):  # å‡½æ•°åã€å‚æ•°åä¸æ¸…æ™°
    m = p / p.shift(l) - 1  # å˜é‡åä¸æ¸…æ™°
    return m.shift(s)  # ç¼ºå°‘æ–‡æ¡£å­—ç¬¦ä¸²ã€ç±»å‹æç¤ºã€å¼‚å¸¸å¤„ç†
```

**3. é…ç½®ç®¡ç†**

```python
# config/strategy_config.py
from dataclasses import dataclass
from typing import List

@dataclass
class StrategyConfig:
    """ç­–ç•¥é…ç½®ç±»"""

    # åŸºæœ¬ä¿¡æ¯
    strategy_name: str = "AdaptiveMomentumStrategy"
    version: str = "1.0.0"

    # å› å­å‚æ•°
    momentum_lookback: int = 252
    momentum_skip: int = 20
    stress_window: int = 20

    # é€‰è‚¡å‚æ•°
    universe: str = 'hs300'
    n_stocks: int = 30
    min_listing_days: int = 252
    min_avg_amount: float = 10_000_000

    # ä»“ä½å‚æ•°
    position_low_stress: float = 1.0
    position_med_stress: float = 0.6
    position_high_stress: float = 0.3
    stress_threshold_low: float = 0.15
    stress_threshold_high: float = 0.25

    # é£æ§å‚æ•°
    max_single_position: float = 0.05
    stop_loss_threshold: float = -0.15
    max_drawdown_alert: float = -0.15
    max_drawdown_reduce: float = -0.20

    # äº¤æ˜“æˆæœ¬
    commission: float = 0.00025
    tax: float = 0.001
    slippage: float = 0.0005

    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            k: v for k, v in self.__dict__.items()
            if not k.startswith('_')
        }

    @classmethod
    def from_dict(cls, config_dict: dict) -> 'StrategyConfig':
        """ä»å­—å…¸åŠ è½½"""
        return cls(**config_dict)

    def save(self, filepath: str):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        import json
        with open(filepath, 'w') as f:
            json.dump(self.to_dict(), f, indent=4)

    @classmethod
    def load(cls, filepath: str) -> 'StrategyConfig':
        """ä»æ–‡ä»¶åŠ è½½é…ç½®"""
        import json
        with open(filepath, 'r') as f:
            config_dict = json.load(f)
        return cls.from_dict(config_dict)

# ä½¿ç”¨
config = StrategyConfig()
config.save('config/my_strategy.json')

loaded_config = StrategyConfig.load('config/my_strategy.json')
```

**4. æ—¥å¿—è§„èŒƒ**

```python
# utils/logger.py
import logging
import sys
from pathlib import Path
from datetime import datetime

def setup_logger(
    name: str,
    log_dir: str = 'logs',
    level: int = logging.INFO
) -> logging.Logger:
    """
    è®¾ç½®æ—¥å¿—å™¨

    Args:
        name: æ—¥å¿—å™¨åç§°
        log_dir: æ—¥å¿—ç›®å½•
        level: æ—¥å¿—çº§åˆ«

    Returns:
        é…ç½®å¥½çš„æ—¥å¿—å™¨
    """
    # åˆ›å»ºæ—¥å¿—ç›®å½•
    log_path = Path(log_dir)
    log_path.mkdir(parents=True, exist_ok=True)

    # åˆ›å»ºæ—¥å¿—å™¨
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # é¿å…é‡å¤æ·»åŠ handler
    if logger.handlers:
        return logger

    # æ–‡ä»¶handler
    log_file = log_path / f"{name}_{datetime.now().strftime('%Y%m%d')}.log"
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(level)

    # æ§åˆ¶å°handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)

    # æ ¼å¼åŒ–
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    # æ·»åŠ handler
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger

# ä½¿ç”¨
logger = setup_logger('AdaptiveMomentumStrategy')

logger.info("ç­–ç•¥åˆå§‹åŒ–å®Œæˆ")
logger.warning("å¸‚åœºå‹åŠ›è¿‡é«˜ï¼Œé™ä½ä»“ä½")
logger.error("æ•°æ®åŠ è½½å¤±è´¥", exc_info=True)
```

### â— 17.2.2 ç‰ˆæœ¬æ§åˆ¶ï¼ˆGitï¼‰

**1. Gitå·¥ä½œæµ**

```bash
# é¡¹ç›®åˆå§‹åŒ–
git init
git add .
git commit -m "Initial commit"

# åˆ›å»ºå¼€å‘åˆ†æ”¯
git checkout -b develop

# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/add-momentum-factor

# ... å¼€å‘åŠŸèƒ½ ...

# æäº¤æ›´æ”¹
git add factors/momentum.py tests/test_momentum.py
git commit -m "feat: æ·»åŠ åŠ¨é‡å› å­è®¡ç®—åŠŸèƒ½

- å®ç°åŸºäºè¿‡å»Nå¤©æ”¶ç›Šç‡çš„åŠ¨é‡è®¡ç®—
- æ”¯æŒè·³è¿‡æœ€è¿‘Må¤©
- æ·»åŠ å•å…ƒæµ‹è¯•
- æ›´æ–°æ–‡æ¡£"

# åˆå¹¶åˆ°develop
git checkout develop
git merge feature/add-momentum-factor

# å‘å¸ƒç‰ˆæœ¬
git checkout main
git merge develop
git tag -a v1.0.0 -m "Release version 1.0.0"
```

**2. .gitignoreé…ç½®**

```
# .gitignore

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Jupyter Notebook
.ipynb_checkpoints

# æ•°æ®æ–‡ä»¶
*.csv
*.h5
*.hdf5
*.db
data/raw/
data/processed/

# æ—¥å¿—æ–‡ä»¶
logs/*.log

# é…ç½®æ–‡ä»¶ï¼ˆåŒ…å«æ•æ„Ÿä¿¡æ¯ï¼‰
config/secrets.json
config/api_keys.json

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# å›æµ‹ç»“æœï¼ˆå¯é€‰ï¼‰
results/
backtest_output/
```

**3. æäº¤ä¿¡æ¯è§„èŒƒ**

éµå¾ª Conventional Commits è§„èŒƒï¼š

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Typeç±»å‹**ï¼š
- `feat`: æ–°åŠŸèƒ½
- `fix`: ä¿®å¤bug
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼è°ƒæ•´ï¼ˆä¸å½±å“ä»£ç åŠŸèƒ½ï¼‰
- `refactor`: é‡æ„
- `perf`: æ€§èƒ½ä¼˜åŒ–
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»º/å·¥å…·ç›¸å…³

**ç¤ºä¾‹**ï¼š

```
feat(factors): æ·»åŠ ä»·å€¼å› å­è®¡ç®—

- å®ç°PBã€PEã€PSå› å­
- æ”¯æŒè¡Œä¸šä¸­æ€§åŒ–
- æ·»åŠ å¼‚å¸¸å€¼å¤„ç†
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡100%

Closes #123
```

### â— 17.2.3 æ–‡æ¡£ç¼–å†™

**1. README.md**

```markdown
# Adaptive Momentum Strategy

åŸºäºåŠ¨é‡æ•ˆåº”å’Œå¸‚åœºå‹åŠ›çš„è‡ªé€‚åº”é‡åŒ–ç­–ç•¥

## ğŸ“‹ ç›®å½•

- [ç­–ç•¥ç®€ä»‹](#ç­–ç•¥ç®€ä»‹)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [å®‰è£…](#å®‰è£…)
- [ä½¿ç”¨æ–¹æ³•](#ä½¿ç”¨æ–¹æ³•)
- [ç­–ç•¥é€»è¾‘](#ç­–ç•¥é€»è¾‘)
- [å›æµ‹ç»“æœ](#å›æµ‹ç»“æœ)
- [é…ç½®è¯´æ˜](#é…ç½®è¯´æ˜)
- [å¼€å‘æŒ‡å—](#å¼€å‘æŒ‡å—)
- [è®¸å¯è¯](#è®¸å¯è¯)

## ç­–ç•¥ç®€ä»‹

æœ¬ç­–ç•¥ç»“åˆäº†ç»å…¸çš„åŠ¨é‡å› å­å’Œå¸‚åœºå‹åŠ›æŒ‡æ ‡ï¼Œé€šè¿‡åŠ¨æ€è°ƒæ•´ä»“ä½æ¥æ§åˆ¶å›æ’¤ã€‚

**æ ¸å¿ƒç‰¹ç‚¹**ï¼š
- âœ… åˆ©ç”¨åŠ¨é‡æ•ˆåº”é€‰è‚¡
- âœ… æ ¹æ®å¸‚åœºç¯å¢ƒåŠ¨æ€è°ƒæ•´ä»“ä½
- âœ… å®Œå–„çš„é£æ§æœºåˆ¶
- âœ… å†å²å›æµ‹å¹´åŒ–æ”¶ç›Š25%ï¼Œå¤æ™®æ¯”ç‡1.8

## å¿«é€Ÿå¼€å§‹

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/yourusername/adaptive-momentum-strategy.git
cd adaptive-momentum-strategy

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# è¿è¡Œå›æµ‹
python scripts/run_backtest.py --start-date 2019-01-01 --end-date 2023-12-31
```

## å®‰è£…

### ä¾èµ–è¦æ±‚

- Python >= 3.8
- pandas >= 1.3.0
- numpy >= 1.21.0
- tushare >= 1.2.0

### å®‰è£…æ­¥éª¤

```bash
# 1. åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
conda create -n quant python=3.9
conda activate quant

# 2. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 3. é…ç½®Tushare token
echo "TUSHARE_TOKEN=your_token_here" > .env
```

## ä½¿ç”¨æ–¹æ³•

### å›æµ‹

```python
from strategies.adaptive_momentum import AdaptiveMomentumStrategy
from backtest.engine import Backtester
from config.strategy_config import StrategyConfig

# åŠ è½½é…ç½®
config = StrategyConfig()

# åˆå§‹åŒ–ç­–ç•¥
strategy = AdaptiveMomentumStrategy(config)

# è¿è¡Œå›æµ‹
backtester = Backtester(strategy, data, config)
results = backtester.run(start_date='2019-01-01', end_date='2023-12-31')

# åˆ†æç»“æœ
backtester.plot_results()
```

### å®ç›˜

```python
from trade.live_trading import LiveTradingSystem

# åˆå§‹åŒ–å®ç›˜ç³»ç»Ÿ
live_system = LiveTradingSystem(strategy, trader, risk_manager, monitor)

# å¯åŠ¨
live_system.start()
```

## ç­–ç•¥é€»è¾‘

è¯¦è§ [ç­–ç•¥æ–‡æ¡£](docs/strategy_design.md)

## å›æµ‹ç»“æœ

| æŒ‡æ ‡ | å€¼ |
|------|--------|
| å¹´åŒ–æ”¶ç›Šç‡ | 25.3% |
| å¤æ™®æ¯”ç‡ | 1.82 |
| æœ€å¤§å›æ’¤ | -18.5% |
| èƒœç‡ | 58.7% |

è¯¦ç»†å›æµ‹æŠ¥å‘Šï¼š[backtest_report.pdf](docs/backtest_report.pdf)

## é…ç½®è¯´æ˜

é…ç½®æ–‡ä»¶ä½äº `config/strategy_config.py`ï¼Œä¸»è¦å‚æ•°ï¼š

```python
momentum_lookback = 252    # åŠ¨é‡å›çœ‹æœŸ
n_stocks = 30             # é€‰è‚¡æ•°é‡
max_single_position = 0.05  # å•ç¥¨æœ€å¤§ä»“ä½5%
```

## å¼€å‘æŒ‡å—

### æ·»åŠ æ–°å› å­

1. åœ¨ `factors/` ç›®å½•ä¸‹åˆ›å»ºæ–°æ–‡ä»¶
2. ç»§æ‰¿ `BaseFactor` ç±»
3. å®ç° `calculate()` æ–¹æ³•
4. æ·»åŠ å•å…ƒæµ‹è¯•

ç¤ºä¾‹ï¼š

```python
from factors.base import BaseFactor

class MyFactor(BaseFactor):
    def calculate(self, data):
        # å®ç°å› å­è®¡ç®—é€»è¾‘
        pass
```

### è¿è¡Œæµ‹è¯•

```bash
pytest tests/ -v --cov=./
```

## è®¸å¯è¯

MIT License
```

**2. APIæ–‡æ¡£**

ä½¿ç”¨Sphinxæˆ–ç±»ä¼¼å·¥å…·ç”ŸæˆAPIæ–‡æ¡£ï¼š

```python
def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.03) -> float:
    """
    è®¡ç®—å¤æ™®æ¯”ç‡

    å¤æ™®æ¯”ç‡è¡¡é‡çš„æ˜¯æ¯æ‰¿æ‹…ä¸€å•ä½é£é™©æ‰€è·å¾—çš„è¶…é¢æ”¶ç›Šã€‚

    Args:
        returns: æ”¶ç›Šç‡åºåˆ—ï¼ˆæ—¥é¢‘æˆ–å…¶ä»–é¢‘ç‡ï¼‰
        risk_free_rate: æ— é£é™©åˆ©ç‡ï¼ˆå¹´åŒ–ï¼‰ï¼Œé»˜è®¤0.03

    Returns:
        å¹´åŒ–å¤æ™®æ¯”ç‡

    Raises:
        ValueError: å¦‚æœæ”¶ç›Šç‡åºåˆ—ä¸ºç©ºæˆ–å…¨ä¸ºNaN

    Examples:
        >>> returns = pd.Series([0.01, -0.02, 0.03, 0.01])
        >>> sharpe = calculate_sharpe_ratio(returns, risk_free_rate=0.03)
        >>> print(f"Sharpe Ratio: {sharpe:.2f}")
        Sharpe Ratio: 1.25

    Notes:
        - å‡è®¾æ”¶ç›Šç‡å·²ç»æ˜¯å¯¹æ•°æ”¶ç›Šç‡æˆ–ç®€å•æ”¶ç›Šç‡
        - è‡ªåŠ¨è¯†åˆ«æ•°æ®é¢‘ç‡ï¼ˆæ—¥/å‘¨/æœˆï¼‰å¹¶è¿›è¡Œå¹´åŒ–
        - ä½¿ç”¨è´å¡å°”æ ¡æ­£çš„æ ‡å‡†å·®ï¼ˆddof=1ï¼‰

    References:
        Sharpe, W. F. (1994). The Sharpe Ratio. Journal of Portfolio Management.
    """
    if returns.empty or returns.isna().all():
        raise ValueError("æ”¶ç›Šç‡åºåˆ—ä¸èƒ½ä¸ºç©º")

    # è®¡ç®—è¶…é¢æ”¶ç›Š
    excess_return = returns.mean() - risk_free_rate / 252

    # è®¡ç®—æ³¢åŠ¨ç‡
    volatility = returns.std()

    # å¹´åŒ–å¤æ™®æ¯”ç‡
    sharpe = excess_return / volatility * np.sqrt(252)

    return sharpe
```

### â— 17.2.4 å•å…ƒæµ‹è¯•

**1. æµ‹è¯•æ¡†æ¶ï¼špytest**

```python
# tests/test_factors.py
import pytest
import pandas as pd
import numpy as np
from factors.momentum import MomentumFactor

class TestMomentumFactor:
    """åŠ¨é‡å› å­æµ‹è¯•ç±»"""

    @pytest.fixture
    def sample_data(self):
        """å‡†å¤‡æµ‹è¯•æ•°æ®"""
        dates = pd.date_range('2020-01-01', periods=300, freq='D')
        stocks = ['000001.SZ', '000002.SZ', '600000.SH']

        # ç”Ÿæˆæ¨¡æ‹Ÿä»·æ ¼æ•°æ®
        np.random.seed(42)
        data = pd.DataFrame(
            np.random.randn(300, 3).cumsum(axis=0) + 100,
            index=dates,
            columns=stocks
        )
        return data

    def test_momentum_calculation(self, sample_data):
        """æµ‹è¯•åŠ¨é‡è®¡ç®—æ˜¯å¦æ­£ç¡®"""
        factor = MomentumFactor(lookback=120, skip=20)
        momentum = factor.calculate(sample_data)

        # æ£€æŸ¥ç»“æœå½¢çŠ¶
        assert momentum.shape == sample_data.shape

        # æ£€æŸ¥å‰120+20å¤©åº”è¯¥æ˜¯NaN
        assert momentum.iloc[:140].isna().all().all()

        # æ£€æŸ¥è®¡ç®—é€»è¾‘
        expected = sample_data.iloc[120] / sample_data.iloc[0] - 1
        actual = momentum.iloc[140, :]
        pd.testing.assert_series_equal(actual, expected, check_names=False)

    def test_momentum_with_short_data(self):
        """æµ‹è¯•æ•°æ®ä¸è¶³æ—¶æ˜¯å¦æŠ›å‡ºå¼‚å¸¸"""
        short_data = pd.DataFrame({
            'stock1': [100, 101, 102]
        })

        factor = MomentumFactor(lookback=252)

        with pytest.raises(ValueError, match="æ•°æ®é•¿åº¦.*å°äºå›çœ‹æœŸ"):
            factor.calculate(short_data)

    def test_momentum_with_nan(self, sample_data):
        """æµ‹è¯•åŒ…å«NaNçš„æ•°æ®"""
        data_with_nan = sample_data.copy()
        data_with_nan.iloc[10:20, 0] = np.nan

        factor = MomentumFactor(lookback=120, skip=20)
        momentum = factor.calculate(data_with_nan)

        # NaNåº”è¯¥è¢«ä¼ æ’­
        assert momentum.iloc[140, 0] is np.nan

    def test_momentum_zero_skip(self, sample_data):
        """æµ‹è¯•skip=0çš„æƒ…å†µ"""
        factor = MomentumFactor(lookback=120, skip=0)
        momentum = factor.calculate(sample_data)

        # å‰120å¤©åº”è¯¥æ˜¯NaN
        assert momentum.iloc[:120].isna().all().all()

        # ç¬¬120å¤©å¼€å§‹åº”è¯¥æœ‰å€¼
        assert not momentum.iloc[120:].isna().all().all()

    @pytest.mark.parametrize("lookback,skip", [
        (120, 20),
        (252, 20),
        (60, 5),
    ])
    def test_momentum_different_parameters(self, sample_data, lookback, skip):
        """æµ‹è¯•ä¸åŒå‚æ•°ç»„åˆ"""
        factor = MomentumFactor(lookback=lookback, skip=skip)
        momentum = factor.calculate(sample_data)

        # åŸºæœ¬æ£€æŸ¥
        assert momentum.shape == sample_data.shape
        assert momentum.iloc[:lookback+skip].isna().all().all()

# è¿è¡Œæµ‹è¯•
# pytest tests/test_factors.py -v
```

**2. æµ‹è¯•è¦†ç›–ç‡**

```bash
# å®‰è£…coverage
pip install pytest-cov

# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pytest tests/ --cov=./ --cov-report=html --cov-report=term

# æŸ¥çœ‹HTMLæŠ¥å‘Š
open htmlcov/index.html
```

**3. æŒç»­é›†æˆï¼ˆCIï¼‰**

ä½¿ç”¨GitHub Actionsï¼š

```yaml
# .github/workflows/tests.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.8, 3.9, '3.10']

    steps:
    - uses: actions/checkout@v2

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        pytest tests/ --cov=./ --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
```

---

## 17.3 ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†

ä¸€ä¸ªç­–ç•¥ä»ä¸Šçº¿åˆ°é€€å½¹ï¼Œä¼šç»å†å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸã€‚ä¸“ä¸šçš„é‡åŒ–å›¢é˜Ÿä¼šå¯¹ç­–ç•¥è¿›è¡Œå…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

### â— 17.3.1 ç­–ç•¥ä¸Šçº¿æ ‡å‡†

**ä¸Šçº¿å‰æ£€æŸ¥è¡¨**ï¼š

```python
# ç­–ç•¥ä¸Šçº¿è¯„ä¼°ç³»ç»Ÿ
class StrategyLaunchEvaluator:
    """ç­–ç•¥ä¸Šçº¿è¯„ä¼°å™¨"""

    def __init__(self):
        self.checks = {
            'å›æµ‹æ€§èƒ½': self.check_backtest_performance,
            'æ ·æœ¬å¤–éªŒè¯': self.check_out_of_sample,
            'ç¨³å¥æ€§æµ‹è¯•': self.check_robustness,
            'é£é™©æŒ‡æ ‡': self.check_risk_metrics,
            'äº¤æ˜“æˆæœ¬': self.check_transaction_costs,
            'ä»£ç è´¨é‡': self.check_code_quality,
            'æ–‡æ¡£å®Œæ•´æ€§': self.check_documentation,
            'é£æ§æœºåˆ¶': self.check_risk_controls,
        }
        self.results = {}

    def evaluate(self, strategy) -> bool:
        """
        è¯„ä¼°ç­–ç•¥æ˜¯å¦å¯ä»¥ä¸Šçº¿

        Returns:
            True if all checks pass, False otherwise
        """
        print("=" * 70)
        print(" " * 20 + "ç­–ç•¥ä¸Šçº¿è¯„ä¼°")
        print("=" * 70)

        all_passed = True

        for check_name, check_func in self.checks.items():
            print(f"\næ£€æŸ¥ [{check_name}]...")
            passed, message = check_func(strategy)
            self.results[check_name] = {'passed': passed, 'message': message}

            status = "âœ… é€šè¿‡" if passed else "âŒ å¤±è´¥"
            print(f"  {status}: {message}")

            if not passed:
                all_passed = False

        print("\n" + "=" * 70)
        if all_passed:
            print("ğŸ‰ æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œç­–ç•¥å¯ä»¥ä¸Šçº¿ï¼")
        else:
            print("âš ï¸  éƒ¨åˆ†æ£€æŸ¥æœªé€šè¿‡ï¼Œè¯·ä¿®å¤åå†ä¸Šçº¿ã€‚")
        print("=" * 70)

        return all_passed

    def check_backtest_performance(self, strategy) -> tuple:
        """æ£€æŸ¥å›æµ‹æ€§èƒ½"""
        stats = strategy.backtest_stats

        # æ£€æŸ¥æ ‡å‡†
        criteria = {
            'å¹´åŒ–æ”¶ç›Šç‡': (stats.get('annual_return', 0), 0.10, '>'),
            'å¤æ™®æ¯”ç‡': (stats.get('sharpe_ratio', 0), 1.0, '>'),
            'æœ€å¤§å›æ’¤': (abs(stats.get('max_drawdown', 0)), 0.30, '<'),
            'èƒœç‡': (stats.get('win_rate', 0), 0.50, '>'),
        }

        failed = []
        for metric, (value, threshold, op) in criteria.items():
            if op == '>' and value <= threshold:
                failed.append(f"{metric}={value:.2%} <= {threshold:.2%}")
            elif op == '<' and value >= threshold:
                failed.append(f"{metric}={value:.2%} >= {threshold:.2%}")

        if failed:
            return False, "æœªè¾¾æ ‡: " + "; ".join(failed)
        return True, "æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡"

    def check_out_of_sample(self, strategy) -> tuple:
        """æ£€æŸ¥æ ·æœ¬å¤–è¡¨ç°"""
        in_sample_sharpe = strategy.in_sample_stats.get('sharpe_ratio', 0)
        out_of_sample_sharpe = strategy.out_of_sample_stats.get('sharpe_ratio', 0)

        # æ ·æœ¬å¤–å¤æ™®åº”è¯¥ >= æ ·æœ¬å†…çš„70%
        if out_of_sample_sharpe < in_sample_sharpe * 0.7:
            return False, f"æ ·æœ¬å¤–å¤æ™®{out_of_sample_sharpe:.2f} < æ ·æœ¬å†…{in_sample_sharpe:.2f} * 70%"

        return True, f"æ ·æœ¬å¤–è¡¨ç°è‰¯å¥½ï¼ˆå¤æ™®={out_of_sample_sharpe:.2f}ï¼‰"

    def check_robustness(self, strategy) -> tuple:
        """æ£€æŸ¥ç¨³å¥æ€§"""
        # æ£€æŸ¥å‚æ•°æ•æ„Ÿæ€§
        param_sensitivity = strategy.param_sensitivity_analysis

        # æœ€ä¼˜å‚æ•°å‘¨å›´çš„å‚æ•°ç»„åˆï¼Œå¹³å‡å¤æ™®åº”è¯¥ > 0.8
        if param_sensitivity['nearby_avg_sharpe'] < 0.8:
            return False, "å‚æ•°è¿‡äºæ•æ„Ÿï¼Œå¯èƒ½è¿‡æ‹Ÿåˆ"

        return True, "å‚æ•°ç¨³å¥æ€§è‰¯å¥½"

    def check_risk_metrics(self, strategy) -> tuple:
        """æ£€æŸ¥é£é™©æŒ‡æ ‡"""
        stats = strategy.backtest_stats

        # è¿ç»­äºæŸæœˆæ•°ä¸è¶…è¿‡6ä¸ªæœˆ
        max_losing_months = stats.get('max_consecutive_losing_months', 0)
        if max_losing_months > 6:
            return False, f"æœ€é•¿è¿ç»­äºæŸ{max_losing_months}ä¸ªæœˆ"

        # å¡ç›æ¯”ç‡ > 0.5
        calmar = stats.get('calmar_ratio', 0)
        if calmar < 0.5:
            return False, f"å¡ç›æ¯”ç‡{calmar:.2f} < 0.5"

        return True, "é£é™©æŒ‡æ ‡åˆæ ¼"

    def check_transaction_costs(self, strategy) -> tuple:
        """æ£€æŸ¥äº¤æ˜“æˆæœ¬"""
        stats = strategy.backtest_stats

        # å¹´åŒ–æ¢æ‰‹ç‡ä¸è¶…è¿‡1000%ï¼ˆå³æ¯å¤©æ¢æ‰‹ ~4%ï¼‰
        annual_turnover = stats.get('annual_turnover', 0)
        if annual_turnover > 10.0:
            return False, f"å¹´åŒ–æ¢æ‰‹ç‡{annual_turnover:.1f}å€è¿‡é«˜"

        # äº¤æ˜“æˆæœ¬å æ”¶ç›Šçš„æ¯”ä¾‹ä¸è¶…è¿‡30%
        total_return = stats.get('total_return', 0)
        total_costs = stats.get('total_transaction_costs', 0)
        if total_costs / (total_return + 1e-6) > 0.3:
            return False, "äº¤æ˜“æˆæœ¬å æ¯”è¿‡é«˜"

        return True, f"äº¤æ˜“æˆæœ¬åˆç†ï¼ˆå¹´åŒ–æ¢æ‰‹{annual_turnover:.1f}å€ï¼‰"

    def check_code_quality(self, strategy) -> tuple:
        """æ£€æŸ¥ä»£ç è´¨é‡"""
        # è¿™é‡Œç®€åŒ–ï¼Œå®é™…åº”è¯¥æ£€æŸ¥ï¼š
        # - å•å…ƒæµ‹è¯•è¦†ç›–ç‡
        # - ä»£ç å¤æ‚åº¦
        # - æ˜¯å¦æœ‰ä»£ç å®¡æŸ¥
        # - æ˜¯å¦é€šè¿‡é™æ€ä»£ç åˆ†æ

        if not hasattr(strategy, 'test_coverage'):
            return False, "ç¼ºå°‘æµ‹è¯•è¦†ç›–ç‡ä¿¡æ¯"

        if strategy.test_coverage < 0.80:
            return False, f"æµ‹è¯•è¦†ç›–ç‡{strategy.test_coverage:.0%} < 80%"

        return True, f"ä»£ç è´¨é‡è‰¯å¥½ï¼ˆæµ‹è¯•è¦†ç›–ç‡{strategy.test_coverage:.0%}ï¼‰"

    def check_documentation(self, strategy) -> tuple:
        """æ£€æŸ¥æ–‡æ¡£å®Œæ•´æ€§"""
        required_docs = [
            'strategy_design',
            'backtest_report',
            'risk_assessment',
            'api_documentation'
        ]

        missing = [doc for doc in required_docs if not hasattr(strategy, f'doc_{doc}')]

        if missing:
            return False, f"ç¼ºå°‘æ–‡æ¡£: {', '.join(missing)}"

        return True, "æ–‡æ¡£å®Œæ•´"

    def check_risk_controls(self, strategy) -> tuple:
        """æ£€æŸ¥é£æ§æœºåˆ¶"""
        required_controls = [
            'stop_loss',
            'position_limit',
            'drawdown_control',
            'emergency_stop'
        ]

        missing = [ctrl for ctrl in required_controls
                  if not hasattr(strategy.risk_manager, ctrl)]

        if missing:
            return False, f"ç¼ºå°‘é£æ§æœºåˆ¶: {', '.join(missing)}"

        return True, "é£æ§æœºåˆ¶å®Œå–„"

    def generate_report(self, filepath: str):
        """ç”Ÿæˆè¯„ä¼°æŠ¥å‘Š"""
        import json
        with open(filepath, 'w') as f:
            json.dump(self.results, f, indent=4)
        print(f"\nè¯„ä¼°æŠ¥å‘Šå·²ä¿å­˜è‡³: {filepath}")

# ä½¿ç”¨
evaluator = StrategyLaunchEvaluator()
can_launch = evaluator.evaluate(my_strategy)

if can_launch:
    evaluator.generate_report('reports/launch_evaluation.json')
    # å¯ä»¥ä¸Šçº¿
else:
    # ä¿®å¤é—®é¢˜åé‡æ–°è¯„ä¼°
    pass
```

### â— 17.3.2 è¿è¡Œç›‘æ§

ç­–ç•¥ä¸Šçº¿åï¼Œéœ€è¦æŒç»­ç›‘æ§å…¶è¿è¡ŒçŠ¶æ€ã€‚

```python
# å®æ—¶ç›‘æ§ç³»ç»Ÿ
class StrategyMonitor:
    """ç­–ç•¥ç›‘æ§ç³»ç»Ÿ"""

    def __init__(self, strategy, alert_config):
        self.strategy = strategy
        self.alert_config = alert_config
        self.metrics_history = []
        self.alerts = []

    def monitor_realtime(self):
        """å®æ—¶ç›‘æ§"""
        while True:
            try:
                # è·å–å½“å‰æŒ‡æ ‡
                metrics = self.collect_metrics()

                # è®°å½•å†å²
                self.metrics_history.append(metrics)

                # æ£€æŸ¥å¼‚å¸¸
                self.check_alerts(metrics)

                # æ›´æ–°ç›‘æ§é¢æ¿
                self.update_dashboard(metrics)

                # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
                time.sleep(60)

            except Exception as e:
                self.send_alert(f"ç›‘æ§ç³»ç»Ÿé”™è¯¯: {e}", level='ERROR')

    def collect_metrics(self) -> dict:
        """æ”¶é›†å½“å‰æŒ‡æ ‡"""
        return {
            'timestamp': datetime.now(),
            'total_value': self.strategy.get_total_value(),
            'cash': self.strategy.get_cash(),
            'position_value': self.strategy.get_position_value(),
            'daily_return': self.strategy.get_daily_return(),
            'current_drawdown': self.strategy.get_current_drawdown(),
            'position_count': len(self.strategy.positions),
            'leverage': self.strategy.get_leverage(),
        }

    def check_alerts(self, metrics: dict):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        # æ£€æŸ¥å›æ’¤
        if metrics['current_drawdown'] < self.alert_config['max_drawdown_warning']:
            self.send_alert(
                f"âš ï¸ å›æ’¤é¢„è­¦: å½“å‰å›æ’¤{metrics['current_drawdown']:.2%}",
                level='WARNING'
            )

        if metrics['current_drawdown'] < self.alert_config['max_drawdown_critical']:
            self.send_alert(
                f"ğŸš¨ å›æ’¤ä¸¥é‡: å½“å‰å›æ’¤{metrics['current_drawdown']:.2%}ï¼Œå»ºè®®å‡ä»“",
                level='CRITICAL'
            )

        # æ£€æŸ¥æ æ†
        if metrics['leverage'] > self.alert_config['max_leverage']:
            self.send_alert(
                f"âš ï¸ æ æ†è¶…æ ‡: å½“å‰æ æ†{metrics['leverage']:.2f}",
                level='WARNING'
            )

        # æ£€æŸ¥æŒä»“æ•°é‡
        if metrics['position_count'] > self.alert_config['max_positions']:
            self.send_alert(
                f"âš ï¸ æŒä»“è¿‡å¤š: å½“å‰{metrics['position_count']}åª",
                level='WARNING'
            )

        # æ£€æŸ¥å•æ—¥äºæŸ
        if metrics['daily_return'] < -0.05:  # å•æ—¥äºæŸ>5%
            self.send_alert(
                f"âš ï¸ å•æ—¥å¤§å¹…äºæŸ: {metrics['daily_return']:.2%}",
                level='WARNING'
            )

    def send_alert(self, message: str, level: str = 'INFO'):
        """å‘é€å‘Šè­¦"""
        alert = {
            'timestamp': datetime.now(),
            'level': level,
            'message': message
        }
        self.alerts.append(alert)

        # è®°å½•æ—¥å¿—
        logger = logging.getLogger('StrategyMonitor')
        if level == 'INFO':
            logger.info(message)
        elif level == 'WARNING':
            logger.warning(message)
        elif level == 'ERROR' or level == 'CRITICAL':
            logger.error(message)

        # å‘é€é’‰é’‰/ä¼ä¸šå¾®ä¿¡é€šçŸ¥
        if level in ['WARNING', 'ERROR', 'CRITICAL']:
            self.send_dingtalk(message)
            self.send_email(message)

    def send_dingtalk(self, message: str):
        """å‘é€é’‰é’‰é€šçŸ¥"""
        # å®ç°é’‰é’‰æœºå™¨äººé€šçŸ¥
        pass

    def send_email(self, message: str):
        """å‘é€é‚®ä»¶é€šçŸ¥"""
        # å®ç°é‚®ä»¶é€šçŸ¥
        pass

    def update_dashboard(self, metrics: dict):
        """æ›´æ–°ç›‘æ§é¢æ¿ï¼ˆä½¿ç”¨Grafanaæˆ–è‡ªå»ºï¼‰"""
        # å°†æŒ‡æ ‡æ¨é€åˆ°æ—¶åºæ•°æ®åº“ï¼ˆå¦‚InfluxDBï¼‰
        # åœ¨Grafanaä¸­å¯è§†åŒ–
        pass

    def generate_daily_report(self):
        """ç”Ÿæˆæ¯æ—¥æŠ¥å‘Š"""
        today_metrics = [m for m in self.metrics_history
                        if m['timestamp'].date() == datetime.now().date()]

        report = f"""
        ========== ç­–ç•¥æ¯æ—¥æŠ¥å‘Š ==========
        æ—¥æœŸ: {datetime.now().date()}

        ğŸ“Š æ”¶ç›Šæƒ…å†µ:
        - å½“æ—¥æ”¶ç›Šç‡: {today_metrics[-1]['daily_return']:.2%}
        - å½“å‰æ€»èµ„äº§: Â¥{today_metrics[-1]['total_value']:,.2f}
        - å½“å‰æŒä»“å¸‚å€¼: Â¥{today_metrics[-1]['position_value']:,.2f}
        - å½“å‰ç°é‡‘: Â¥{today_metrics[-1]['cash']:,.2f}

        ğŸ“‰ é£é™©æƒ…å†µ:
        - å½“å‰å›æ’¤: {today_metrics[-1]['current_drawdown']:.2%}
        - å½“å‰æ æ†: {today_metrics[-1]['leverage']:.2f}
        - æŒä»“æ•°é‡: {today_metrics[-1]['position_count']}

        âš ï¸  ä»Šæ—¥å‘Šè­¦:
        """

        today_alerts = [a for a in self.alerts
                       if a['timestamp'].date() == datetime.now().date()]

        if today_alerts:
            for alert in today_alerts:
                report += f"\n- [{alert['level']}] {alert['message']}"
        else:
            report += "\næ— å‘Šè­¦"

        report += "\n" + "=" * 40

        # å‘é€æŠ¥å‘Š
        self.send_email(report)

        return report
```

### â— 17.3.3 æ€§èƒ½è¯„ä¼°

å®šæœŸè¯„ä¼°ç­–ç•¥çš„å®ç›˜è¡¨ç°ï¼Œä¸å›æµ‹ç»“æœå¯¹æ¯”ã€‚

```python
def evaluate_live_performance(
    live_returns: pd.Series,
    backtest_returns: pd.Series,
    period: str = 'æœˆåº¦'
) -> dict:
    """
    è¯„ä¼°å®ç›˜è¡¨ç°ï¼Œä¸å›æµ‹å¯¹æ¯”

    å‚æ•°:
        live_returns: å®ç›˜æ”¶ç›Šç‡åºåˆ—
        backtest_returns: å›æµ‹æ”¶ç›Šç‡åºåˆ—ï¼ˆåŒæœŸï¼‰
        period: è¯„ä¼°å‘¨æœŸï¼ˆ'æ—¥åº¦', 'å‘¨åº¦', 'æœˆåº¦'ï¼‰
    """
    # è®¡ç®—å®ç›˜æŒ‡æ ‡
    live_stats = {
        'æ€»æ”¶ç›Šç‡': (1 + live_returns).prod() - 1,
        'å¹´åŒ–æ”¶ç›Šç‡': (1 + live_returns).prod() ** (252 / len(live_returns)) - 1,
        'æ³¢åŠ¨ç‡': live_returns.std() * np.sqrt(252),
        'å¤æ™®æ¯”ç‡': (live_returns.mean() - 0.03/252) / live_returns.std() * np.sqrt(252),
        'æœ€å¤§å›æ’¤': (live_returns.cumsum().cummax() - live_returns.cumsum()).max(),
        'èƒœç‡': (live_returns > 0).mean(),
    }

    # è®¡ç®—å›æµ‹æŒ‡æ ‡ï¼ˆåŒæœŸï¼‰
    backtest_stats = {
        'æ€»æ”¶ç›Šç‡': (1 + backtest_returns).prod() - 1,
        'å¹´åŒ–æ”¶ç›Šç‡': (1 + backtest_returns).prod() ** (252 / len(backtest_returns)) - 1,
        'æ³¢åŠ¨ç‡': backtest_returns.std() * np.sqrt(252),
        'å¤æ™®æ¯”ç‡': (backtest_returns.mean() - 0.03/252) / backtest_returns.std() * np.sqrt(252),
        'æœ€å¤§å›æ’¤': (backtest_returns.cumsum().cummax() - backtest_returns.cumsum()).max(),
        'èƒœç‡': (backtest_returns > 0).mean(),
    }

    # è®¡ç®—åå·®
    deviation = {
        key: live_stats[key] - backtest_stats[key]
        for key in live_stats.keys()
    }

    # è®¡ç®—åå·®ç™¾åˆ†æ¯”
    deviation_pct = {
        key: (live_stats[key] - backtest_stats[key]) / (abs(backtest_stats[key]) + 1e-6)
        for key in live_stats.keys()
    }

    # æ‰“å°æŠ¥å‘Š
    print("\n" + "=" * 80)
    print(" " * 30 + "å®ç›˜ vs å›æµ‹å¯¹æ¯”")
    print("=" * 80)
    print(f"{'æŒ‡æ ‡':20s} | {'å®ç›˜':>12s} | {'å›æµ‹':>12s} | {'åå·®':>12s} | {'åå·®%':>10s}")
    print("-" * 80)

    for key in live_stats.keys():
        print(f"{key:20s} | {live_stats[key]:>12.2%} | "
              f"{backtest_stats[key]:>12.2%} | {deviation[key]:>12.2%} | "
              f"{deviation_pct[key]:>10.1%}")

    print("=" * 80)

    # åˆ¤æ–­ç­–ç•¥çŠ¶æ€
    # å®ç›˜å¤æ™® >= å›æµ‹å¤æ™®çš„70% è§†ä¸ºæ­£å¸¸
    sharpe_degradation = deviation_pct['å¤æ™®æ¯”ç‡']

    if sharpe_degradation >= -0.30:
        status = "âœ… æ­£å¸¸"
        comment = "å®ç›˜è¡¨ç°ç¬¦åˆé¢„æœŸ"
    elif sharpe_degradation >= -0.50:
        status = "âš ï¸  è­¦å‘Š"
        comment = "å®ç›˜è¡¨ç°ç•¥ä½äºé¢„æœŸï¼Œéœ€è¦å…³æ³¨"
    else:
        status = "âŒ å¼‚å¸¸"
        comment = "å®ç›˜è¡¨ç°ä¸¥é‡åç¦»å›æµ‹ï¼Œå»ºè®®æš‚åœå¹¶æ’æŸ¥åŸå› "

    print(f"\nç­–ç•¥çŠ¶æ€: {status}")
    print(f"è¯„ä¼°æ„è§: {comment}")
    print("=" * 80)

    # å¯è§†åŒ–
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))

    # ç´¯è®¡æ”¶ç›Šå¯¹æ¯”
    axes[0, 0].plot((1 + live_returns).cumprod() - 1, label='å®ç›˜', linewidth=2)
    axes[0, 0].plot((1 + backtest_returns).cumprod() - 1, label='å›æµ‹', linewidth=2, alpha=0.7)
    axes[0, 0].set_title('ç´¯è®¡æ”¶ç›Šå¯¹æ¯”')
    axes[0, 0].set_ylabel('ç´¯è®¡æ”¶ç›Šç‡')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)

    # æ”¶ç›Šç‡åˆ†å¸ƒå¯¹æ¯”
    axes[0, 1].hist(live_returns, bins=50, alpha=0.5, label='å®ç›˜', density=True)
    axes[0, 1].hist(backtest_returns, bins=50, alpha=0.5, label='å›æµ‹', density=True)
    axes[0, 1].set_title('æ”¶ç›Šç‡åˆ†å¸ƒå¯¹æ¯”')
    axes[0, 1].set_xlabel('æ”¶ç›Šç‡')
    axes[0, 1].set_ylabel('é¢‘ç‡')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)

    # æ»šåŠ¨å¤æ™®æ¯”ç‡
    window = 60  # 60å¤©æ»šåŠ¨çª—å£
    live_rolling_sharpe = live_returns.rolling(window).apply(
        lambda x: x.mean() / x.std() * np.sqrt(252) if x.std() > 0 else 0
    )
    backtest_rolling_sharpe = backtest_returns.rolling(window).apply(
        lambda x: x.mean() / x.std() * np.sqrt(252) if x.std() > 0 else 0
    )

    axes[1, 0].plot(live_rolling_sharpe, label='å®ç›˜', linewidth=2)
    axes[1, 0].plot(backtest_rolling_sharpe, label='å›æµ‹', linewidth=2, alpha=0.7)
    axes[1, 0].set_title(f'{window}æ—¥æ»šåŠ¨å¤æ™®æ¯”ç‡')
    axes[1, 0].set_ylabel('å¤æ™®æ¯”ç‡')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)

    # æŒ‡æ ‡å¯¹æ¯”é›·è¾¾å›¾
    from math import pi

    categories = list(live_stats.keys())
    N = len(categories)

    angles = [n / float(N) * 2 * pi for n in range(N)]
    angles += angles[:1]

    # å½’ä¸€åŒ–åˆ°0-1
    live_values = [live_stats[cat] for cat in categories]
    backtest_values = [backtest_stats[cat] for cat in categories]
    max_val = max(max(live_values), max(backtest_values))
    live_normalized = [v / max_val for v in live_values]
    backtest_normalized = [v / max_val for v in backtest_values]
    live_normalized += live_normalized[:1]
    backtest_normalized += backtest_normalized[:1]

    ax = plt.subplot(2, 2, 4, projection='polar')
    ax.plot(angles, live_normalized, 'o-', linewidth=2, label='å®ç›˜')
    ax.fill(angles, live_normalized, alpha=0.25)
    ax.plot(angles, backtest_normalized, 'o-', linewidth=2, label='å›æµ‹')
    ax.fill(angles, backtest_normalized, alpha=0.25)
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(categories)
    ax.set_title('æŒ‡æ ‡å¯¹æ¯”é›·è¾¾å›¾')
    ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0))

    plt.tight_layout()
    plt.savefig('live_vs_backtest.png', dpi=300, bbox_inches='tight')
    plt.show()

    return {
        'live_stats': live_stats,
        'backtest_stats': backtest_stats,
        'deviation': deviation,
        'deviation_pct': deviation_pct,
        'status': status,
        'comment': comment
    }
```

### â— 17.3.4 é€€å½¹æœºåˆ¶

ç­–ç•¥ä¸æ˜¯ä¸€æˆä¸å˜çš„ï¼Œå½“ç­–ç•¥å¤±æ•ˆæ—¶ï¼Œéœ€è¦åŠæ—¶é€€å½¹ã€‚

**ç­–ç•¥é€€å½¹æ ‡å‡†**ï¼š

```python
class StrategyRetirementEvaluator:
    """ç­–ç•¥é€€å½¹è¯„ä¼°å™¨"""

    def __init__(self, strategy, config):
        self.strategy = strategy
        self.config = config
        self.live_returns = strategy.get_live_returns()

    def should_retire(self) -> tuple:
        """
        åˆ¤æ–­ç­–ç•¥æ˜¯å¦åº”è¯¥é€€å½¹

        Returns:
            (should_retire: bool, reasons: list)
        """
        reasons = []

        # 1. è¿ç»­äºæŸæ£€æŸ¥
        if self.check_consecutive_losses():
            reasons.append("è¿ç»­äºæŸæ—¶é—´è¿‡é•¿")

        # 2. å¤æ™®æ¯”ç‡è¡°å‡æ£€æŸ¥
        if self.check_sharpe_degradation():
            reasons.append("å¤æ™®æ¯”ç‡ä¸¥é‡è¡°å‡")

        # 3. æœ€å¤§å›æ’¤æ£€æŸ¥
        if self.check_excessive_drawdown():
            reasons.append("å›æ’¤è¶…è¿‡é˜ˆå€¼")

        # 4. ç­–ç•¥å®¹é‡æ£€æŸ¥
        if self.check_capacity_issue():
            reasons.append("ç­–ç•¥å®¹é‡ä¸è¶³")

        # 5. å¸‚åœºç¯å¢ƒå˜åŒ–æ£€æŸ¥
        if self.check_regime_change():
            reasons.append("å¸‚åœºç¯å¢ƒå‘ç”Ÿæ ¹æœ¬æ€§å˜åŒ–")

        should_retire = len(reasons) >= 2  # æ»¡è¶³2ä¸ªæˆ–ä»¥ä¸Šæ¡ä»¶åˆ™é€€å½¹

        return should_retire, reasons

    def check_consecutive_losses(self) -> bool:
        """æ£€æŸ¥è¿ç»­äºæŸ"""
        # è¿ç»­6ä¸ªæœˆäºæŸ
        monthly_returns = self.live_returns.resample('M').apply(lambda x: (1 + x).prod() - 1)

        consecutive_losses = 0
        for ret in monthly_returns.iloc[::-1]:  # ä»æœ€è¿‘å¼€å§‹
            if ret < 0:
                consecutive_losses += 1
            else:
                break

        return consecutive_losses >= 6

    def check_sharpe_degradation(self) -> bool:
        """æ£€æŸ¥å¤æ™®æ¯”ç‡è¡°å‡"""
        # æœ€è¿‘6ä¸ªæœˆçš„å¤æ™®æ¯”ç‡
        recent_returns = self.live_returns.tail(126)  # çº¦6ä¸ªæœˆ
        recent_sharpe = (recent_returns.mean() - 0.03/252) / recent_returns.std() * np.sqrt(252)

        # å†å²å¤æ™®æ¯”ç‡
        backtest_sharpe = self.strategy.backtest_stats['sharpe_ratio']

        # è¡°å‡è¶…è¿‡50%
        return recent_sharpe < backtest_sharpe * 0.5

    def check_excessive_drawdown(self) -> bool:
        """æ£€æŸ¥è¿‡åº¦å›æ’¤"""
        current_dd = self.strategy.get_current_drawdown()
        max_acceptable_dd = self.config.MAX_ACCEPTABLE_DRAWDOWN  # å¦‚-0.30

        return current_dd < max_acceptable_dd

    def check_capacity_issue(self) -> bool:
        """æ£€æŸ¥å®¹é‡é—®é¢˜"""
        # å¦‚æœç­–ç•¥è§„æ¨¡å¢é•¿ï¼Œä½†æ”¶ç›Šä¸‹é™
        # è¿™é‡Œç®€åŒ–å¤„ç†
        return False

    def check_regime_change(self) -> bool:
        """æ£€æŸ¥å¸‚åœºç¯å¢ƒå˜åŒ–"""
        # ä¾‹å¦‚ï¼š
        # - å¸‚åœºæ³¢åŠ¨ç‡æŒç»­å¼‚å¸¸
        # - å› å­ICæŒç»­ä¸ºè´Ÿ
        # - ç­–ç•¥é€»è¾‘æ‰€ä¾èµ–çš„å¸‚åœºç‰¹å¾æ¶ˆå¤±

        # è¿™é‡Œç®€åŒ–å¤„ç†
        return False

    def generate_retirement_report(self, reasons: list) -> str:
        """ç”Ÿæˆé€€å½¹æŠ¥å‘Š"""
        report = f"""
        ========== ç­–ç•¥é€€å½¹æŠ¥å‘Š ==========
        ç­–ç•¥åç§°: {self.strategy.name}
        è¯„ä¼°æ—¥æœŸ: {datetime.now().date()}

        ğŸ“Š æœ€è¿‘è¡¨ç°:
        - æœ€è¿‘6ä¸ªæœˆæ”¶ç›Š: {self.live_returns.tail(126).sum():.2%}
        - æœ€è¿‘6ä¸ªæœˆå¤æ™®: {(self.live_returns.tail(126).mean() - 0.03/252) / self.live_returns.tail(126).std() * np.sqrt(252):.2f}
        - å½“å‰å›æ’¤: {self.strategy.get_current_drawdown():.2%}

        âš ï¸  é€€å½¹åŸå› :
        """

        for reason in reasons:
            report += f"\n- {reason}"

        report += """

        ğŸ“‹ å»ºè®®æªæ–½:
        1. åœæ­¢æ–°å¢èµ„é‡‘æŠ•å…¥
        2. é€æ­¥é™ä½ä»“ä½ï¼ˆå»ºè®®1-2å‘¨å†…é™è‡³0ï¼‰
        3. è¿›è¡Œç­–ç•¥å¤ç›˜ï¼Œåˆ†æå¤±æ•ˆåŸå› 
        4. å¦‚æœ‰æ”¹è¿›æ–¹æ¡ˆï¼Œé‡æ–°å›æµ‹éªŒè¯åå†è€ƒè™‘é‡å¯
        5. ä¿ç•™ä»£ç å’Œæ•°æ®ï¼Œä½œä¸ºç»éªŒæ€»ç»“

        ================================
        """

        return report

# ä½¿ç”¨
evaluator = StrategyRetirementEvaluator(my_strategy, config)
should_retire, reasons = evaluator.should_retire()

if should_retire:
    print("âš ï¸  ç­–ç•¥è¾¾åˆ°é€€å½¹æ ‡å‡†ï¼")
    report = evaluator.generate_retirement_report(reasons)
    print(report)

    # å‘é€é€šçŸ¥
    send_alert(report, level='CRITICAL')

    # å¼€å§‹é€€å½¹æµç¨‹
    # ...
```

---

## æœ¬ç« å°ç»“

æœ¬ç« å…¨é¢ä»‹ç»äº†ä¸“ä¸šçš„é‡åŒ–ç­–ç•¥å¼€å‘å®Œæ•´æµç¨‹ï¼Œä¸»è¦å†…å®¹åŒ…æ‹¬ï¼š

### ğŸ“š æ ¸å¿ƒè¦ç‚¹

1. **å®Œæ•´çš„ç ”ç©¶å·¥ä½œæµ**
   - Ideaäº§ç”Ÿ â†’ å‡è®¾éªŒè¯ â†’ ç­–ç•¥è®¾è®¡ â†’ ç¼–ç å®ç° â†’ å›æµ‹ä¼˜åŒ– â†’ å®ç›˜éƒ¨ç½²
   - æ¯ä¸ªé˜¶æ®µéƒ½ä¸èƒ½è·³è¿‡ï¼Œç‰¹åˆ«æ˜¯å‡è®¾éªŒè¯
   - å…è®¸è¿­ä»£å›é€€ï¼Œå‘ç°é—®é¢˜åŠæ—¶è°ƒæ•´

2. **ç­–ç•¥å¼€å‘æœ€ä½³å®è·µ**
   - éµå¾ªè§„èŒƒçš„ä»£ç ç»“æ„å’Œç¼–ç é£æ ¼
   - ä½¿ç”¨Gitè¿›è¡Œç‰ˆæœ¬æ§åˆ¶
   - ç¼–å†™å®Œæ•´çš„æ–‡æ¡£
   - è¿›è¡Œå……åˆ†çš„å•å…ƒæµ‹è¯•

3. **ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†**
   - åˆ¶å®šä¸¥æ ¼çš„ä¸Šçº¿æ ‡å‡†
   - æŒç»­ç›‘æ§è¿è¡ŒçŠ¶æ€
   - å®šæœŸè¯„ä¼°å®ç›˜è¡¨ç°
   - åŠæ—¶é€€å½¹å¤±æ•ˆç­–ç•¥

### âš ï¸ é‡ç‚¹æé†’

1. **å‡è®¾éªŒè¯çš„é‡è¦æ€§**
   - åœ¨ç¼–ç å‰å¿…é¡»éªŒè¯ç­–ç•¥çš„æ ¸å¿ƒå‡è®¾
   - ä½¿ç”¨ICåˆ†æã€åˆ†ç»„å›æµ‹ç­‰æ–¹æ³•
   - å‡è®¾æœªé€šè¿‡ï¼Œä¸è¦å¼ºè¡Œç»§ç»­

2. **é˜²æ­¢è¿‡æ‹Ÿåˆ**
   - ä½¿ç”¨æ ·æœ¬å¤–æµ‹è¯•
   - å‚æ•°ä¸åº”è¿‡äºæ•æ„Ÿ
   - ç­–ç•¥é€»è¾‘è¦æœ‰ç»æµå­¦è§£é‡Š

3. **å°èµ„é‡‘è¯•é”™**
   - ä¸è¦ä¸€ä¸Šæ¥å°±æŠ•å…¥å¤§é¢èµ„é‡‘
   - ä»1ä¸‡å¼€å§‹ï¼Œé€æ­¥æ”¾å¤§
   - éªŒè¯ç­–ç•¥åœ¨çœŸå®å¸‚åœºçš„è¡¨ç°

4. **åŠæ—¶æ­¢æŸ**
   - ç­–ç•¥å¤±æ•ˆè¦åŠæ—¶é€€å½¹
   - ä¸è¦å¯¹å•ä¸€ç­–ç•¥è¿‡åº¦æ‰§ç€
   - ä¿æŒç­–ç•¥ç»„åˆçš„åŠ¨æ€è°ƒæ•´

### ğŸ¯ å®è·µå»ºè®®

1. **å»ºç«‹è‡ªå·±çš„ç­–ç•¥å¼€å‘æ¨¡æ¿**
   - ç»Ÿä¸€çš„é¡¹ç›®ç»“æ„
   - æ ‡å‡†çš„é…ç½®æ–‡ä»¶
   - å¯å¤ç”¨çš„å·¥å…·å‡½æ•°

2. **ç§¯ç´¯ç­–ç•¥åº“**
   - æ¯ä¸ªç­–ç•¥éƒ½å®Œæ•´è®°å½•
   - åŒ…æ‹¬æˆåŠŸå’Œå¤±è´¥çš„ç­–ç•¥
   - å®šæœŸå¤ç›˜å’Œæ€»ç»“

3. **æŒç»­å­¦ä¹ **
   - è·Ÿè¸ªå­¦æœ¯å‰æ²¿
   - å‚ä¸é‡åŒ–ç¤¾åŒº
   - åˆ†äº«å’Œäº¤æµç»éªŒ

### ğŸ“– ä¸‹ä¸€æ­¥å­¦ä¹ 

ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹  **å› å­æŒ–æ˜ä¸ç ”ç©¶**ï¼Œæ·±å…¥äº†è§£å¦‚ä½•æ„å»ºæœ‰æ•ˆçš„é‡åŒ–å› å­ï¼Œè¿™æ˜¯ç­–ç•¥å¼€å‘çš„æ ¸å¿ƒåŸºç¡€ã€‚

---

**ğŸ’¡ æ€è€ƒé¢˜**ï¼š

1. ä½ è®¤ä¸ºåœ¨ç­–ç•¥å¼€å‘æµç¨‹ä¸­ï¼Œå“ªä¸ªç¯èŠ‚æœ€å®¹æ˜“è¢«å¿½è§†ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
2. å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç­–ç•¥çš„å¤±æ•ˆæ˜¯æš‚æ—¶çš„è¿˜æ˜¯æ°¸ä¹…çš„ï¼Ÿ
3. åœ¨å°èµ„é‡‘è¯•é”™é˜¶æ®µï¼Œå¦‚æœå®ç›˜è¡¨ç°ä¸å›æµ‹åå·®å¾ˆå¤§ï¼Œåº”è¯¥å¦‚ä½•åº”å¯¹ï¼Ÿ

---

*æœ¬ç« å®Œ*
