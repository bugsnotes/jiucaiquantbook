# ç¬¬åäºŒç« ï¼šå›æµ‹ä¸å®ç›˜ ğŸ¯

> ğŸ’¡ **æœ¬ç« å¯¼è¯»**ï¼šå›æµ‹æ˜¯ç­–ç•¥ä»ç†è®ºèµ°å‘å®è·µçš„æ¡¥æ¢ã€‚ç„¶è€Œ,å¾ˆå¤šçœ‹ä¼¼å®Œç¾çš„å›æµ‹ç»“æœåœ¨å®ç›˜ä¸­å´æƒ¨é­æ»‘é“å¢ã€‚æœ¬ç« å°†æ·±å…¥è®²è§£å›æµ‹çš„æ­£ç¡®æ–¹æ³•ã€å¸¸è§é™·é˜±ã€å¦‚ä½•è¯†åˆ«çœŸæ­£ä¼˜ç§€çš„ç­–ç•¥,ä»¥åŠå¦‚ä½•å¹³ç¨³åœ°ä»å›æµ‹è¿‡æ¸¡åˆ°å®ç›˜äº¤æ˜“ã€‚

---

## 12.1 å›æµ‹åŸºç¡€çŸ¥è¯† ğŸ“š

### 12.1.1 ä»€ä¹ˆæ˜¯å›æµ‹ï¼Ÿ

**å›æµ‹(Backtesting)**ï¼šä½¿ç”¨å†å²æ•°æ®æ¨¡æ‹Ÿç­–ç•¥çš„äº¤æ˜“è¿‡ç¨‹,è¯„ä¼°ç­–ç•¥çš„å†å²è¡¨ç°ã€‚

**å›æµ‹çš„ç›®çš„**ï¼š
1. éªŒè¯ç­–ç•¥é€»è¾‘æ˜¯å¦æ­£ç¡®
2. è¯„ä¼°ç­–ç•¥çš„ç›ˆåˆ©èƒ½åŠ›
3. äº†è§£ç­–ç•¥çš„é£é™©ç‰¹å¾
4. ä¼˜åŒ–ç­–ç•¥å‚æ•°
5. å¢å¼ºäº¤æ˜“ä¿¡å¿ƒ

### 12.1.2 å›æµ‹çš„åŸºæœ¬æ¡†æ¶

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class SimpleBacktestEngine:
    """ç®€å•å›æµ‹å¼•æ“"""

    def __init__(self, initial_capital, commission_rate=0.0003):
        """
        å‚æ•°:
        initial_capital: float, åˆå§‹èµ„é‡‘
        commission_rate: float, æ‰‹ç»­è´¹ç‡
        """
        self.initial_capital = initial_capital
        self.commission_rate = commission_rate
        self.reset()

    def reset(self):
        """é‡ç½®å›æµ‹çŠ¶æ€"""
        self.cash = self.initial_capital
        self.position = 0  # æŒä»“æ•°é‡
        self.trades = []   # äº¤æ˜“è®°å½•
        self.equity_curve = []  # èµ„é‡‘æ›²çº¿

    def execute_trade(self, date, price, signal):
        """
        æ‰§è¡Œäº¤æ˜“

        å‚æ•°:
        date: æ—¥æœŸ
        price: float, å½“å‰ä»·æ ¼
        signal: int, äº¤æ˜“ä¿¡å·(1: ä¹°å…¥, -1: å–å‡º, 0: æŒæœ‰)

        è¿”å›:
        dict: äº¤æ˜“ä¿¡æ¯
        """
        trade_info = None

        if signal == 1 and self.position == 0:
            # ä¹°å…¥ä¿¡å·ä¸”å½“å‰ç©ºä»“
            # è®¡ç®—å¯ä¹°å…¥æ•°é‡(æ‰£é™¤æ‰‹ç»­è´¹)
            available_cash = self.cash * (1 - self.commission_rate)
            shares = int(available_cash / price)

            if shares > 0:
                cost = shares * price
                commission = cost * self.commission_rate
                self.cash -= (cost + commission)
                self.position = shares

                trade_info = {
                    'date': date,
                    'type': 'BUY',
                    'price': price,
                    'shares': shares,
                    'cost': cost,
                    'commission': commission
                }
                self.trades.append(trade_info)

        elif signal == -1 and self.position > 0:
            # å–å‡ºä¿¡å·ä¸”å½“å‰æŒä»“
            revenue = self.position * price
            commission = revenue * self.commission_rate
            self.cash += (revenue - commission)

            trade_info = {
                'date': date,
                'type': 'SELL',
                'price': price,
                'shares': self.position,
                'revenue': revenue,
                'commission': commission
            }
            self.trades.append(trade_info)
            self.position = 0

        # è®°å½•èµ„é‡‘æ›²çº¿
        portfolio_value = self.cash + self.position * price
        self.equity_curve.append({
            'date': date,
            'cash': self.cash,
            'position': self.position,
            'price': price,
            'portfolio_value': portfolio_value
        })

        return trade_info

    def run_backtest(self, data, signal_column='signal'):
        """
        è¿è¡Œå›æµ‹

        å‚æ•°:
        data: DataFrame, åŒ…å«ä»·æ ¼å’Œä¿¡å·çš„æ•°æ®
        signal_column: str, ä¿¡å·åˆ—å

        è¿”å›:
        dict: å›æµ‹ç»“æœ
        """
        self.reset()

        for idx, row in data.iterrows():
            self.execute_trade(
                date=idx,
                price=row['close'],
                signal=row[signal_column]
            )

        # å¦‚æœæœ€åè¿˜æŒæœ‰ä»“ä½,æŒ‰æœ€åä»·æ ¼å¹³ä»“
        if self.position > 0:
            last_date = data.index[-1]
            last_price = data.iloc[-1]['close']
            self.execute_trade(last_date, last_price, signal=-1)

        return self.calculate_metrics()

    def calculate_metrics(self):
        """
        è®¡ç®—å›æµ‹æŒ‡æ ‡

        è¿”å›:
        dict: å„é¡¹æŒ‡æ ‡
        """
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df.set_index('date', inplace=True)

        final_value = equity_df['portfolio_value'].iloc[-1]
        total_return = (final_value - self.initial_capital) / self.initial_capital

        # è®¡ç®—æ—¥æ”¶ç›Šç‡
        equity_df['returns'] = equity_df['portfolio_value'].pct_change()

        # å¹´åŒ–æ”¶ç›Šç‡
        trading_days = len(equity_df)
        annual_return = (1 + total_return) ** (252 / trading_days) - 1

        # å¹´åŒ–æ³¢åŠ¨ç‡
        annual_volatility = equity_df['returns'].std() * np.sqrt(252)

        # å¤æ™®æ¯”ç‡
        sharpe_ratio = annual_return / annual_volatility if annual_volatility > 0 else 0

        # æœ€å¤§å›æ’¤
        cumulative_max = equity_df['portfolio_value'].cummax()
        drawdown = (equity_df['portfolio_value'] - cumulative_max) / cumulative_max
        max_drawdown = drawdown.min()

        # äº¤æ˜“ç»Ÿè®¡
        trades_df = pd.DataFrame(self.trades)
        num_trades = len(trades_df) // 2  # ä¹°å–æˆå¯¹

        # è®¡ç®—æ¯ç¬”äº¤æ˜“çš„ç›ˆäº
        if num_trades > 0:
            buy_trades = trades_df[trades_df['type'] == 'BUY'].reset_index(drop=True)
            sell_trades = trades_df[trades_df['type'] == 'SELL'].reset_index(drop=True)

            trade_returns = []
            for i in range(min(len(buy_trades), len(sell_trades))):
                buy_price = buy_trades.iloc[i]['price']
                sell_price = sell_trades.iloc[i]['price']
                ret = (sell_price - buy_price) / buy_price
                trade_returns.append(ret)

            win_trades = [r for r in trade_returns if r > 0]
            lose_trades = [r for r in trade_returns if r < 0]

            win_rate = len(win_trades) / len(trade_returns) if trade_returns else 0
            avg_win = np.mean(win_trades) if win_trades else 0
            avg_loss = np.mean(lose_trades) if lose_trades else 0
            profit_loss_ratio = abs(avg_win / avg_loss) if avg_loss != 0 else 0
        else:
            win_rate = 0
            avg_win = 0
            avg_loss = 0
            profit_loss_ratio = 0

        return {
            'initial_capital': self.initial_capital,
            'final_value': final_value,
            'total_return': total_return,
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'num_trades': num_trades,
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_loss_ratio': profit_loss_ratio,
            'equity_curve': equity_df
        }

    def plot_results(self, results):
        """
        å¯è§†åŒ–å›æµ‹ç»“æœ

        å‚æ•°:
        results: dict, å›æµ‹ç»“æœ
        """
        equity_df = results['equity_curve']

        fig, axes = plt.subplots(3, 1, figsize=(14, 10))

        # èµ„é‡‘æ›²çº¿
        axes[0].plot(equity_df.index, equity_df['portfolio_value'], label='ç­–ç•¥å‡€å€¼')
        axes[0].axhline(y=self.initial_capital, color='r',
                       linestyle='--', alpha=0.5, label='åˆå§‹èµ„é‡‘')
        axes[0].set_ylabel('èµ„é‡‘(å…ƒ)')
        axes[0].set_title(f'å›æµ‹ç»“æœ | æ€»æ”¶ç›Š: {results["total_return"]:.2%} | '
                         f'å¤æ™®: {results["sharpe_ratio"]:.2f} | '
                         f'æœ€å¤§å›æ’¤: {results["max_drawdown"]:.2%}')
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)

        # å›æ’¤æ›²çº¿
        cumulative_max = equity_df['portfolio_value'].cummax()
        drawdown = (equity_df['portfolio_value'] - cumulative_max) / cumulative_max
        axes[1].fill_between(equity_df.index, drawdown, 0,
                            alpha=0.3, color='red', label='å›æ’¤')
        axes[1].set_ylabel('å›æ’¤æ¯”ä¾‹')
        axes[1].set_title('å›æ’¤æ›²çº¿')
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)

        # æ—¥æ”¶ç›Šç‡åˆ†å¸ƒ
        axes[2].hist(equity_df['returns'].dropna(), bins=50, alpha=0.7, edgecolor='black')
        axes[2].set_xlabel('æ—¥æ”¶ç›Šç‡')
        axes[2].set_ylabel('é¢‘æ•°')
        axes[2].set_title('æ—¥æ”¶ç›Šç‡åˆ†å¸ƒ')
        axes[2].grid(True, alpha=0.3)

        plt.tight_layout()
        # plt.savefig('backtest_results.png', dpi=300, bbox_inches='tight')
        print("\nå›æµ‹å¯è§†åŒ–å›¾è¡¨å·²ç”Ÿæˆ")

# ç¤ºä¾‹ä½¿ç”¨
# ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
np.random.seed(42)
dates = pd.date_range('2023-01-01', periods=252, freq='D')
prices = 100 + np.cumsum(np.random.randn(252) * 2)
data = pd.DataFrame({
    'close': prices
}, index=dates)

# ç®€å•çš„åŒå‡çº¿ç­–ç•¥ä¿¡å·
data['MA5'] = data['close'].rolling(window=5).mean()
data['MA20'] = data['close'].rolling(window=20).mean()
data['signal'] = 0
data.loc[data['MA5'] > data['MA20'], 'signal'] = 1
data.loc[data['MA5'] < data['MA20'], 'signal'] = -1

# è¿è¡Œå›æµ‹
engine = SimpleBacktestEngine(initial_capital=100000, commission_rate=0.0003)
results = engine.run_backtest(data)

# æ‰“å°ç»“æœ
print("=" * 60)
print("å›æµ‹ç»“æœæ‘˜è¦")
print("=" * 60)
print(f"åˆå§‹èµ„é‡‘: {results['initial_capital']:,.0f}å…ƒ")
print(f"æœ€ç»ˆèµ„é‡‘: {results['final_value']:,.0f}å…ƒ")
print(f"æ€»æ”¶ç›Šç‡: {results['total_return']:.2%}")
print(f"å¹´åŒ–æ”¶ç›Šç‡: {results['annual_return']:.2%}")
print(f"å¹´åŒ–æ³¢åŠ¨ç‡: {results['annual_volatility']:.2%}")
print(f"å¤æ™®æ¯”ç‡: {results['sharpe_ratio']:.2f}")
print(f"æœ€å¤§å›æ’¤: {results['max_drawdown']:.2%}")
print(f"äº¤æ˜“æ¬¡æ•°: {results['num_trades']}")
print(f"èƒœç‡: {results['win_rate']:.2%}")
print(f"ç›ˆäºæ¯”: {results['profit_loss_ratio']:.2f}")
print("=" * 60)
```

### 12.1.3 å›æµ‹æ•°æ®çš„è¦æ±‚

**æ•°æ®è´¨é‡ç›´æ¥å½±å“å›æµ‹å¯é æ€§ï¼**

| è¦æ±‚ | è¯´æ˜ | é‡è¦æ€§ |
|-----|------|-------|
| **å®Œæ•´æ€§** | æ— ç¼ºå¤±æ•°æ®,æˆ–åˆç†å¡«å…… | â­â­â­â­â­ |
| **å‡†ç¡®æ€§** | æ•°æ®æ— é”™è¯¯(å¦‚ä»·æ ¼å¼‚å¸¸) | â­â­â­â­â­ |
| **æ—¶æ•ˆæ€§** | æ•°æ®åŠæ—¶æ›´æ–° | â­â­â­â­ |
| **ä¸€è‡´æ€§** | æ ¼å¼ç»Ÿä¸€,æ—¶åŒºæ­£ç¡® | â­â­â­â­ |
| **è¶³å¤Ÿçš„å†å²é•¿åº¦** | è‡³å°‘3-5å¹´æ•°æ® | â­â­â­â­ |
| **åŒ…å«åˆ†çº¢é…è‚¡** | å¤æƒå¤„ç† | â­â­â­â­ |
| **é«˜é¢‘æ•°æ®è´¨é‡** | Tickæ•°æ®çš„å‡†ç¡®æ€§ | â­â­â­â­â­ (é«˜é¢‘ç­–ç•¥) |

```python
def check_data_quality(data):
    """
    æ£€æŸ¥æ•°æ®è´¨é‡

    å‚æ•°:
    data: DataFrame, ä»·æ ¼æ•°æ®

    è¿”å›:
    dict: æ•°æ®è´¨é‡æŠ¥å‘Š
    """
    report = {}

    # 1. ç¼ºå¤±å€¼æ£€æŸ¥
    missing_count = data.isnull().sum().sum()
    missing_pct = missing_count / (len(data) * len(data.columns))
    report['missing_values'] = {
        'count': missing_count,
        'percentage': missing_pct
    }

    # 2. å¼‚å¸¸å€¼æ£€æŸ¥(ä»·æ ¼çªå˜)
    if 'close' in data.columns:
        returns = data['close'].pct_change()
        # å®šä¹‰å¼‚å¸¸ä¸ºè¶…è¿‡3å€æ ‡å‡†å·®
        threshold = 3 * returns.std()
        outliers = returns[abs(returns) > threshold]
        report['outliers'] = {
            'count': len(outliers),
            'dates': outliers.index.tolist()
        }

    # 3. æ•°æ®è¿ç»­æ€§æ£€æŸ¥
    if isinstance(data.index, pd.DatetimeIndex):
        # æ£€æŸ¥æ—¥æœŸé—´éš”
        date_diffs = data.index.to_series().diff()
        # å‡è®¾åº”è¯¥æ˜¯æ—¥çº¿æ•°æ®,å·¥ä½œæ—¥é—´éš”ä¸åº”è¶…è¿‡3å¤©
        gaps = date_diffs[date_diffs > pd.Timedelta(days=3)]
        report['date_gaps'] = {
            'count': len(gaps),
            'gaps': gaps.index.tolist()
        }

    # 4. æ•°æ®é•¿åº¦
    report['data_length'] = {
        'total_days': len(data),
        'years': len(data) / 252  # å‡è®¾æ¯å¹´252ä¸ªäº¤æ˜“æ—¥
    }

    return report

# ç¤ºä¾‹
quality_report = check_data_quality(data)
print("\næ•°æ®è´¨é‡æŠ¥å‘Š:")
print(f"ç¼ºå¤±å€¼: {quality_report['missing_values']['count']}ä¸ª "
      f"({quality_report['missing_values']['percentage']:.2%})")
print(f"å¼‚å¸¸å€¼: {quality_report['outliers']['count']}ä¸ª")
print(f"æ•°æ®é•¿åº¦: {quality_report['data_length']['total_days']}å¤© "
      f"(çº¦{quality_report['data_length']['years']:.1f}å¹´)")
```

---

## 12.2 å›æµ‹å¸¸è§é™·é˜± âš ï¸

å›æµ‹ä¸­æœ‰å¾ˆå¤šé™·é˜±ä¼šå¯¼è‡´ç»“æœè¿‡äºä¹è§‚,å®ç›˜æ—¶å¤§å¤±æ‰€æœ›ã€‚

### 12.2.1 å‰è§†åå·® (Look-Ahead Bias)

**å®šä¹‰**ï¼šåœ¨å›æµ‹ä¸­ä½¿ç”¨äº†å½“æ—¶è¿˜ä¸å¯è·å¾—çš„æœªæ¥ä¿¡æ¯ã€‚

**å¸¸è§æƒ…å†µ**ï¼š
1. ä½¿ç”¨æœªæ¥æ•°æ®è®¡ç®—ä¿¡å·
2. ä½¿ç”¨å½“æ—¥æ”¶ç›˜ä»·ä½œä¸ºä¹°å…¥ä»·
3. è´¢åŠ¡æ•°æ®å‘å¸ƒæ—¥æœŸå¤„ç†ä¸å½“

```python
# âŒ é”™è¯¯ç¤ºä¾‹:å‰è§†åå·®
def wrong_strategy(data):
    """ä½¿ç”¨äº†æœªæ¥ä¿¡æ¯"""
    data['signal'] = 0

    for i in range(len(data) - 1):
        # é”™è¯¯!è¿™é‡Œä½¿ç”¨äº†ç¬¬i+1å¤©(æœªæ¥)çš„ä¿¡æ¯æ¥å†³å®šç¬¬iå¤©çš„äº¤æ˜“
        if data.iloc[i+1]['close'] > data.iloc[i]['close']:
            data.iloc[i, data.columns.get_loc('signal')] = 1

    return data

# âœ… æ­£ç¡®ç¤ºä¾‹:é¿å…å‰è§†åå·®
def correct_strategy(data):
    """åªä½¿ç”¨å†å²ä¿¡æ¯"""
    data = data.copy()
    data['signal'] = 0

    for i in range(1, len(data)):
        # æ­£ç¡®!ä½¿ç”¨ç¬¬i-1å¤©åŠä¹‹å‰çš„ä¿¡æ¯æ¥å†³å®šç¬¬iå¤©çš„äº¤æ˜“
        if data.iloc[i-1]['close'] > data.iloc[i-2]['close']:
            data.iloc[i, data.columns.get_loc('signal')] = 1

    return data

# æ”¶ç›˜ä»·äº¤æ˜“é™·é˜±
print("âš ï¸ æ”¶ç›˜ä»·äº¤æ˜“é™·é˜±:")
print("é”™è¯¯: çœ‹åˆ°æ”¶ç›˜ä»·100å…ƒ,å‘å‡ºä¹°å…¥ä¿¡å·,æŒ‰100å…ƒæˆäº¤")
print("ç°å®: çœ‹åˆ°æ”¶ç›˜ä»·æ—¶,äº¤æ˜“å·²ç»“æŸ,åªèƒ½ç¬¬äºŒå¤©å¼€ç›˜ä¹°å…¥")
print("\næ­£ç¡®åšæ³•:")
print("1. ä½¿ç”¨ç¬¬äºŒå¤©çš„å¼€ç›˜ä»·æˆäº¤")
print("2. æˆ–è€…åœ¨ç›˜ä¸­ä½¿ç”¨å®æ—¶ä»·æ ¼(é«˜é¢‘ç­–ç•¥)")
```

### 12.2.2 å¹¸å­˜è€…åå·® (Survivorship Bias)

**å®šä¹‰**ï¼šåªä½¿ç”¨äº†å½“å‰ä»ç„¶å­˜åœ¨çš„æ ‡çš„æ•°æ®,å¿½ç•¥äº†å·²é€€å¸‚/æ‘˜ç‰Œçš„æ ‡çš„ã€‚

```python
class SurvivorshipBiasExample:
    """å¹¸å­˜è€…åå·®ç¤ºä¾‹"""

    @staticmethod
    def demonstrate_bias():
        """æ¼”ç¤ºå¹¸å­˜è€…åå·®çš„å½±å“"""

        # å‡è®¾æœ‰10åªè‚¡ç¥¨
        stocks = [
            {'name': 'A', 'return': 0.5, 'survived': True},   # å¹¸å­˜,æ¶¨50%
            {'name': 'B', 'return': 0.3, 'survived': True},   # å¹¸å­˜,æ¶¨30%
            {'name': 'C', 'return': -0.8, 'survived': False}, # é€€å¸‚,è·Œ80%
            {'name': 'D', 'return': 0.2, 'survived': True},   # å¹¸å­˜,æ¶¨20%
            {'name': 'E', 'return': -0.9, 'survived': False}, # é€€å¸‚,è·Œ90%
            {'name': 'F', 'return': 0.4, 'survived': True},   # å¹¸å­˜,æ¶¨40%
            {'name': 'G', 'return': -0.7, 'survived': False}, # é€€å¸‚,è·Œ70%
            {'name': 'H', 'return': 0.1, 'survived': True},   # å¹¸å­˜,æ¶¨10%
            {'name': 'I', 'return': 0.25, 'survived': True},  # å¹¸å­˜,æ¶¨25%
            {'name': 'J', 'return': -0.6, 'survived': False}, # é€€å¸‚,è·Œ60%
        ]

        # åªçœ‹å¹¸å­˜è‚¡ç¥¨(é”™è¯¯)
        survived_stocks = [s for s in stocks if s['survived']]
        biased_return = np.mean([s['return'] for s in survived_stocks])

        # çœ‹æ‰€æœ‰è‚¡ç¥¨(æ­£ç¡®)
        true_return = np.mean([s['return'] for s in stocks])

        print("å¹¸å­˜è€…åå·®ç¤ºä¾‹:")
        print(f"åªçœ‹å¹¸å­˜è‚¡ç¥¨çš„å¹³å‡æ”¶ç›Š: {biased_return:.2%}")
        print(f"åŒ…å«æ‰€æœ‰è‚¡ç¥¨çš„çœŸå®æ”¶ç›Š: {true_return:.2%}")
        print(f"åå·®: {biased_return - true_return:.2%}")

        return biased_return, true_return

SurvivorshipBiasExample.demonstrate_bias()
```

**å¦‚ä½•é¿å…**ï¼š
- ä½¿ç”¨åŒ…å«é€€å¸‚è‚¡ç¥¨çš„å®Œæ•´æ•°æ®åº“
- åœ¨ç­–ç•¥ä¸­æ¨¡æ‹Ÿé€€å¸‚å¤„ç†(è‚¡ä»·å½’é›¶)
- è°¨æ…å¯¹å¾…å†å²æ•°æ®æä¾›å•†çš„"å¹¸å­˜è‚¡ç¥¨æ± "

### 12.2.3 è¿‡åº¦æ‹Ÿåˆ (Overfitting)

**å®šä¹‰**ï¼šç­–ç•¥è¿‡åº¦é€‚åº”å†å²æ•°æ®çš„å™ªéŸ³,è€Œéæ•æ‰çœŸå®è§„å¾‹ã€‚

```python
import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import Pipeline

def demonstrate_overfitting():
    """æ¼”ç¤ºè¿‡åº¦æ‹Ÿåˆ"""

    np.random.seed(42)

    # ç”ŸæˆçœŸå®å…³ç³»: y = sin(x) + noise
    X = np.linspace(0, 10, 50)
    y_true = np.sin(X)
    y = y_true + np.random.randn(50) * 0.3

    X_plot = np.linspace(0, 10, 200)
    y_plot_true = np.sin(X_plot)

    fig, axes = plt.subplots(1, 3, figsize=(15, 4))

    # ç®€å•æ¨¡å‹(æ¬ æ‹Ÿåˆ)
    model1 = Pipeline([
        ('poly', PolynomialFeatures(degree=1)),
        ('linear', LinearRegression())
    ])
    model1.fit(X.reshape(-1, 1), y)
    y_pred1 = model1.predict(X_plot.reshape(-1, 1))

    axes[0].scatter(X, y, alpha=0.5, label='æ•°æ®ç‚¹')
    axes[0].plot(X_plot, y_plot_true, 'g--', label='çœŸå®å…³ç³»', linewidth=2)
    axes[0].plot(X_plot, y_pred1, 'r-', label='æ¨¡å‹æ‹Ÿåˆ', linewidth=2)
    axes[0].set_title('æ¬ æ‹Ÿåˆ(è¿‡äºç®€å•)')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)

    # åˆé€‚çš„æ¨¡å‹
    model2 = Pipeline([
        ('poly', PolynomialFeatures(degree=3)),
        ('linear', LinearRegression())
    ])
    model2.fit(X.reshape(-1, 1), y)
    y_pred2 = model2.predict(X_plot.reshape(-1, 1))

    axes[1].scatter(X, y, alpha=0.5, label='æ•°æ®ç‚¹')
    axes[1].plot(X_plot, y_plot_true, 'g--', label='çœŸå®å…³ç³»', linewidth=2)
    axes[1].plot(X_plot, y_pred2, 'r-', label='æ¨¡å‹æ‹Ÿåˆ', linewidth=2)
    axes[1].set_title('åˆé€‚çš„æ‹Ÿåˆ')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)

    # è¿‡æ‹Ÿåˆæ¨¡å‹
    model3 = Pipeline([
        ('poly', PolynomialFeatures(degree=15)),
        ('linear', LinearRegression())
    ])
    model3.fit(X.reshape(-1, 1), y)
    y_pred3 = model3.predict(X_plot.reshape(-1, 1))

    axes[2].scatter(X, y, alpha=0.5, label='æ•°æ®ç‚¹')
    axes[2].plot(X_plot, y_plot_true, 'g--', label='çœŸå®å…³ç³»', linewidth=2)
    axes[2].plot(X_plot, y_pred3, 'r-', label='æ¨¡å‹æ‹Ÿåˆ', linewidth=2)
    axes[2].set_title('è¿‡æ‹Ÿåˆ(è¿‡äºå¤æ‚)')
    axes[2].legend()
    axes[2].grid(True, alpha=0.3)

    plt.tight_layout()
    # plt.savefig('overfitting_demo.png', dpi=300, bbox_inches='tight')
    print("è¿‡æ‹Ÿåˆæ¼”ç¤ºå›¾è¡¨å·²ç”Ÿæˆ")

# demonstrate_overfitting()

print("\nå¦‚ä½•é¿å…è¿‡åº¦æ‹Ÿåˆ:")
print("1. ä½¿ç”¨æ ·æœ¬å¤–éªŒè¯(è®­ç»ƒé›†/æµ‹è¯•é›†åˆ†ç¦»)")
print("2. äº¤å‰éªŒè¯")
print("3. ä¿æŒç­–ç•¥ç®€å•")
print("4. é™åˆ¶å‚æ•°æ•°é‡")
print("5. ä½¿ç”¨æ­£åˆ™åŒ–")
print("6. æ³¨æ„å‚æ•°ä¼˜åŒ–è¿‡ç¨‹")
```

### 12.2.4 äº¤æ˜“æˆæœ¬å¿½è§†

**å¾ˆå¤šå›æµ‹ç»“æœåœ¨æ‰£é™¤çœŸå®äº¤æ˜“æˆæœ¬å,æ”¶ç›Šå¤§å¹…é™ä½ç”šè‡³ä¸ºè´Ÿã€‚**

```python
class TradingCostAnalysis:
    """äº¤æ˜“æˆæœ¬åˆ†æ"""

    def __init__(self):
        pass

    @staticmethod
    def calculate_total_costs(trades, price, amount):
        """
        è®¡ç®—æ€»äº¤æ˜“æˆæœ¬

        å‚æ•°:
        trades: int, äº¤æ˜“æ¬¡æ•°
        price: float, å¹³å‡ä»·æ ¼
        amount: float, å¹³å‡äº¤æ˜“é‡‘é¢

        è¿”å›:
        dict: å„é¡¹æˆæœ¬
        """
        # ä¸­å›½Aè‚¡å…¸å‹æˆæœ¬(ä¹°å–ä¸€æ¬¡çš„æ€»æˆæœ¬)
        commission = amount * 0.0003  # åˆ¸å•†ä½£é‡‘0.03%,åŒå‘
        stamp_tax = amount * 0.001    # å°èŠ±ç¨0.1%,ä»…å–å‡º
        transfer_fee = amount * 0.00002  # è¿‡æˆ·è´¹0.002%,åŒå‘

        single_trade_cost = (commission * 2) + stamp_tax + (transfer_fee * 2)
        total_cost = single_trade_cost * trades

        return {
            'commission': commission * 2 * trades,
            'stamp_tax': stamp_tax * trades,
            'transfer_fee': transfer_fee * 2 * trades,
            'single_trade_cost': single_trade_cost,
            'total_cost': total_cost,
            'cost_rate': single_trade_cost / amount
        }

    @staticmethod
    def compare_with_without_costs():
        """å¯¹æ¯”æœ‰æ— äº¤æ˜“æˆæœ¬çš„å›æµ‹ç»“æœ"""

        # å‡è®¾ç­–ç•¥
        initial_capital = 100000
        num_trades = 100  # ä¸€å¹´100æ¬¡äº¤æ˜“
        avg_trade_amount = 20000
        gross_return = 0.20  # æ¯›æ”¶ç›Šç‡20%

        costs = TradingCostAnalysis.calculate_total_costs(
            trades=num_trades,
            price=50,
            amount=avg_trade_amount
        )

        net_return = gross_return - (costs['total_cost'] / initial_capital)

        print("äº¤æ˜“æˆæœ¬å½±å“åˆ†æ:")
        print("=" * 50)
        print(f"åˆå§‹èµ„é‡‘: {initial_capital:,.0f}å…ƒ")
        print(f"å¹´äº¤æ˜“æ¬¡æ•°: {num_trades}")
        print(f"å¹³å‡æ¯ç¬”äº¤æ˜“é‡‘é¢: {avg_trade_amount:,.0f}å…ƒ")
        print(f"\nå•æ¬¡ä¹°å–æˆæœ¬: {costs['single_trade_cost']:.2f}å…ƒ "
              f"({costs['cost_rate']:.2%})")
        print(f"  - ä½£é‡‘: {costs['commission'] / num_trades:.2f}å…ƒ")
        print(f"  - å°èŠ±ç¨: {costs['stamp_tax'] / num_trades:.2f}å…ƒ")
        print(f"  - è¿‡æˆ·è´¹: {costs['transfer_fee'] / num_trades:.2f}å…ƒ")
        print(f"\nå¹´åº¦æ€»æˆæœ¬: {costs['total_cost']:,.2f}å…ƒ")
        print(f"\næ¯›æ”¶ç›Šç‡: {gross_return:.2%}")
        print(f"å‡€æ”¶ç›Šç‡: {net_return:.2%}")
        print(f"æˆæœ¬å½±å“: {gross_return - net_return:.2%}")
        print("=" * 50)

TradingCostAnalysis.compare_with_without_costs()
```

**äº¤æ˜“æˆæœ¬æ¸…å•**ï¼š
- âœ… ä½£é‡‘
- âœ… å°èŠ±ç¨(ä¸­å›½Aè‚¡)
- âœ… è¿‡æˆ·è´¹
- âœ… æ»‘ç‚¹(å¸‚ä»·å•ä¸å®é™…æˆäº¤ä»·å·®å¼‚)
- âœ… å¸‚åœºå†²å‡»æˆæœ¬(å¤§å•å¯¹ä»·æ ¼çš„å½±å“)
- âœ… èèµ„èåˆ¸åˆ©æ¯(æ æ†äº¤æ˜“)

### 12.2.5 æµåŠ¨æ€§å‡è®¾

**å¾ˆå¤šå›æµ‹å‡è®¾å¯ä»¥æŒ‰ç…§é¢„æœŸä»·æ ¼ç«‹å³æˆäº¤,ä½†å®é™…ä¸­å¯èƒ½é¢ä¸´æµåŠ¨æ€§ä¸è¶³ã€‚**

```python
def check_liquidity_risk(data, position_value, max_volume_pct=0.05):
    """
    æ£€æŸ¥æµåŠ¨æ€§é£é™©

    å‚æ•°:
    data: DataFrame, åŒ…å«æˆäº¤é‡æ•°æ®
    position_value: float, æ‹Ÿå»ºä»“ä½ä»·å€¼
    max_volume_pct: float, ä¸åº”è¶…è¿‡æ—¥å‡æˆäº¤é‡çš„ç™¾åˆ†æ¯”

    è¿”å›:
    dict: æµåŠ¨æ€§åˆ†æ
    """
    if 'volume' not in data.columns or 'close' not in data.columns:
        return {'error': 'Data must contain volume and close columns'}

    # è®¡ç®—æ—¥å‡æˆäº¤é¢
    data['turnover'] = data['volume'] * data['close']
    avg_daily_turnover = data['turnover'].mean()

    # å»ºè®®çš„æœ€å¤§ä»“ä½
    max_position = avg_daily_turnover * max_volume_pct

    # è¯„ä¼°
    is_liquid_enough = position_value <= max_position
    liquidity_ratio = position_value / max_position

    return {
        'avg_daily_turnover': avg_daily_turnover,
        'position_value': position_value,
        'max_safe_position': max_position,
        'is_liquid_enough': is_liquid_enough,
        'liquidity_ratio': liquidity_ratio,
        'warning': 'æµåŠ¨æ€§ä¸è¶³,å¯èƒ½é¢ä¸´æ»‘ç‚¹æˆ–æ— æ³•æˆäº¤' if not is_liquid_enough else 'æµåŠ¨æ€§å……è¶³'
    }

# ç¤ºä¾‹
# å‡è®¾æ•°æ®åŒ…å«æˆäº¤é‡
data_with_volume = data.copy()
data_with_volume['volume'] = np.random.randint(1000000, 5000000, len(data))

position_value = 500000  # æƒ³è¦å»ºä»“50ä¸‡
liquidity_analysis = check_liquidity_risk(data_with_volume, position_value)

print("\næµåŠ¨æ€§åˆ†æ:")
print(f"æ—¥å‡æˆäº¤é¢: {liquidity_analysis['avg_daily_turnover']:,.0f}å…ƒ")
print(f"æ‹Ÿå»ºä»“ä½: {liquidity_analysis['position_value']:,.0f}å…ƒ")
print(f"å®‰å…¨ä»“ä½ä¸Šé™: {liquidity_analysis['max_safe_position']:,.0f}å…ƒ")
print(f"æµåŠ¨æ€§æ¯”ç‡: {liquidity_analysis['liquidity_ratio']:.2f}")
print(f"è¯„ä¼°: {liquidity_analysis['warning']}")
```

---

## 12.3 å¦‚ä½•è¯†åˆ«å¥½ç­–ç•¥ âœ¨

### 12.3.1 æ ·æœ¬å¤–éªŒè¯

**å°†æ•°æ®åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†,åœ¨è®­ç»ƒé›†ä¸Šå¼€å‘ç­–ç•¥,åœ¨æµ‹è¯•é›†ä¸ŠéªŒè¯ã€‚**

```python
class WalkForwardAnalysis:
    """æ»šåŠ¨ä¼˜åŒ–åˆ†æ(Walk-Forward Analysis)"""

    def __init__(self, train_period, test_period):
        """
        å‚æ•°:
        train_period: int, è®­ç»ƒæœŸé•¿åº¦(å¤©)
        test_period: int, æµ‹è¯•æœŸé•¿åº¦(å¤©)
        """
        self.train_period = train_period
        self.test_period = test_period

    def split_data(self, data):
        """
        æ»šåŠ¨åˆ†å‰²æ•°æ®

        å‚æ•°:
        data: DataFrame, å®Œæ•´æ•°æ®

        è¿”å›:
        list: [(è®­ç»ƒé›†, æµ‹è¯•é›†), ...]
        """
        splits = []
        total_length = len(data)
        step = self.test_period

        start = 0
        while start + self.train_period + self.test_period <= total_length:
            train_end = start + self.train_period
            test_end = train_end + self.test_period

            train_data = data.iloc[start:train_end]
            test_data = data.iloc[train_end:test_end]

            splits.append((train_data, test_data))

            start += step

        return splits

    def analyze(self, data, strategy_func):
        """
        æ‰§è¡Œæ»šåŠ¨åˆ†æ

        å‚æ•°:
        data: DataFrame, å®Œæ•´æ•°æ®
        strategy_func: function, ç­–ç•¥å‡½æ•°,æ¥å—æ•°æ®å’Œå‚æ•°,è¿”å›ä¿¡å·

        è¿”å›:
        dict: åˆ†æç»“æœ
        """
        splits = self.split_data(data)

        train_results = []
        test_results = []

        for i, (train_data, test_data) in enumerate(splits):
            # åœ¨è®­ç»ƒé›†ä¸Šä¼˜åŒ–å‚æ•°(è¿™é‡Œç®€åŒ–,å®é™…åº”è¯¥è¿›è¡Œå‚æ•°æœç´¢)
            train_signals = strategy_func(train_data)
            train_returns = self.calculate_returns(train_data, train_signals)
            train_results.append(train_returns)

            # åœ¨æµ‹è¯•é›†ä¸ŠéªŒè¯
            test_signals = strategy_func(test_data)
            test_returns = self.calculate_returns(test_data, test_signals)
            test_results.append(test_returns)

        return {
            'num_splits': len(splits),
            'train_avg_return': np.mean(train_results),
            'test_avg_return': np.mean(test_results),
            'train_std': np.std(train_results),
            'test_std': np.std(test_results),
            'degradation': np.mean(train_results) - np.mean(test_results),
            'consistency': np.corrcoef(train_results, test_results)[0, 1]
        }

    @staticmethod
    def calculate_returns(data, signals):
        """ç®€å•è®¡ç®—æ”¶ç›Šç‡"""
        returns = data['close'].pct_change()
        strategy_returns = (signals.shift(1) * returns).sum()
        return strategy_returns

# ç¤ºä¾‹
def simple_strategy(data):
    """ç®€å•çš„åŒå‡çº¿ç­–ç•¥"""
    signals = pd.Series(0, index=data.index)
    ma5 = data['close'].rolling(5).mean()
    ma20 = data['close'].rolling(20).mean()
    signals[ma5 > ma20] = 1
    signals[ma5 < ma20] = -1
    return signals

wfa = WalkForwardAnalysis(train_period=120, test_period=60)
results = wfa.analyze(data, simple_strategy)

print("\næ»šåŠ¨ä¼˜åŒ–åˆ†æç»“æœ:")
print(f"åˆ†å‰²æ¬¡æ•°: {results['num_splits']}")
print(f"è®­ç»ƒé›†å¹³å‡æ”¶ç›Š: {results['train_avg_return']:.2%}")
print(f"æµ‹è¯•é›†å¹³å‡æ”¶ç›Š: {results['test_avg_return']:.2%}")
print(f"æ€§èƒ½è¡°å‡: {results['degradation']:.2%}")
print(f"ä¸€è‡´æ€§: {results['consistency']:.2f}")

if results['degradation'] > 0.05:
    print("âš ï¸ è­¦å‘Š: æ ·æœ¬å¤–è¡¨ç°æ˜¾è‘—å·®äºæ ·æœ¬å†…,å¯èƒ½å­˜åœ¨è¿‡æ‹Ÿåˆ")
```

### 12.3.2 å…³é”®æŒ‡æ ‡è¯„ä¼°

```python
class StrategyEvaluator:
    """ç­–ç•¥ç»¼åˆè¯„ä¼°"""

    def __init__(self):
        self.criteria = {
            'min_sharpe': 1.0,
            'max_drawdown': -0.20,
            'min_win_rate': 0.40,
            'min_profit_loss_ratio': 1.2,
            'min_num_trades': 30
        }

    def evaluate(self, backtest_results):
        """
        ç»¼åˆè¯„ä¼°ç­–ç•¥

        å‚æ•°:
        backtest_results: dict, å›æµ‹ç»“æœ

        è¿”å›:
        dict: è¯„ä¼°ç»“æœå’Œå»ºè®®
        """
        scores = {}
        passed = True

        # 1. å¤æ™®æ¯”ç‡
        sharpe = backtest_results['sharpe_ratio']
        scores['sharpe'] = {
            'value': sharpe,
            'criterion': self.criteria['min_sharpe'],
            'passed': sharpe >= self.criteria['min_sharpe'],
            'grade': self._grade_sharpe(sharpe)
        }
        if not scores['sharpe']['passed']:
            passed = False

        # 2. æœ€å¤§å›æ’¤
        max_dd = backtest_results['max_drawdown']
        scores['max_drawdown'] = {
            'value': max_dd,
            'criterion': self.criteria['max_drawdown'],
            'passed': max_dd >= self.criteria['max_drawdown'],
            'grade': self._grade_drawdown(max_dd)
        }
        if not scores['max_drawdown']['passed']:
            passed = False

        # 3. èƒœç‡
        win_rate = backtest_results['win_rate']
        scores['win_rate'] = {
            'value': win_rate,
            'criterion': self.criteria['min_win_rate'],
            'passed': win_rate >= self.criteria['min_win_rate'],
            'grade': self._grade_win_rate(win_rate)
        }
        if not scores['win_rate']['passed']:
            passed = False

        # 4. ç›ˆäºæ¯”
        pl_ratio = backtest_results['profit_loss_ratio']
        scores['profit_loss_ratio'] = {
            'value': pl_ratio,
            'criterion': self.criteria['min_profit_loss_ratio'],
            'passed': pl_ratio >= self.criteria['min_profit_loss_ratio'],
            'grade': self._grade_pl_ratio(pl_ratio)
        }
        if not scores['profit_loss_ratio']['passed']:
            passed = False

        # 5. äº¤æ˜“æ¬¡æ•°
        num_trades = backtest_results['num_trades']
        scores['num_trades'] = {
            'value': num_trades,
            'criterion': self.criteria['min_num_trades'],
            'passed': num_trades >= self.criteria['min_num_trades'],
            'grade': 'A' if num_trades >= 50 else ('B' if num_trades >= 30 else 'C')
        }
        if not scores['num_trades']['passed']:
            passed = False

        # ç»¼åˆè¯„åˆ†
        overall_grade = self._calculate_overall_grade(scores)

        return {
            'scores': scores,
            'passed': passed,
            'overall_grade': overall_grade,
            'recommendation': self._get_recommendation(scores, overall_grade)
        }

    @staticmethod
    def _grade_sharpe(sharpe):
        if sharpe >= 2.0:
            return 'A'
        elif sharpe >= 1.5:
            return 'B'
        elif sharpe >= 1.0:
            return 'C'
        else:
            return 'D'

    @staticmethod
    def _grade_drawdown(dd):
        if dd >= -0.10:
            return 'A'
        elif dd >= -0.15:
            return 'B'
        elif dd >= -0.20:
            return 'C'
        else:
            return 'D'

    @staticmethod
    def _grade_win_rate(wr):
        if wr >= 0.60:
            return 'A'
        elif wr >= 0.50:
            return 'B'
        elif wr >= 0.40:
            return 'C'
        else:
            return 'D'

    @staticmethod
    def _grade_pl_ratio(plr):
        if plr >= 2.0:
            return 'A'
        elif plr >= 1.5:
            return 'B'
        elif plr >= 1.2:
            return 'C'
        else:
            return 'D'

    @staticmethod
    def _calculate_overall_grade(scores):
        grades = [s['grade'] for s in scores.values()]
        grade_values = {'A': 4, 'B': 3, 'C': 2, 'D': 1}
        avg = np.mean([grade_values[g] for g in grades])

        if avg >= 3.5:
            return 'A'
        elif avg >= 2.5:
            return 'B'
        elif avg >= 1.5:
            return 'C'
        else:
            return 'D'

    @staticmethod
    def _get_recommendation(scores, overall_grade):
        if overall_grade == 'A':
            return "ä¼˜ç§€ç­–ç•¥,å¯ä»¥è€ƒè™‘å°èµ„é‡‘å®ç›˜æµ‹è¯•"
        elif overall_grade == 'B':
            return "è‰¯å¥½ç­–ç•¥,å»ºè®®è¿›ä¸€æ­¥ä¼˜åŒ–åå®ç›˜"
        elif overall_grade == 'C':
            return "ä¸€èˆ¬ç­–ç•¥,éœ€è¦æ˜¾è‘—æ”¹è¿›"
        else:
            return "ä¸å»ºè®®å®ç›˜,éœ€è¦é‡æ–°è®¾è®¡"

# ç¤ºä¾‹
evaluator = StrategyEvaluator()
evaluation = evaluator.evaluate(results)

print("\nç­–ç•¥ç»¼åˆè¯„ä¼°:")
print("=" * 70)
for metric, score in evaluation['scores'].items():
    status = "âœ“" if score['passed'] else "âœ—"
    print(f"{status} {metric}: {score['value']:.2%} (æ ‡å‡†: {score['criterion']:.2%}, è¯„çº§: {score['grade']})")

print(f"\nç»¼åˆè¯„çº§: {evaluation['overall_grade']}")
print(f"å»ºè®®: {evaluation['recommendation']}")
print("=" * 70)
```

### 12.3.3 ç¨³å®šæ€§æµ‹è¯•

```python
class RobustnessTest:
    """ç¨³å¥æ€§æµ‹è¯•"""

    @staticmethod
    def parameter_sensitivity(data, strategy_func, param_name, param_range):
        """
        å‚æ•°æ•æ„Ÿæ€§æµ‹è¯•

        å‚æ•°:
        data: DataFrame, æ•°æ®
        strategy_func: function, ç­–ç•¥å‡½æ•°
        param_name: str, å‚æ•°å
        param_range: list, å‚æ•°å–å€¼èŒƒå›´

        è¿”å›:
        DataFrame: å„å‚æ•°å€¼ä¸‹çš„è¡¨ç°
        """
        results = []

        for param_value in param_range:
            # è¿è¡Œç­–ç•¥
            signals = strategy_func(data, **{param_name: param_value})

            # ç®€å•è®¡ç®—æ”¶ç›Š(å®é™…åº”è¯¥å®Œæ•´å›æµ‹)
            returns = data['close'].pct_change()
            strategy_returns = (signals.shift(1) * returns).sum()

            results.append({
                param_name: param_value,
                'return': strategy_returns
            })

        return pd.DataFrame(results)

    @staticmethod
    def time_period_stability(data, strategy_func, period_length=60):
        """
        ä¸åŒæ—¶é—´æ®µç¨³å®šæ€§æµ‹è¯•

        å‚æ•°:
        data: DataFrame, æ•°æ®
        strategy_func: function, ç­–ç•¥å‡½æ•°
        period_length: int, æ¯ä¸ªæ—¶æ®µçš„é•¿åº¦

        è¿”å›:
        DataFrame: å„æ—¶æ®µè¡¨ç°
        """
        results = []
        num_periods = len(data) // period_length

        for i in range(num_periods):
            start = i * period_length
            end = start + period_length
            period_data = data.iloc[start:end]

            signals = strategy_func(period_data)
            returns = period_data['close'].pct_change()
            strategy_returns = (signals.shift(1) * returns).sum()

            results.append({
                'period': i + 1,
                'start_date': period_data.index[0],
                'end_date': period_data.index[-1],
                'return': strategy_returns
            })

        df = pd.DataFrame(results)

        # è®¡ç®—ç»Ÿè®¡é‡
        stats = {
            'mean_return': df['return'].mean(),
            'std_return': df['return'].std(),
            'positive_periods': (df['return'] > 0).sum(),
            'total_periods': len(df),
            'consistency': (df['return'] > 0).sum() / len(df)
        }

        return df, stats

# ç¤ºä¾‹
print("\nå‚æ•°æ•æ„Ÿæ€§æµ‹è¯•(ä¸åŒå‡çº¿å‘¨æœŸ):")
# è¿™é‡Œéœ€è¦ä¿®æ”¹strategyå‡½æ•°ä»¥æ¥å—å‚æ•°
def parameterized_strategy(data, short_window=5):
    signals = pd.Series(0, index=data.index)
    ma_short = data['close'].rolling(short_window).mean()
    ma_long = data['close'].rolling(20).mean()
    signals[ma_short > ma_long] = 1
    signals[ma_short < ma_long] = -1
    return signals

sensitivity = RobustnessTest.parameter_sensitivity(
    data, parameterized_strategy, 'short_window', range(3, 11)
)
print(sensitivity)

print("\nä¸åŒæ—¶é—´æ®µç¨³å®šæ€§æµ‹è¯•:")
period_results, period_stats = RobustnessTest.time_period_stability(
    data, simple_strategy, period_length=50
)
print(f"å¹³å‡æ”¶ç›Š: {period_stats['mean_return']:.2%}")
print(f"æ”¶ç›Šæ ‡å‡†å·®: {period_stats['std_return']:.2%}")
print(f"æ­£æ”¶ç›ŠæœŸæ•°: {period_stats['positive_periods']}/{period_stats['total_periods']}")
print(f"ä¸€è‡´æ€§: {period_stats['consistency']:.2%}")
```

---

## 12.4 ä»å›æµ‹åˆ°å®ç›˜ ğŸš€

### 12.4.1 æ¨¡æ‹Ÿäº¤æ˜“ (Paper Trading)

**åœ¨çœŸå®å¸‚åœºç¯å¢ƒä¸­ç”¨è™šæ‹Ÿèµ„é‡‘æµ‹è¯•ç­–ç•¥ã€‚**

```python
class PaperTradingAccount:
    """æ¨¡æ‹Ÿäº¤æ˜“è´¦æˆ·"""

    def __init__(self, initial_capital, commission_rate=0.0003):
        """
        å‚æ•°:
        initial_capital: float, åˆå§‹èµ„é‡‘
        commission_rate: float, æ‰‹ç»­è´¹ç‡
        """
        self.initial_capital = initial_capital
        self.cash = initial_capital
        self.commission_rate = commission_rate
        self.positions = {}  # {symbol: {'shares': int, 'avg_price': float}}
        self.orders = []
        self.trades = []

    def place_order(self, symbol, shares, price, order_type='BUY'):
        """
        ä¸‹å•

        å‚æ•°:
        symbol: str, æ ‡çš„ä»£ç 
        shares: int, æ•°é‡
        price: float, ä»·æ ¼
        order_type: str, 'BUY' æˆ– 'SELL'

        è¿”å›:
        dict: è®¢å•ä¿¡æ¯
        """
        order = {
            'symbol': symbol,
            'shares': shares,
            'price': price,
            'type': order_type,
            'time': pd.Timestamp.now(),
            'status': 'PENDING'
        }
        self.orders.append(order)
        return order

    def execute_order(self, order, actual_price=None):
        """
        æ‰§è¡Œè®¢å•

        å‚æ•°:
        order: dict, è®¢å•
        actual_price: float, å®é™…æˆäº¤ä»·(æ¨¡æ‹Ÿæ»‘ç‚¹)

        è¿”å›:
        bool: æ˜¯å¦æˆåŠŸ
        """
        if actual_price is None:
            actual_price = order['price']

        symbol = order['symbol']
        shares = order['shares']
        order_type = order['type']

        if order_type == 'BUY':
            cost = shares * actual_price
            commission = cost * self.commission_rate

            if self.cash >= cost + commission:
                self.cash -= (cost + commission)

                if symbol not in self.positions:
                    self.positions[symbol] = {'shares': 0, 'avg_price': 0}

                # æ›´æ–°å¹³å‡æˆæœ¬
                current_shares = self.positions[symbol]['shares']
                current_avg_price = self.positions[symbol]['avg_price']
                new_shares = current_shares + shares
                new_avg_price = (current_shares * current_avg_price + cost) / new_shares

                self.positions[symbol]['shares'] = new_shares
                self.positions[symbol]['avg_price'] = new_avg_price

                order['status'] = 'FILLED'
                self.trades.append({
                    'type': 'BUY',
                    'symbol': symbol,
                    'shares': shares,
                    'price': actual_price,
                    'commission': commission,
                    'time': pd.Timestamp.now()
                })
                return True
            else:
                order['status'] = 'REJECTED'
                return False

        elif order_type == 'SELL':
            if symbol in self.positions and self.positions[symbol]['shares'] >= shares:
                revenue = shares * actual_price
                commission = revenue * self.commission_rate
                self.cash += (revenue - commission)

                self.positions[symbol]['shares'] -= shares
                if self.positions[symbol]['shares'] == 0:
                    del self.positions[symbol]

                order['status'] = 'FILLED'
                self.trades.append({
                    'type': 'SELL',
                    'symbol': symbol,
                    'shares': shares,
                    'price': actual_price,
                    'commission': commission,
                    'time': pd.Timestamp.now()
                })
                return True
            else:
                order['status'] = 'REJECTED'
                return False

    def get_portfolio_value(self, market_prices):
        """
        è·å–ç»„åˆæ€»å€¼

        å‚æ•°:
        market_prices: dict, {symbol: current_price}

        è¿”å›:
        float: ç»„åˆæ€»å€¼
        """
        holdings_value = sum(
            pos['shares'] * market_prices.get(symbol, pos['avg_price'])
            for symbol, pos in self.positions.items()
        )
        return self.cash + holdings_value

    def get_account_summary(self, market_prices):
        """è·å–è´¦æˆ·æ‘˜è¦"""
        total_value = self.get_portfolio_value(market_prices)
        return {
            'cash': self.cash,
            'holdings_value': total_value - self.cash,
            'total_value': total_value,
            'return': (total_value - self.initial_capital) / self.initial_capital,
            'positions': self.positions.copy(),
            'num_trades': len(self.trades)
        }

# ç¤ºä¾‹
account = PaperTradingAccount(initial_capital=100000)

# ä¸‹å•ä¹°å…¥
order1 = account.place_order('000001', shares=1000, price=10.0, order_type='BUY')
account.execute_order(order1, actual_price=10.05)  # æ¨¡æ‹Ÿæ»‘ç‚¹

# æŸ¥çœ‹è´¦æˆ·
market_prices = {'000001': 10.50}
summary = account.get_account_summary(market_prices)
print("\næ¨¡æ‹Ÿäº¤æ˜“è´¦æˆ·æ‘˜è¦:")
for key, value in summary.items():
    if key != 'positions':
        print(f"{key}: {value}")
```

### 12.4.2 å®ç›˜å‰çš„æ£€æŸ¥æ¸…å•

```python
class PreLiveTradingChecklist:
    """å®ç›˜å‰æ£€æŸ¥æ¸…å•"""

    def __init__(self):
        self.checklist = {
            'ç­–ç•¥éªŒè¯': [
                'å›æµ‹æ—¶é—´è·¨åº¦â‰¥3å¹´',
                'åŒ…å«å¤šç§å¸‚åœºç¯å¢ƒ(ç‰›å¸‚/ç†Šå¸‚/éœ‡è¡)',
                'æ ·æœ¬å¤–éªŒè¯é€šè¿‡',
                'å‚æ•°ç¨³å¥æ€§æµ‹è¯•é€šè¿‡',
                'äº¤æ˜“æˆæœ¬å·²å……åˆ†è€ƒè™‘',
            ],
            'é£é™©ç®¡ç†': [
                'æ˜ç¡®æœ€å¤§å•ç¬”æŸå¤±é™é¢',
                'æ˜ç¡®æœ€å¤§å›æ’¤å®¹å¿åº¦',
                'è®¾ç½®äº†æ­¢æŸæœºåˆ¶',
                'ä»“ä½ç®¡ç†è§„åˆ™æ¸…æ™°',
                'å»ºç«‹äº†äº¤æ˜“æš‚åœæœºåˆ¶',
            ],
            'æŠ€æœ¯å‡†å¤‡': [
                'äº¤æ˜“æ¥å£æµ‹è¯•å®Œæˆ',
                'è®¢å•æ‰§è¡Œæµç¨‹éªŒè¯',
                'å¼‚å¸¸å¤„ç†æœºåˆ¶å®Œå–„',
                'æ—¥å¿—è®°å½•ç³»ç»Ÿå°±ç»ª',
                'ç›‘æ§å‘Šè­¦ç³»ç»Ÿéƒ¨ç½²',
            ],
            'èµ„é‡‘å‡†å¤‡': [
                'ä½¿ç”¨å¯æ‰¿å—æŸå¤±çš„é—²ç½®èµ„é‡‘',
                'é¢„ç•™è‡³å°‘6ä¸ªæœˆç”Ÿæ´»è´¹',
                'ä¸ä½¿ç”¨æ æ†æˆ–ä¸¥æ ¼æ§åˆ¶æ æ†',
                'ä»å°èµ„é‡‘å¼€å§‹(â‰¤æ€»èµ„é‡‘10%)',
            ],
            'å¿ƒç†å‡†å¤‡': [
                'ç†è§£ç­–ç•¥çš„é£é™©ç‰¹å¾',
                'æ¥å—æ­£å¸¸èŒƒå›´å†…çš„å›æ’¤',
                'ä¸æœŸæœ›ä¸€å¤œæš´å¯Œ',
                'å‡†å¤‡å¥½é•¿æœŸåšæŒ',
                'èƒ½å¤Ÿæ‰¿å—è¿ç»­äºæŸçš„å‹åŠ›',
            ]
        }

    def display_checklist(self):
        """æ˜¾ç¤ºæ£€æŸ¥æ¸…å•"""
        print("\n" + "=" * 70)
        print("å®ç›˜å‰æ£€æŸ¥æ¸…å•")
        print("=" * 70)

        for category, items in self.checklist.items():
            print(f"\nã€{category}ã€‘")
            for i, item in enumerate(items, 1):
                print(f"  {i}. [ ] {item}")

        print("\n" + "=" * 70)
        print("è¯·ç¡®ä¿æ‰€æœ‰é¡¹ç›®éƒ½å·²å®Œæˆæ£€æŸ¥å¹¶æ‰“å‹¾!")
        print("=" * 70)

checklist = PreLiveTradingChecklist()
checklist.display_checklist()
```

### 12.4.3 å®ç›˜ç›‘æ§

```python
class LiveTradingMonitor:
    """å®ç›˜ç›‘æ§ç³»ç»Ÿ"""

    def __init__(self, strategy_name):
        """
        å‚æ•°:
        strategy_name: str, ç­–ç•¥åç§°
        """
        self.strategy_name = strategy_name
        self.alerts = []

    def check_performance(self, current_results, expected_results):
        """
        æ£€æŸ¥å®ç›˜è¡¨ç°æ˜¯å¦ä¸é¢„æœŸä¸€è‡´

        å‚æ•°:
        current_results: dict, å½“å‰å®ç›˜ç»“æœ
        expected_results: dict, å›æµ‹é¢„æœŸç»“æœ

        è¿”å›:
        list: å‘Šè­¦ä¿¡æ¯
        """
        alerts = []

        # 1. æ”¶ç›Šç‡åå·®
        return_diff = current_results['return'] - expected_results['return']
        if abs(return_diff) > 0.05:  # åå·®è¶…è¿‡5%
            alerts.append({
                'level': 'WARNING',
                'metric': 'return',
                'message': f"æ”¶ç›Šç‡åå·®è¾ƒå¤§: å®é™…{current_results['return']:.2%} "
                          f"vs é¢„æœŸ{expected_results['return']:.2%}"
            })

        # 2. èƒœç‡åå·®
        if 'win_rate' in current_results and 'win_rate' in expected_results:
            wr_diff = current_results['win_rate'] - expected_results['win_rate']
            if abs(wr_diff) > 0.1:  # åå·®è¶…è¿‡10%
                alerts.append({
                    'level': 'WARNING',
                    'metric': 'win_rate',
                    'message': f"èƒœç‡åå·®è¾ƒå¤§: å®é™…{current_results['win_rate']:.2%} "
                              f"vs é¢„æœŸ{expected_results['win_rate']:.2%}"
                })

        # 3. å›æ’¤æ£€æŸ¥
        if current_results.get('max_drawdown', 0) < -0.15:
            alerts.append({
                'level': 'CRITICAL',
                'metric': 'max_drawdown',
                'message': f"å›æ’¤è¿‡å¤§: {current_results['max_drawdown']:.2%}"
            })

        # 4. äº¤æ˜“é¢‘ç‡
        if 'num_trades' in current_results and 'num_trades' in expected_results:
            trade_ratio = current_results['num_trades'] / max(expected_results['num_trades'], 1)
            if trade_ratio < 0.5 or trade_ratio > 2.0:
                alerts.append({
                    'level': 'WARNING',
                    'metric': 'num_trades',
                    'message': f"äº¤æ˜“é¢‘ç‡å¼‚å¸¸: å®é™…{current_results['num_trades']} "
                              f"vs é¢„æœŸ{expected_results['num_trades']}"
                })

        self.alerts.extend(alerts)
        return alerts

    def generate_daily_report(self, account_summary, trades_today):
        """
        ç”Ÿæˆæ—¥æŠ¥

        å‚æ•°:
        account_summary: dict, è´¦æˆ·æ‘˜è¦
        trades_today: list, ä»Šæ—¥äº¤æ˜“

        è¿”å›:
        str: æŠ¥å‘Šå†…å®¹
        """
        report = f"""
{'=' * 60}
{self.strategy_name} - æ¯æ—¥ç›‘æ§æŠ¥å‘Š
æ—¥æœŸ: {pd.Timestamp.now().strftime('%Y-%m-%d')}
{'=' * 60}

ã€è´¦æˆ·æ¦‚å†µã€‘
æ€»èµ„äº§: {account_summary['total_value']:,.2f}å…ƒ
ç°é‡‘: {account_summary['cash']:,.2f}å…ƒ
æŒä»“å¸‚å€¼: {account_summary['holdings_value']:,.2f}å…ƒ
ç´¯è®¡æ”¶ç›Šç‡: {account_summary['return']:.2%}

ã€ä»Šæ—¥äº¤æ˜“ã€‘
äº¤æ˜“ç¬”æ•°: {len(trades_today)}
"""
        for trade in trades_today:
            report += f"  {trade['type']} {trade['symbol']} "
            report += f"{trade['shares']}è‚¡ @ {trade['price']:.2f}å…ƒ\n"

        if self.alerts:
            report += "\nã€å‘Šè­¦ä¿¡æ¯ã€‘\n"
            for alert in self.alerts:
                report += f"  [{alert['level']}] {alert['metric']}: {alert['message']}\n"
        else:
            report += "\nã€å‘Šè­¦ä¿¡æ¯ã€‘\n  æ— å‘Šè­¦\n"

        report += "=" * 60

        return report

# ç¤ºä¾‹
monitor = LiveTradingMonitor(strategy_name="åŒå‡çº¿ç­–ç•¥")

# æ£€æŸ¥è¡¨ç°
current = {'return': 0.08, 'win_rate': 0.52, 'max_drawdown': -0.12, 'num_trades': 25}
expected = {'return': 0.10, 'win_rate': 0.55, 'max_drawdown': -0.15, 'num_trades': 30}

alerts = monitor.check_performance(current, expected)
if alerts:
    print("\nå‘ç°å‘Šè­¦:")
    for alert in alerts:
        print(f"[{alert['level']}] {alert['message']}")

# ç”Ÿæˆæ—¥æŠ¥
account_summary = {
    'total_value': 108000,
    'cash': 50000,
    'holdings_value': 58000,
    'return': 0.08
}

trades_today = [
    {'type': 'BUY', 'symbol': '000001', 'shares': 500, 'price': 10.2},
    {'type': 'SELL', 'symbol': '000002', 'shares': 300, 'price': 15.8}
]

report = monitor.generate_daily_report(account_summary, trades_today)
print(report)
```

### 12.4.4 å®ç›˜å¸¸è§é—®é¢˜

```python
class CommonLiveTradingIssues:
    """å®ç›˜å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ"""

    @staticmethod
    def get_issues_and_solutions():
        issues = {
            'æ»‘ç‚¹è¶…å‡ºé¢„æœŸ': {
                'description': 'å®é™…æˆäº¤ä»·ä¸é¢„æœŸä»·å·®è¾ƒå¤§',
                'causes': [
                    'æµåŠ¨æ€§ä¸è¶³',
                    'å¸‚ä»·å•ä½¿ç”¨ä¸å½“',
                    'å¸‚åœºæ³¢åŠ¨å‰§çƒˆ'
                ],
                'solutions': [
                    'ä½¿ç”¨é™ä»·å•',
                    'åˆ†æ‰¹å»ºä»“/å¹³ä»“',
                    'é¿å¼€å¼€ç›˜å’Œæ”¶ç›˜',
                    'é€‰æ‹©æµåŠ¨æ€§å¥½çš„æ ‡çš„'
                ]
            },

            'ç­–ç•¥å¤±æ•ˆ': {
                'description': 'å®ç›˜è¡¨ç°è¿œä¸å¦‚å›æµ‹',
                'causes': [
                    'è¿‡æ‹Ÿåˆ',
                    'å¸‚åœºç¯å¢ƒæ”¹å˜',
                    'å›æµ‹é™·é˜±æœªé¿å…'
                ],
                'solutions': [
                    'åœæ­¢äº¤æ˜“,é‡æ–°è¯„ä¼°',
                    'æ£€æŸ¥ç­–ç•¥é€»è¾‘',
                    'æ ·æœ¬å¤–éªŒè¯',
                    'å¸‚åœºé€‚åº”æ€§è°ƒæ•´'
                ]
            },

            'æƒ…ç»ªåŒ–äº¤æ˜“': {
                'description': 'æœªæŒ‰ç­–ç•¥æ‰§è¡Œ,æƒ…ç»ªå¹²æ‰°',
                'causes': [
                    'è¿ç»­äºæŸå‹åŠ›',
                    'è´ªå©ªè¿½æ±‚æ›´é«˜æ”¶ç›Š',
                    'ææƒ§é”™è¿‡æœºä¼š'
                ],
                'solutions': [
                    'å®Œå…¨è‡ªåŠ¨åŒ–æ‰§è¡Œ',
                    'è®¾ç½®å¼ºåˆ¶ä¼‘æ¯æœŸ',
                    'é™ä½ä»“ä½ç¼“è§£å‹åŠ›',
                    'è®°å½•äº¤æ˜“æ—¥å¿—åæ€'
                ]
            },

            'æŠ€æœ¯æ•…éšœ': {
                'description': 'ç³»ç»Ÿå´©æºƒã€æ–­ç½‘ç­‰',
                'causes': [
                    'ä»£ç bug',
                    'ç½‘ç»œä¸­æ–­',
                    'æœåŠ¡å™¨æ•…éšœ'
                ],
                'solutions': [
                    'å»ºç«‹å¤‡ç”¨ç³»ç»Ÿ',
                    'è®¾ç½®äººå·¥ç›‘æ§',
                    'ç´§æ€¥å¹³ä»“é¢„æ¡ˆ',
                    'å¼‚å¸¸æƒ…å†µå‘Šè­¦'
                ]
            },

            'èµ„é‡‘ç®¡ç†å¤±æ§': {
                'description': 'äºæŸè¶…è¿‡é¢„æœŸ,èµ„é‡‘å¤§å¹…ç¼©æ°´',
                'causes': [
                    'æœªä¸¥æ ¼æ­¢æŸ',
                    'ä»“ä½è¿‡é‡',
                    'è¿ç»­åŠ ä»“æ‘Šå¹³'
                ],
                'solutions': [
                    'ä¸¥æ ¼æ‰§è¡Œæ­¢æŸ',
                    'éµå®ˆä»“ä½é™åˆ¶',
                    'å¯åŠ¨æš‚åœæœºåˆ¶',
                    'åŠæ—¶æ­¢æŸè®¤é”™'
                ]
            }
        }

        return issues

    @staticmethod
    def display_issues():
        issues = CommonLiveTradingIssues.get_issues_and_solutions()

        print("\n" + "=" * 70)
        print("å®ç›˜å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ")
        print("=" * 70)

        for issue_name, details in issues.items():
            print(f"\nã€{issue_name}ã€‘")
            print(f"é—®é¢˜æè¿°: {details['description']}")

            print("\nå¯èƒ½åŸå› :")
            for cause in details['causes']:
                print(f"  â€¢ {cause}")

            print("\nè§£å†³æ–¹æ¡ˆ:")
            for solution in details['solutions']:
                print(f"  âœ“ {solution}")

        print("\n" + "=" * 70)

CommonLiveTradingIssues.display_issues()
```

---

## 12.5 æœ¬ç« å°ç»“ ğŸ“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **å›æµ‹æ˜¯ç­–ç•¥éªŒè¯çš„åŸºç¡€**
   - ä½¿ç”¨å†å²æ•°æ®æ¨¡æ‹Ÿäº¤æ˜“
   - è¯„ä¼°ç­–ç•¥çš„ç›ˆåˆ©èƒ½åŠ›å’Œé£é™©ç‰¹å¾
   - æ˜¯å®ç›˜å‰çš„å¿…ç»æ­¥éª¤

2. **è­¦æƒ•å›æµ‹é™·é˜±**
   - å‰è§†åå·®ï¼šä¸èƒ½ä½¿ç”¨æœªæ¥ä¿¡æ¯
   - å¹¸å­˜è€…åå·®ï¼šè¦åŒ…å«é€€å¸‚æ ‡çš„
   - è¿‡åº¦æ‹Ÿåˆï¼šç­–ç•¥è¿‡äºå¤æ‚å®¹æ˜“å¤±æ•ˆ
   - äº¤æ˜“æˆæœ¬ï¼šå¿…é¡»å……åˆ†è€ƒè™‘
   - æµåŠ¨æ€§ï¼šè¦è¯„ä¼°å®é™…å¯æˆäº¤æ€§

3. **è¯†åˆ«å¥½ç­–ç•¥çš„æ–¹æ³•**
   - æ ·æœ¬å¤–éªŒè¯(è®­ç»ƒé›†/æµ‹è¯•é›†åˆ†ç¦»)
   - æ»šåŠ¨ä¼˜åŒ–åˆ†æ
   - ç»¼åˆæŒ‡æ ‡è¯„ä¼°(å¤æ™®ã€å›æ’¤ã€èƒœç‡ç­‰)
   - å‚æ•°ç¨³å¥æ€§æµ‹è¯•
   - ä¸åŒæ—¶æœŸè¡¨ç°ä¸€è‡´æ€§

4. **ä»å›æµ‹åˆ°å®ç›˜çš„è¿‡æ¸¡**
   - å…ˆè¿›è¡Œæ¨¡æ‹Ÿäº¤æ˜“(Paper Trading)
   - å®Œæˆå®ç›˜å‰æ£€æŸ¥æ¸…å•
   - ä»å°èµ„é‡‘å¼€å§‹
   - å»ºç«‹ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
   - å‡†å¤‡å¥½åº”å¯¹å¸¸è§é—®é¢˜

### å›æµ‹ä¸å®ç›˜çš„å·®å¼‚

| æ–¹é¢ | å›æµ‹ | å®ç›˜ |
|-----|------|------|
| **æ•°æ®** | å®Œç¾çš„å†å²æ•°æ® | å®æ—¶æ•°æ®å¯èƒ½æœ‰å»¶è¿Ÿæˆ–é”™è¯¯ |
| **æ‰§è¡Œ** | å‡è®¾å®Œç¾æ‰§è¡Œ | å­˜åœ¨æ»‘ç‚¹ã€éƒ¨åˆ†æˆäº¤ç­‰ |
| **æˆæœ¬** | å¯ä»¥ç²¾ç¡®è®¾å®š | å®é™…æˆæœ¬å¯èƒ½æ³¢åŠ¨ |
| **å¿ƒç†** | æ— å‹åŠ› | çœŸé‡‘ç™½é“¶çš„å¿ƒç†å‹åŠ› |
| **ä¼˜åŒ–** | å¯ä»¥åå¤è°ƒè¯• | æ¯ç¬”äº¤æ˜“éƒ½æ˜¯çœŸå®çš„ |
| **æ—¶é—´** | å¿«é€Ÿå®Œæˆ | éœ€è¦å®æ—¶ç­‰å¾… |

### å®ç”¨å»ºè®® ğŸ’¡

1. **ä¿æŒè°¦é€Š**
   - å›æµ‹å†å®Œç¾ä¹Ÿä¸ä»£è¡¨å®ç›˜ä¸€å®šæˆåŠŸ
   - å¸‚åœºåœ¨ä¸æ–­å˜åŒ–,æ²¡æœ‰æ°¸è¿œæœ‰æ•ˆçš„ç­–ç•¥
   - æŒç»­å­¦ä¹ å’Œé€‚åº”æ˜¯å…³é”®

2. **å°æ­¥å¿«è·‘**
   - ä»å°èµ„é‡‘å¼€å§‹å®ç›˜
   - é€æ­¥å¢åŠ æŠ•å…¥
   - æ¯æ¬¡å¤±è´¥éƒ½æ˜¯å­¦ä¹ æœºä¼š

3. **ä¸¥æ ¼çºªå¾‹**
   - åˆ¶å®šè§„åˆ™å¹¶ä¸¥æ ¼æ‰§è¡Œ
   - ä¸è¦å› ä¸ºçŸ­æœŸæ³¢åŠ¨æ”¹å˜ç­–ç•¥
   - å®šæœŸè¯„ä¼°,ç†æ€§è°ƒæ•´

4. **é£é™©ç¬¬ä¸€**
   - æ°¸è¿œæŠŠé£é™©æ§åˆ¶æ”¾åœ¨é¦–ä½
   - ä¿æŠ¤èµ„é‡‘æ¯”è¿½æ±‚æ”¶ç›Šæ›´é‡è¦
   - æ´»ä¸‹æ¥æ‰æœ‰æœºä¼šç›ˆåˆ©

---

**æ­å–œä½ å®ŒæˆçŸ¥è¯†ç¯‡ï¼** ğŸ‰

é€šè¿‡ç¬¬åç« åˆ°ç¬¬åäºŒç« ,ä½ å·²ç»ç³»ç»Ÿå­¦ä¹ äº†é‡åŒ–ç­–ç•¥çš„åŸºç¡€çŸ¥è¯†ã€é£é™©ç®¡ç†æ–¹æ³•,ä»¥åŠå›æµ‹ä¸å®ç›˜çš„å®Œæ•´æµç¨‹ã€‚æ¥ä¸‹æ¥,æˆ‘ä»¬å°†è¿›å…¥**æŠ€æœ¯ç¯‡**,æ·±å…¥å­¦ä¹ Pythonç¼–ç¨‹ã€æ•°æ®åˆ†æã€å¯è§†åŒ–ç­‰é‡åŒ–äº¤æ˜“çš„å¿…å¤‡æŠ€æœ¯æŠ€èƒ½ã€‚

**ä¸‹ä¸€ç« é¢„å‘Š** ğŸ‘‰

ç¬¬åä¸‰ç« ã€ŠPythonç¼–ç¨‹åŸºç¡€ã€‹å°†å¸¦ä½ ä»é›¶å¼€å§‹å­¦ä¹ Python,ä¸ºåç»­çš„é‡åŒ–äº¤æ˜“å®è·µæ‰“ä¸‹åšå®çš„ç¼–ç¨‹åŸºç¡€ã€‚å³ä½¿ä½ å®Œå…¨æ²¡æœ‰ç¼–ç¨‹ç»éªŒ,ä¹Ÿèƒ½é€šè¿‡ç³»ç»Ÿå­¦ä¹ æŒæ¡è¿™é—¨å¼ºå¤§çš„å·¥å…·ï¼
