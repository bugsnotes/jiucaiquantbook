# 第七章：交易平台与接口

有了数据,开发了策略,下一步就是实盘交易。本章详细介绍主流量化交易平台与API接口,重点讲解QMT量化交易系统的使用。

---

## 7.1 交易接口概览

### 什么是交易接口

**定义**:
```
交易接口 = 程序化下单的通道

作用:
- 连接策略程序与券商交易系统
- 自动执行买卖指令
- 实时获取账户持仓
- 查询委托成交

本质:
- 把手动点击变成代码调用
- 实现策略自动化执行
```

### 交易接口分类

**1. 按提供方分类**:
```
券商官方接口:
- QMT(迅投)
- PTrade(国金)
- TTS(华宝)
优点: 稳定,合规
缺点: 需要对应券商账户

第三方平台:
- 掘金量化
- vn.py
- RQAlpha
优点: 跨券商
缺点: 可能有中间层风险

开源框架:
- vn.py
- easytrader
优点: 免费,灵活
缺点: 需要技术能力
```

**2. 按速度分类**:
```
普通接口:
- 延迟: 100-500ms
- 适合: 日内、日线策略

低延迟接口:
- 延迟: <50ms
- 适合: 高频策略
- 价格: 贵

超低延迟:
- 延迟: <10ms
- 适合: 机构高频
- 价格: 极贵
```

**3. 按功能分类**:
```
基础接口:
- 下单、撤单
- 查询持仓
- 查询委托

高级接口:
- 算法单
- 篮子交易
- 期权交易
- 融资融券
```

### 主流平台对比

| 平台 | 类型 | 成本 | 难度 | 适合人群 |
|------|------|------|------|----------|
| **QMT** | 券商官方 | 免费 | 中 | 个人投资者 |
| **掘金量化** | 第三方 | 付费 | 低 | 初学者 |
| **vn.py** | 开源 | 免费 | 高 | 专业开发者 |
| **聚宽/米筐** | 平台 | 付费 | 低 | 策略研究者 |
| **东财/同花顺** | 券商 | 免费 | 中 | 个人用户 |

### 选择建议

**个人投资者**:
```
首选: QMT
理由:
- 免费
- 券商官方,稳定
- 功能完善
- Python接口友好
- 支持券商多(国金、中泰、兴业等)
```

**专业开发者**:
```
首选: vn.py
理由:
- 开源,可定制
- 支持多市场(股票、期货、期权)
- 社区活跃
- 完全免费
```

**初学者**:
```
首选: 掘金量化 or 聚宽
理由:
- 图形化界面
- 上手简单
- 文档完善
- 有技术支持
```

---

## 7.2 QMT量化交易系统 (⭐重点推荐)

### 7.2.1 QMT简介

**什么是QMT**:
```
QMT = 迅投量化交易系统

开发商: 迅投QMT团队
定位: 面向个人的专业量化交易平台

特点:
- 券商官方支持
- 完全免费
- Python接口
- 功能强大
- 稳定可靠

支持券商(部分):
- 国金证券
- 中泰证券
- 兴业证券
- 东兴证券
- 华西证券
- 中信建投
- ...30+券商
```

**QMT组成部分**:
```
1. QMT客户端(XtQuant)
   - 图形化界面
   - 策略编写IDE
   - 回测模块
   - 实盘交易

2. Python SDK
   - xtquant库
   - 行情接口
   - 交易接口
   - 数据接口

3. MiniQMT
   - 轻量级版本
   - 纯交易功能
   - 适合策略执行
```

### 7.2.2 QMT安装与配置

#### 下载安装

**Step 1: 开户**:
```
1. 在支持QMT的券商开户
   推荐: 国金证券、中泰证券

2. 联系客户经理或客服
   说明: 需要开通QMT权限

3. 获取QMT下载链接
   每个券商的QMT版本不同
```

**Step 2: 下载QMT**:
```
方式1: 券商官网下载
- 登录券商官网
- 找到QMT下载页面
- 下载对应版本

方式2: 迅投官网
- 访问: www.xtquant.com
- 根据券商选择版本
```

**Step 3: 安装**:
```
1. 运行安装程序
2. 选择安装路径(建议默认)
3. 完成安装
4. 首次运行会自动更新
```

#### 配置Python环境

**Step 1: 安装xtquant库**:
```python
# QMT自带Python环境,需要在QMT的Python中安装

# 找到QMT安装目录,例如:
# C:\Program Files\国金QMT交易端\userdata_mini\

# 使用QMT自带的pip安装
# 在QMT目录下找到Python文件夹
cd C:\Program Files\国金QMT交易端\bin.x64\Lib\site-packages

# 或者在QMT的Python控制台直接导入
import xtquant

# 验证
print(xtquant.__version__)
```

**Step 2: 外部Python调用**(推荐):
```python
# 在自己的Python环境中安装xtquant

# 方法1: pip安装(如果可用)
pip install xtquant

# 方法2: 添加路径
import sys
sys.path.append(r'C:\Program Files\国金QMT交易端\bin.x64')

import xtquant as xt
```

#### 登录配置

**配置交易账户**:
```python
from xtquant import xttrader

# 初始化
xttrader.connect()

# 登录账户(在QMT客户端中配置)
# 账户信息存储在QMT配置文件中
# 首次使用需要在QMT客户端手动登录一次

# 获取账户列表
accounts = xttrader.get_account_list()
print("可用账户:", accounts)

# 使用账户
account_id = accounts[0]
```

### 7.2.3 QMT核心功能

#### 行情接口

**1. 获取实时行情**:
```python
from xtquant import xtdata

# 订阅行情
stocks = ['000001.SZ', '600000.SH', '600519.SH']
xtdata.subscribe_quote(stocks, period='1d', count=-1)

# 获取最新行情
quotes = xtdata.get_market_data(
    field_list=['open', 'high', 'low', 'close', 'volume'],
    stock_list=stocks,
    period='1d',
    count=10  # 最近10个交易日
)

print(quotes)
# 返回格式: {股票代码: DataFrame}
```

**2. 获取K线数据**:
```python
# 日线
df = xtdata.get_market_data(
    field_list=['open', 'high', 'low', 'close', 'volume', 'amount'],
    stock_list=['000001.SZ'],
    period='1d',
    start_time='20230101',
    end_time='20231231'
)

# 分钟线
df_min = xtdata.get_market_data(
    field_list=['close'],
    stock_list=['000001.SZ'],
    period='1m',  # 1m, 5m, 15m, 30m, 60m
    count=100
)

# Tick数据(逐笔)
ticks = xtdata.get_full_tick(['000001.SZ'])
```

**3. 获取股票列表**:
```python
# 全部A股
all_stocks = xtdata.get_stock_list_in_sector('沪深A股')

# 沪深300
hs300 = xtdata.get_stock_list_in_sector('沪深300')

# 行业板块
bank_stocks = xtdata.get_stock_list_in_sector('银行')

print(f"沪深300成分股数量: {len(hs300)}")
```

**4. 获取财务数据**:
```python
# 财务指标
financial = xtdata.get_financial_data(
    stock_list=['000001.SZ'],
    table_list=['FDMTFinancialIndex'],  # 财务指标表
    start_time='20200101',
    end_time='20231231'
)

# 包含: PE, PB, ROE, 负债率等
```

#### 交易接口

**1. 下单**:
```python
from xtquant import xttrader

# 连接
xttrader.connect()

# 获取账户
account = xttrader.get_account_list()[0]

# 买入
order = xttrader.order_stock(
    account=account,
    stock_code='000001.SZ',
    order_type=xttrader.FIX_PRICE,  # 限价单
    order_volume=100,                # 数量(股)
    price=12.50,                     # 价格
    strategy_name='测试策略',
    order_remark='买入测试'
)

print(f"委托编号: {order}")

# 卖出
order_sell = xttrader.order_stock(
    account=account,
    stock_code='000001.SZ',
    order_type=xttrader.FIX_PRICE,
    order_volume=-100,  # 负数表示卖出
    price=12.80,
    strategy_name='测试策略'
)
```

**2. 订单类型**:
```python
# 限价单
xttrader.FIX_PRICE  # 指定价格

# 市价单
xttrader.MARKET_PRICE  # 市价成交

# 五档即成剩撤
xttrader.FIVE_LEVEL_CANCEL

# 五档即成剩转限价
xttrader.FIVE_LEVEL_TO_LIMIT
```

**3. 撤单**:
```python
# 撤销指定委托
xttrader.cancel_order(account, order_id)

# 撤销全部委托
all_orders = xttrader.query_orders(account)
for order in all_orders:
    if order['order_status'] == xttrader.ORDER_UNREPORTED:
        xttrader.cancel_order(account, order['order_id'])
```

**4. 查询持仓**:
```python
# 获取当前持仓
positions = xttrader.query_stock_positions(account)

for pos in positions:
    print(f"股票: {pos.stock_code}")
    print(f"数量: {pos.volume}")
    print(f"可用: {pos.can_use_volume}")
    print(f"成本价: {pos.avg_price}")
    print(f"当前价: {pos.last_price}")
    print(f"盈亏: {pos.unrealized_pnl}")
    print("---")
```

**5. 查询资金**:
```python
# 资金账户
asset = xttrader.query_stock_asset(account)

print(f"总资产: {asset.total_asset}")
print(f"可用资金: {asset.cash}")
print(f"冻结资金: {asset.frozen_cash}")
print(f"持仓市值: {asset.market_value}")
print(f"总盈亏: {asset.unrealized_pnl}")
```

**6. 查询委托**:
```python
# 查询今日委托
orders = xttrader.query_orders(account)

for order in orders:
    print(f"委托编号: {order.order_id}")
    print(f"股票: {order.stock_code}")
    print(f"方向: {'买入' if order.order_volume > 0 else '卖出'}")
    print(f"委托价: {order.price}")
    print(f"委托量: {abs(order.order_volume)}")
    print(f"成交量: {order.traded_volume}")
    print(f"状态: {order.order_status}")
    print("---")
```

**7. 查询成交**:
```python
# 查询成交记录
trades = xttrader.query_trades(account)

for trade in trades:
    print(f"股票: {trade.stock_code}")
    print(f"成交价: {trade.traded_price}")
    print(f"成交量: {trade.traded_volume}")
    print(f"成交时间: {trade.traded_time}")
```

### 7.2.4 QMT完整策略示例

#### 示例1: 简单双均线策略

```python
"""
QMT双均线自动交易策略
策略逻辑: MA5上穿MA20买入, 下穿卖出
"""

from xtquant import xttrader, xtdata
import pandas as pd
import time

# ==================== 配置区 ====================
STOCK_CODE = '000001.SZ'      # 交易股票
CAPITAL = 100000              # 初始资金
POSITION_RATIO = 0.8          # 仓位比例
CHECK_INTERVAL = 60           # 检查间隔(秒)

# ==================== 初始化 ====================
# 连接
xttrader.connect()
account = xttrader.get_account_list()[0]

# 订阅行情
xtdata.subscribe_quote([STOCK_CODE], period='1d')

print("策略启动成功!")
print(f"交易账户: {account}")
print(f"目标股票: {STOCK_CODE}")

# ==================== 策略函数 ====================
def calculate_signals():
    """计算交易信号"""
    # 获取最近30天数据
    data = xtdata.get_market_data(
        field_list=['close'],
        stock_list=[STOCK_CODE],
        period='1d',
        count=30
    )

    df = data[STOCK_CODE]

    # 计算均线
    df['ma5'] = df['close'].rolling(5).mean()
    df['ma20'] = df['close'].rolling(20).mean()

    # 获取最新两个数据点
    last = df.iloc[-1]
    prev = df.iloc[-2]

    # 判断信号
    if prev['ma5'] <= prev['ma20'] and last['ma5'] > last['ma20']:
        return 'BUY', last['close']
    elif prev['ma5'] >= prev['ma20'] and last['ma5'] < last['ma20']:
        return 'SELL', last['close']
    else:
        return 'HOLD', last['close']

def get_position():
    """获取当前持仓"""
    positions = xttrader.query_stock_positions(account)
    for pos in positions:
        if pos.stock_code == STOCK_CODE:
            return pos.volume
    return 0

def execute_trade(signal, price):
    """执行交易"""
    current_position = get_position()
    asset = xttrader.query_stock_asset(account)
    available_cash = asset.cash

    if signal == 'BUY' and current_position == 0:
        # 计算买入数量
        target_value = available_cash * POSITION_RATIO
        volume = int(target_value / price / 100) * 100  # 取整到100股

        if volume >= 100:
            print(f"\n[买入信号] 价格:{price}, 数量:{volume}")
            order = xttrader.order_stock(
                account=account,
                stock_code=STOCK_CODE,
                order_type=xttrader.FIX_PRICE,
                order_volume=volume,
                price=price,
                strategy_name='双均线策略'
            )
            print(f"委托编号: {order}")
        else:
            print("[买入信号] 资金不足")

    elif signal == 'SELL' and current_position > 0:
        print(f"\n[卖出信号] 价格:{price}, 数量:{current_position}")
        order = xttrader.order_stock(
            account=account,
            stock_code=STOCK_CODE,
            order_type=xttrader.FIX_PRICE,
            order_volume=-current_position,  # 全部卖出
            price=price,
            strategy_name='双均线策略'
        )
        print(f"委托编号: {order}")

    elif signal == 'HOLD':
        print(".", end='', flush=True)  # 无信号时只打印点

# ==================== 主循环 ====================
print("\n策略运行中...(Ctrl+C停止)")

try:
    while True:
        # 检查是否交易时间
        current_time = time.strftime("%H:%M:%S")
        hour = int(current_time[:2])
        minute = int(current_time[3:5])

        # 交易时间: 9:30-11:30, 13:00-15:00
        is_trading_time = (
            (hour == 9 and minute >= 30) or
            (hour == 10) or
            (hour == 11 and minute <= 30) or
            (hour == 13) or
            (hour == 14) or
            (hour == 15 and minute == 0)
        )

        if is_trading_time:
            # 计算信号
            signal, price = calculate_signals()

            # 执行交易
            execute_trade(signal, price)

        # 等待
        time.sleep(CHECK_INTERVAL)

except KeyboardInterrupt:
    print("\n\n策略已停止")

    # 打印最终状态
    asset = xttrader.query_stock_asset(account)
    print(f"\n最终资产: {asset.total_asset:.2f}")
    print(f"持仓市值: {asset.market_value:.2f}")
    print(f"可用资金: {asset.cash:.2f}")
    print(f"总盈亏: {asset.unrealized_pnl:.2f}")
```

#### 示例2: 多股票轮动策略

```python
"""
QMT多股票动量轮动策略
策略逻辑: 持有涨幅最大的N只股票
"""

from xtquant import xttrader, xtdata
import pandas as pd
import time

# ==================== 配置 ====================
STOCK_POOL = [  # 股票池
    '000001.SZ', '600000.SH', '600519.SH',
    '000858.SZ', '601318.SH', '000333.SZ'
]
HOLD_NUM = 3          # 持仓股票数
LOOKBACK = 20         # 动量周期(天)
REBALANCE_DAYS = 5    # 调仓周期(天)

# ==================== 初始化 ====================
xttrader.connect()
account = xttrader.get_account_list()[0]
xtdata.subscribe_quote(STOCK_POOL, period='1d')

last_rebalance = None  # 上次调仓日期

# ==================== 策略函数 ====================
def calculate_momentum():
    """计算股票动量"""
    results = []

    for stock in STOCK_POOL:
        # 获取历史数据
        data = xtdata.get_market_data(
            field_list=['close'],
            stock_list=[stock],
            period='1d',
            count=LOOKBACK + 1
        )

        df = data[stock]

        # 计算收益率
        returns = (df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]

        results.append({
            'stock': stock,
            'momentum': returns
        })

    # 排序
    df_result = pd.DataFrame(results)
    df_result = df_result.sort_values('momentum', ascending=False)

    return df_result

def rebalance():
    """调仓"""
    print("\n========== 开始调仓 ==========")

    # 计算目标持仓
    momentum = calculate_momentum()
    target_stocks = momentum.head(HOLD_NUM)['stock'].tolist()

    print("目标股票:")
    for stock in target_stocks:
        mom = momentum[momentum['stock'] == stock]['momentum'].values[0]
        print(f"  {stock}: {mom*100:.2f}%")

    # 获取当前持仓
    current_positions = {}
    positions = xttrader.query_stock_positions(account)
    for pos in positions:
        if pos.volume > 0:
            current_positions[pos.stock_code] = pos.volume

    # 获取可用资金
    asset = xttrader.query_stock_asset(account)
    total_value = asset.total_asset
    target_value_per_stock = total_value / HOLD_NUM

    # 卖出不在目标中的股票
    for stock, volume in current_positions.items():
        if stock not in target_stocks:
            print(f"卖出 {stock}: {volume}股")
            quotes = xtdata.get_market_data(['close'], [stock], '1d', count=1)
            price = quotes[stock]['close'].iloc[-1]

            xttrader.order_stock(
                account=account,
                stock_code=stock,
                order_type=xttrader.FIX_PRICE,
                order_volume=-volume,
                price=price * 0.99,  # 略低于现价
                strategy_name='动量轮动'
            )

    time.sleep(2)  # 等待卖出委托

    # 买入目标股票
    asset = xttrader.query_stock_asset(account)  # 更新资金
    available_cash = asset.cash

    for stock in target_stocks:
        # 获取当前价格
        quotes = xtdata.get_market_data(['close'], [stock], '1d', count=1)
        price = quotes[stock]['close'].iloc[-1]

        # 计算目标数量
        target_volume = int(target_value_per_stock / price / 100) * 100
        current_volume = current_positions.get(stock, 0)

        diff = target_volume - current_volume

        if diff >= 100:  # 需要买入
            buy_value = diff * price
            if buy_value <= available_cash:
                print(f"买入 {stock}: {diff}股")
                xttrader.order_stock(
                    account=account,
                    stock_code=stock,
                    order_type=xttrader.FIX_PRICE,
                    order_volume=diff,
                    price=price * 1.01,  # 略高于现价
                    strategy_name='动量轮动'
                )
                available_cash -= buy_value
        elif diff <= -100:  # 需要卖出
            print(f"减持 {stock}: {-diff}股")
            xttrader.order_stock(
                account=account,
                stock_code=stock,
                order_type=xttrader.FIX_PRICE,
                order_volume=diff,
                price=price * 0.99,
                strategy_name='动量轮动'
            )

    print("========== 调仓完成 ==========\n")

    return time.strftime("%Y%m%d")

# ==================== 主循环 ====================
print("动量轮动策略启动!")

try:
    while True:
        today = time.strftime("%Y%m%d")

        # 判断是否需要调仓
        if last_rebalance is None:
            # 首次运行,立即调仓
            last_rebalance = rebalance()
        else:
            # 计算距离上次调仓的天数
            # 简化处理: 每REBALANCE_DAYS天调仓一次
            # 实际应该用交易日历
            time_diff = int(today) - int(last_rebalance)
            if time_diff >= REBALANCE_DAYS:
                last_rebalance = rebalance()

        # 每小时检查一次
        time.sleep(3600)

except KeyboardInterrupt:
    print("\n策略已停止")
```

### 7.2.5 QMT进阶技巧

#### 风险控制

**1. 止损止盈**:
```python
def check_stop_loss():
    """检查止损止盈"""
    positions = xttrader.query_stock_positions(account)

    for pos in positions:
        # 计算盈亏比例
        pnl_ratio = pos.unrealized_pnl / (pos.avg_price * pos.volume)

        # 止损: -5%
        if pnl_ratio < -0.05:
            print(f"[止损] {pos.stock_code}, 亏损{pnl_ratio*100:.2f}%")
            xttrader.order_stock(
                account=account,
                stock_code=pos.stock_code,
                order_type=xttrader.MARKET_PRICE,
                order_volume=-pos.volume,
                strategy_name='止损'
            )

        # 止盈: +10%
        elif pnl_ratio > 0.10:
            print(f"[止盈] {pos.stock_code}, 盈利{pnl_ratio*100:.2f}%")
            xttrader.order_stock(
                account=account,
                stock_code=pos.stock_code,
                order_type=xttrader.MARKET_PRICE,
                order_volume=-pos.volume,
                strategy_name='止盈'
            )
```

**2. 仓位管理**:
```python
def calculate_position_size(stock_code, signal_strength):
    """
    根据信号强度计算仓位
    signal_strength: 0-1之间
    """
    asset = xttrader.query_stock_asset(account)
    available_cash = asset.cash

    # 基础仓位
    base_ratio = 0.3

    # 根据信号调整
    position_ratio = base_ratio * signal_strength

    # 不超过总资产的80%
    max_ratio = 0.8
    position_ratio = min(position_ratio, max_ratio)

    # 获取价格
    quotes = xtdata.get_market_data(['close'], [stock_code], '1d', count=1)
    price = quotes[stock_code]['close'].iloc[-1]

    # 计算数量
    target_value = asset.total_asset * position_ratio
    volume = int(target_value / price / 100) * 100

    return volume
```

**3. 滑点控制**:
```python
def smart_order(stock_code, volume, side='buy'):
    """智能下单,控制滑点"""
    # 获取当前五档行情
    tick = xtdata.get_full_tick([stock_code])[stock_code]

    if side == 'buy':
        # 买入: 使用卖一价
        price = tick['askPrice'][0]
    else:
        # 卖出: 使用买一价
        price = tick['bidPrice'][0]

    # 下单
    order = xttrader.order_stock(
        account=account,
        stock_code=stock_code,
        order_type=xttrader.FIX_PRICE,
        order_volume=volume if side == 'buy' else -volume,
        price=price,
        strategy_name='智能下单'
    )

    return order
```

#### 回测功能

**使用QMT回测**:
```python
from xtquant import xtbacktest

# 定义策略
def my_strategy(account):
    """策略函数"""
    # 在这里编写策略逻辑
    pass

# 配置回测
config = {
    'start_time': '20230101',
    'end_time': '20231231',
    'initial_cash': 1000000,
    'benchmark': '000300.SH',  # 沪深300作为基准
}

# 运行回测
result = xtbacktest.run_backtest(
    strategy_func=my_strategy,
    config=config
)

# 查看结果
print(f"总收益率: {result['total_return']:.2%}")
print(f"年化收益: {result['annual_return']:.2%}")
print(f"最大回撤: {result['max_drawdown']:.2%}")
print(f"夏普比率: {result['sharpe_ratio']:.2f}")
```

### 7.2.6 QMT常见问题

**Q1: 连接失败**:
```
问题: xttrader.connect()失败

解决:
1. 确保QMT客户端已启动
2. 检查是否已登录交易账户
3. 查看QMT日志文件
4. 重启QMT客户端
```

**Q2: 下单失败**:
```
问题: order_stock返回错误

原因:
- 资金不足
- 股票停牌
- 价格超出涨跌停
- 数量不是100的倍数
- 非交易时间

解决: 检查错误信息,调整参数
```

**Q3: 行情数据延迟**:
```
问题: 获取的行情有延迟

说明:
- QMT提供Level-1行情(实时)
- 部分券商有延迟
- 分钟线有1-3分钟延迟

解决:
- 升级到Level-2行情(付费)
- 使用Tick数据
```

**Q4: Python版本问题**:
```
问题: xtquant导入失败

解决:
- QMT支持Python 3.7-3.9
- 使用QMT自带Python环境
- 或配置sys.path
```

---

## 7.3 掘金量化

### 平台介绍

**掘金量化(MyQuant)**:
```
定位: 专业量化交易平台
官网: www.myquant.cn

特点:
- 跨券商
- 图形化界面
- 策略商店
- 云端回测

优点:
✓ 上手简单
✓ 文档完善
✓ 支持多市场
✓ 有技术支持

缺点:
✗ 收费
✗ 性能一般
```

### 定价

```
免费版:
- 实时行情
- 策略回测
- 模拟交易

专业版: 99元/月
- 实盘交易
- Level-2行情
- 更多API调用

旗舰版: 299元/月
- 高频数据
- 私有部署
- 定制服务
```

### 使用示例

```python
# 安装
pip install gm3

# 导入
from gm.api import *

# 初始化
set_token('your_token')

# 回测设置
set_backtest_config(
    start_time='2023-01-01 09:00:00',
    end_time='2023-12-31 15:00:00',
    initial_cash=1000000,
    benchmark='SHSE.000300'
)

# 策略函数
def init(context):
    # 订阅
    subscribe('SZSE.000001', '1d')

def on_bar(context, bars):
    # 策略逻辑
    bar = bars[0]

    # 买入
    order_target_percent('SZSE.000001', 0.5,
                         order_type=OrderType_Limit,
                         price=bar.close)

# 运行
run()
```

---

## 7.4 vn.py量化框架

### 框架介绍

**vn.py**:
```
定位: 开源量化交易框架
GitHub: vnpy/vnpy
作者: vn.py团队

特点:
- 完全开源免费
- 支持多市场(股票、期货、期权、外汇)
- 支持多接口
- 高度可定制
- 社区活跃

适合:
- 专业开发者
- 机构用户
- 需要定制的场景
```

### 安装

```bash
# 安装核心
pip install vnpy

# 安装组件
pip install vnpy_ctp        # 期货CTP接口
pip install vnpy_ib         # 盈透接口
pip install vnpy_binance    # 币安接口

# 安装图形界面
pip install vnpy_ctastrategy  # CTA策略
pip install vnpy_datamanager  # 数据管理
pip install vnpy_riskmanager  # 风控
```

### 基础使用

```python
from vnpy.event import EventEngine
from vnpy.trader.engine import MainEngine
from vnpy.trader.ui import MainWindow, create_qapp
from vnpy.gateway.ctp import CtpGateway

# 创建事件引擎
event_engine = EventEngine()

# 创建主引擎
main_engine = MainEngine(event_engine)

# 添加接口
main_engine.add_gateway(CtpGateway)

# 创建GUI
qapp = create_qapp()
main_window = MainWindow(main_engine, event_engine)
main_window.showMaximized()

# 运行
qapp.exec()
```

### 策略示例

```python
from vnpy.app.cta_strategy import (
    CtaTemplate,
    StopOrder,
    TickData,
    BarData,
    TradeData,
    OrderData
)

class DualMaStrategy(CtaTemplate):
    """双均线策略"""

    author = "vn.py"

    fast_window = 10
    slow_window = 20

    parameters = ["fast_window", "slow_window"]
    variables = ["fast_ma", "slow_ma"]

    def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
        super().__init__(cta_engine, strategy_name, vt_symbol, setting)

        self.fast_ma = 0
        self.slow_ma = 0

    def on_init(self):
        """初始化"""
        self.write_log("策略初始化")
        self.load_bar(10)

    def on_start(self):
        """启动"""
        self.write_log("策略启动")

    def on_stop(self):
        """停止"""
        self.write_log("策略停止")

    def on_bar(self, bar: BarData):
        """K线回调"""
        # 计算均线
        am = self.am
        am.update_bar(bar)
        if not am.inited:
            return

        self.fast_ma = am.sma(self.fast_window)
        self.slow_ma = am.sma(self.slow_window)

        # 交易逻辑
        if self.pos == 0:
            if self.fast_ma > self.slow_ma:
                self.buy(bar.close_price, 1)
        elif self.pos > 0:
            if self.fast_ma < self.slow_ma:
                self.sell(bar.close_price, abs(self.pos))

        self.put_event()
```

---

## 7.5 其他交易接口

### 聚宽/米筐

**特点**:
- 云端平台
- 在线回测
- 在线实盘
- 适合策略研究

**限制**:
- 必须在平台运行
- 不能本地部署
- 依赖平台稳定性

### 东方财富/同花顺

**东财量化**:
- 基于东财账户
- 免费
- 功能基础

**同花顺量化**:
- 条件单
- 简单策略
- 适合初级用户

### easytrader(开源)

**简介**:
```
GitHub: shidenggui/easytrader
特点: 模拟点击交易
原理: 自动化操作券商客户端

风险:
⚠️ 依赖客户端界面
⚠️ 易被检测
⚠️ 不稳定
⚠️ 不推荐生产使用
```

---

## 本章小结

本章介绍了量化交易的平台与接口:

### 核心要点

**1. 交易接口选择**:
```
个人投资者: QMT(免费,稳定)
专业开发者: vn.py(开源,可定制)
初学者: 掘金量化(简单,有支持)
研究为主: 聚宽/米筐(云端,方便)
```

**2. QMT重点掌握**:
- 安装配置
- 行情接口: get_market_data
- 交易接口: order_stock
- 查询接口: query_positions/orders
- 完整策略编写

**3. 实盘注意事项**:
- 先模拟,后实盘
- 小资金测试
- 风险控制(止损止盈)
- 仓位管理
- 滑点控制

**4. 常见错误**:
❌ 直接实盘未经测试的策略
❌ 忽视风控
❌ 全仓单股
❌ 频繁交易
❌ 过度优化

✅ **正确做法**:
- 充分回测
- 小资金验证
- 严格风控
- 分散持仓
- 控制频率

---

**下一章预告**:
第八章将介绍**学习资源导航**,包括书籍、课程、网站、社区等,帮助你持续提升量化交易能力。
