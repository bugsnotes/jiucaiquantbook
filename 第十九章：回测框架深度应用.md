# ç¬¬åä¹ç« ï¼šå›æµ‹æ¡†æ¶æ·±åº¦åº”ç”¨

ğŸ¯ **é€‚åˆäººç¾¤**ï¼šæœ‰ç¼–ç¨‹èƒ½åŠ›çš„ä¸“ä¸šç”¨æˆ· | â±ï¸ **å­¦ä¹ å‘¨æœŸ**ï¼š2-3å‘¨

## æœ¬ç« å¯¼è¯»

å›æµ‹æ˜¯é‡åŒ–ç­–ç•¥å¼€å‘çš„å…³é”®ç¯èŠ‚ã€‚é€‰æ‹©åˆé€‚çš„å›æµ‹æ¡†æ¶å¯ä»¥å¤§å¤§æé«˜å¼€å‘æ•ˆç‡å’Œç­–ç•¥è´¨é‡ã€‚æœ¬ç« å°†æ·±å…¥ä»‹ç»ä¸‰å¤§ä¸»æµå›æµ‹æ¡†æ¶ï¼šbacktraderã€vectorbtå’ŒQlibï¼Œä»¥åŠå¦‚ä½•è‡ªå»ºå›æµ‹æ¡†æ¶ã€‚

**æœ¬ç« å†…å®¹**ï¼š
- ğŸ“Š 19.1 backtraderæ¡†æ¶è¯¦è§£
- âš¡ 19.2 vectorbté«˜æ€§èƒ½å›æµ‹
- ğŸ”¥ 19.3 Qlib AIé‡åŒ–å¹³å°
- ğŸ”§ 19.4 è‡ªå»ºå›æµ‹æ¡†æ¶

---

## 19.1 backtraderæ¡†æ¶è¯¦è§£

backtraderæ˜¯Pythonä¸­æœ€æµè¡Œçš„å›æµ‹æ¡†æ¶ä¹‹ä¸€ï¼ŒåŠŸèƒ½å¼ºå¤§ä¸”çµæ´»ã€‚

### â— 19.1.1 æ¶æ„è®¾è®¡

backtraderé‡‡ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œæ ¸å¿ƒç»„ä»¶åŒ…æ‹¬ï¼š

```
Cerebro (å¤§è„‘)
â”œâ”€â”€ Data Feeds (æ•°æ®æº)
â”œâ”€â”€ Strategies (ç­–ç•¥)
â”œâ”€â”€ Indicators (æŒ‡æ ‡)
â”œâ”€â”€ Analyzers (åˆ†æå™¨)
â”œâ”€â”€ Observers (è§‚å¯Ÿå™¨)
â””â”€â”€ Broker (ç»çºªå•†)
```

### â— 19.1.2 åŸºç¡€ä½¿ç”¨

```python
import backtrader as bt
import pandas as pd

# 1. åˆ›å»ºç­–ç•¥ç±»
class MyStrategy(bt.Strategy):
    params = (
        ('ma_period', 20),
        ('printlog', False),
    )

    def __init__(self):
        # ä¿å­˜æ”¶ç›˜ä»·å¼•ç”¨
        self.dataclose = self.datas[0].close

        # åˆ›å»ºç§»åŠ¨å¹³å‡çº¿æŒ‡æ ‡
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.ma_period
        )

        # è®¢å•å¼•ç”¨
        self.order = None

    def log(self, txt, dt=None):
        """æ—¥å¿—å‡½æ•°"""
        if self.params.printlog:
            dt = dt or self.datas[0].datetime.date(0)
            print(f'{dt.isoformat()} {txt}')

    def notify_order(self, order):
        """è®¢å•çŠ¶æ€é€šçŸ¥"""
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'ä¹°å…¥æ‰§è¡Œ, ä»·æ ¼: {order.executed.price:.2f}, '
                        f'æˆæœ¬: {order.executed.value:.2f}, '
                        f'ä½£é‡‘: {order.executed.comm:.2f}')
            elif order.issell():
                self.log(f'å–å‡ºæ‰§è¡Œ, ä»·æ ¼: {order.executed.price:.2f}, '
                        f'æˆæœ¬: {order.executed.value:.2f}, '
                        f'ä½£é‡‘: {order.executed.comm:.2f}')

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('è®¢å•å–æ¶ˆ/ä¿è¯é‡‘ä¸è¶³/æ‹’ç»')

        self.order = None

    def notify_trade(self, trade):
        """äº¤æ˜“é€šçŸ¥"""
        if not trade.isclosed:
            return

        self.log(f'äº¤æ˜“åˆ©æ¶¦, æ¯›åˆ©æ¶¦: {trade.pnl:.2f}, å‡€åˆ©æ¶¦: {trade.pnlcomm:.2f}')

    def next(self):
        """ç­–ç•¥ä¸»é€»è¾‘"""
        self.log(f'æ”¶ç›˜ä»·, {self.dataclose[0]:.2f}')

        # æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„è®¢å•
        if self.order:
            return

        # æ£€æŸ¥æ˜¯å¦æŒä»“
        if not self.position:
            # æ²¡æœ‰æŒä»“ï¼Œæ£€æŸ¥ä¹°å…¥ä¿¡å·
            if self.dataclose[0] > self.sma[0]:
                self.log(f'ä¹°å…¥ä¿¡å·, {self.dataclose[0]:.2f}')
                # ä¹°å…¥
                self.order = self.buy()
        else:
            # æœ‰æŒä»“ï¼Œæ£€æŸ¥å–å‡ºä¿¡å·
            if self.dataclose[0] < self.sma[0]:
                self.log(f'å–å‡ºä¿¡å·, {self.dataclose[0]:.2f}')
                # å–å‡º
                self.order = self.sell()

# 2. åˆå§‹åŒ–Cerebroå¼•æ“
cerebro = bt.Cerebro()

# 3. æ·»åŠ ç­–ç•¥
cerebro.addstrategy(MyStrategy, ma_period=20, printlog=True)

# 4. åŠ è½½æ•°æ®
# å‡è®¾æœ‰CSVæ–‡ä»¶ï¼Œæ ¼å¼ä¸ºï¼šdate,open,high,low,close,volume
data = bt.feeds.GenericCSVData(
    dataname='data.csv',
    dtformat='%Y-%m-%d',
    datetime=0,
    open=1,
    high=2,
    low=3,
    close=4,
    volume=5,
    openinterest=-1
)
cerebro.adddata(data)

# 5. è®¾ç½®åˆå§‹èµ„é‡‘
cerebro.broker.setcash(100000.0)

# 6. è®¾ç½®ä½£é‡‘
cerebro.broker.setcommission(commission=0.001)

# 7. æ‰“å°åˆå§‹èµ„é‡‘
print(f'åˆå§‹èµ„é‡‘: {cerebro.broker.getvalue():.2f}')

# 8. è¿è¡Œå›æµ‹
cerebro.run()

# 9. æ‰“å°æœ€ç»ˆèµ„é‡‘
print(f'æœ€ç»ˆèµ„é‡‘: {cerebro.broker.getvalue():.2f}')

# 10. ç»˜å›¾
cerebro.plot()
```

### â— 19.1.3 è‡ªå®šä¹‰æŒ‡æ ‡

```python
class MyIndicator(bt.Indicator):
    """è‡ªå®šä¹‰æŒ‡æ ‡ï¼šåŠ¨é‡æŒ¯è¡å™¨"""
    lines = ('momentum_osc',)  # å®šä¹‰è¾“å‡ºçº¿
    params = (
        ('period', 14),
        ('movav', bt.indicators.SMA),
    )

    def __init__(self):
        # è®¡ç®—ä»·æ ¼åŠ¨é‡
        momentum = self.data.close - self.data.close(-self.params.period)

        # å¯¹åŠ¨é‡è¿›è¡Œå¹³æ»‘
        self.lines.momentum_osc = self.params.movav(momentum, period=self.params.period)

# åœ¨ç­–ç•¥ä¸­ä½¿ç”¨
class MyStrategyWithCustomIndicator(bt.Strategy):
    def __init__(self):
        self.my_indicator = MyIndicator(self.data, period=14)

    def next(self):
        if self.my_indicator.momentum_osc[0] > 0:
            # åŠ¨é‡ä¸ºæ­£ï¼Œè€ƒè™‘ä¹°å…¥
            if not self.position:
                self.buy()
        elif self.my_indicator.momentum_osc[0] < 0:
            # åŠ¨é‡ä¸ºè´Ÿï¼Œè€ƒè™‘å–å‡º
            if self.position:
                self.sell()
```

### â— 19.1.4 åˆ†æå™¨ä½¿ç”¨

```python
# æ·»åŠ åˆ†æå™¨
cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')
cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')

# è¿è¡Œå›æµ‹
results = cerebro.run()

# è·å–åˆ†æç»“æœ
strat = results[0]

# å¤æ™®æ¯”ç‡
print(f"å¤æ™®æ¯”ç‡: {strat.analyzers.sharpe.get_analysis()['sharperatio']:.2f}")

# æœ€å¤§å›æ’¤
print(f"æœ€å¤§å›æ’¤: {strat.analyzers.drawdown.get_analysis()['max']['drawdown']:.2f}%")

# æ”¶ç›Šç‡
print(f"æ€»æ”¶ç›Šç‡: {strat.analyzers.returns.get_analysis()['rtot']:.2%}")

# äº¤æ˜“åˆ†æ
trades = strat.analyzers.trades.get_analysis()
print(f"æ€»äº¤æ˜“æ¬¡æ•°: {trades.total.total}")
print(f"ç›ˆåˆ©äº¤æ˜“: {trades.won.total}")
print(f"äºæŸäº¤æ˜“: {trades.lost.total}")
```

### â— 19.1.5 å®Œæ•´æ¡ˆä¾‹ï¼šåŒå‡çº¿ç­–ç•¥

```python
import backtrader as bt
import datetime

class DualMAStrategy(bt.Strategy):
    """åŒå‡çº¿ç­–ç•¥"""
    params = (
        ('fast_period', 10),
        ('slow_period', 30),
        ('printlog', True),
    )

    def __init__(self):
        # å¿«é€Ÿå‡çº¿
        self.fast_ma = bt.indicators.SMA(
            self.data.close, period=self.params.fast_period
        )
        # æ…¢é€Ÿå‡çº¿
        self.slow_ma = bt.indicators.SMA(
            self.data.close, period=self.params.slow_period
        )

        # äº¤å‰ä¿¡å·
        self.crossover = bt.indicators.CrossOver(self.fast_ma, self.slow_ma)

        self.order = None

    def log(self, txt, dt=None):
        if self.params.printlog:
            dt = dt or self.datas[0].datetime.date(0)
            print(f'{dt.isoformat()} {txt}')

    def notify_order(self, order):
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'ä¹°å…¥: {order.executed.price:.2f}')
            else:
                self.log(f'å–å‡º: {order.executed.price:.2f}')
        self.order = None

    def next(self):
        if self.order:
            return

        if not self.position:
            # é‡‘å‰ä¹°å…¥
            if self.crossover > 0:
                self.order = self.buy()
        else:
            # æ­»å‰å–å‡º
            if self.crossover < 0:
                self.order = self.sell()

# è¿è¡Œå®Œæ•´å›æµ‹
if __name__ == '__main__':
    cerebro = bt.Cerebro()
    cerebro.addstrategy(DualMAStrategy)

    # æ·»åŠ æ•°æ®ï¼ˆè¿™é‡Œéœ€è¦å®é™…æ•°æ®ï¼‰
    # data = bt.feeds.GenericCSVData(...)
    # cerebro.adddata(data)

    cerebro.broker.setcash(100000.0)
    cerebro.broker.setcommission(commission=0.001)

    # æ·»åŠ åˆ†æå™¨
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='dd')

    print(f'åˆå§‹èµ„é‡‘: {cerebro.broker.getvalue():.2f}')
    results = cerebro.run()
    print(f'æœ€ç»ˆèµ„é‡‘: {cerebro.broker.getvalue():.2f}')

    # åˆ†æç»“æœ
    strat = results[0]
    sharpe = strat.analyzers.sharpe.get_analysis()['sharperatio']
    dd = strat.analyzers.dd.get_analysis()['max']['drawdown']
    print(f'å¤æ™®æ¯”ç‡: {sharpe:.2f}')
    print(f'æœ€å¤§å›æ’¤: {dd:.2f}%')

    cerebro.plot()
```

---

## 19.2 vectorbté«˜æ€§èƒ½å›æµ‹

vectorbtæ˜¯åŸºäºå‘é‡åŒ–è®¡ç®—çš„é«˜æ€§èƒ½å›æµ‹æ¡†æ¶ï¼Œç‰¹åˆ«é€‚åˆå‚æ•°ä¼˜åŒ–ã€‚

### â— 19.2.1 å‘é‡åŒ–å›æµ‹åŸç†

```python
import vectorbt as vbt
import numpy as np
import pandas as pd

# åŠ è½½æ•°æ®
price = vbt.YFData.download('AAPL', start='2020-01-01', end='2023-12-31').get('Close')

# å¿«é€Ÿæ„å»ºåŒå‡çº¿ç­–ç•¥
fast_ma = vbt.MA.run(price, 10)
slow_ma = vbt.MA.run(price, 30)

# ç”Ÿæˆä¿¡å·
entries = fast_ma.ma_crossed_above(slow_ma)
exits = fast_ma.ma_crossed_below(slow_ma)

# å›æµ‹
portfolio = vbt.Portfolio.from_signals(
    price,
    entries,
    exits,
    init_cash=100000,
    fees=0.001
)

# æŸ¥çœ‹ç»“æœ
print(portfolio.stats())
print(f"æ€»æ”¶ç›Š: {portfolio.total_return():.2%}")
print(f"å¤æ™®æ¯”ç‡: {portfolio.sharpe_ratio():.2f}")
print(f"æœ€å¤§å›æ’¤: {portfolio.max_drawdown():.2%}")

# å¯è§†åŒ–
portfolio.plot().show()
```

### â— 19.2.2 å‚æ•°ä¼˜åŒ–

```python
# æ‰¹é‡æµ‹è¯•å¤šç»„å‚æ•°
fast_windows = np.arange(5, 50, 5)
slow_windows = np.arange(20, 100, 10)

# è®¡ç®—æ‰€æœ‰ç»„åˆçš„å‡çº¿
fast_ma = vbt.MA.run(price, fast_windows, short_name='fast')
slow_ma = vbt.MA.run(price, slow_windows, short_name='slow')

# ç”Ÿæˆä¿¡å·ï¼ˆå¹¿æ’­ï¼‰
entries = fast_ma.ma_crossed_above(slow_ma)
exits = fast_ma.ma_crossed_below(slow_ma)

# æ‰¹é‡å›æµ‹
portfolios = vbt.Portfolio.from_signals(
    price,
    entries,
    exits,
    init_cash=100000,
    fees=0.001
)

# æ‰¾åˆ°æœ€ä¼˜å‚æ•°
sharpe_ratios = portfolios.sharpe_ratio()
best_params = sharpe_ratios.idxmax()
print(f"æœ€ä¼˜å‚æ•°: fast={best_params[0]}, slow={best_params[1]}")
print(f"æœ€ä¼˜å¤æ™®: {sharpe_ratios.max():.2f}")

# å¯è§†åŒ–å‚æ•°ç©ºé—´
sharpe_ratios.vbt.heatmap().show()
```

### â— 19.2.3 æ€§èƒ½å¯¹æ¯”

vectorbtç›¸æ¯”ä¼ ç»Ÿå›æµ‹æ¡†æ¶çš„ä¼˜åŠ¿ï¼š

| ç‰¹æ€§ | backtrader | vectorbt |
|------|------------|----------|
| å›æµ‹é€Ÿåº¦ | æ…¢ï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰ | å¿«ï¼ˆå‘é‡åŒ–ï¼‰ |
| å‚æ•°ä¼˜åŒ– | æ…¢ | æå¿« |
| å†…å­˜å ç”¨ | ä½ | é«˜ |
| çµæ´»æ€§ | é«˜ | ä¸­ |
| å­¦ä¹ æ›²çº¿ | é™¡ | å¹³ç¼“ |

---

## 19.3 Qlib AIé‡åŒ–å¹³å°

Qlibæ˜¯å¾®è½¯å¼€æºçš„AIé‡åŒ–æŠ•èµ„å¹³å°ï¼Œé›†æˆäº†æ•°æ®å¤„ç†ã€å› å­æŒ–æ˜ã€æ¨¡å‹è®­ç»ƒã€å›æµ‹ç­‰å…¨æµç¨‹ã€‚

### â— 19.3.1 Qlibå¿«é€Ÿå…¥é—¨

```python
import qlib
from qlib.constant import REG_CN
from qlib.utils import init_instance_by_config
from qlib.workflow import R
from qlib.workflow.record_temp import SignalRecord
from qlib.tests.data import GetData

# 1. åˆå§‹åŒ–Qlib
qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)

# 2. å®šä¹‰å› å­ï¼ˆAlpha158ï¼‰
market = "csi300"
benchmark = "SH000300"

# æ•°æ®å¤„ç†é…ç½®
data_handler_config = {
    "start_time": "2010-01-01",
    "end_time": "2020-12-31",
    "fit_start_time": "2010-01-01",
    "fit_end_time": "2015-12-31",
    "instruments": market,
}

# 3. è®­ç»ƒæ¨¡å‹
from qlib.contrib.model.gbdt import LGBModel

model = LGBModel()

# 4. å›æµ‹
from qlib.contrib.strategy.signal_strategy import TopkDropoutStrategy
from qlib.contrib.evaluate import backtest

strategy_config = {
    "class": "TopkDropoutStrategy",
    "module_path": "qlib.contrib.strategy.signal_strategy",
    "kwargs": {
        "topk": 50,
        "n_drop": 5,
    },
}

# è¿è¡Œå›æµ‹
portfolio_metric_dict, indicator_dict = backtest(
    pred=pred_score,
    strategy=strategy_config,
    executor_config=executor_config,
    backtest_config=backtest_config
)

print(portfolio_metric_dict)
```

### â— 19.3.2 å› å­è¡¨è¾¾å¼å¼•æ“

```python
# Qlibçš„å› å­è¡¨è¾¾å¼éå¸¸å¼ºå¤§
factors = [
    # ä»·æ ¼ç±»
    "($close-Ref($close,1))/Ref($close,1)",  # æ—¥æ”¶ç›Šç‡
    "Mean($close,5)/Mean($close,20)-1",      # çŸ­æœŸ/é•¿æœŸå‡çº¿æ¯”

    # æˆäº¤é‡ç±»
    "Log($volume/Mean($volume,5))",          # ç›¸å¯¹æˆäº¤é‡

    # æ³¢åŠ¨ç‡ç±»
    "Std($close,20)",                        # 20æ—¥æ³¢åŠ¨ç‡

    # é«˜çº§ç®—å­
    "Corr($close,$volume,10)",               # é‡ä»·ç›¸å…³æ€§
    "Rank(Sub($close,Mean($close,10)))",     # ä»·æ ¼æ’å
]

# åœ¨æ•°æ®é…ç½®ä¸­ä½¿ç”¨
fields = factors
names = [f"factor_{i}" for i in range(len(factors))]
```

### â— 19.3.3 å®Œæ•´çš„Qlibå·¥ä½œæµ

```python
"""
å®Œæ•´çš„Qlibé‡åŒ–ç ”ç©¶æµç¨‹
"""
import qlib
import pandas as pd
from qlib.config import REG_CN
from qlib.contrib.data.handler import Alpha158
from qlib.contrib.model.pytorch_lstm import LSTM
from qlib.contrib.strategy.signal_strategy import TopkDropoutStrategy
from qlib.contrib.evaluate import backtest
from qlib.utils import init_instance_by_config

# 1. åˆå§‹åŒ–
qlib.init(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN)

# 2. æ•°æ®é…ç½®
market = "csi300"
benchmark = "SH000300"

dataset_config = {
    "class": "DatasetH",
    "module_path": "qlib.data.dataset",
    "kwargs": {
        "handler": {
            "class": "Alpha158",
            "module_path": "qlib.contrib.data.handler",
            "kwargs": {
                "start_time": "2010-01-01",
                "end_time": "2020-12-31",
                "fit_start_time": "2010-01-01",
                "fit_end_time": "2015-12-31",
                "instruments": market,
            },
        },
        "segments": {
            "train": ("2010-01-01", "2015-12-31"),
            "valid": ("2016-01-01", "2017-12-31"),
            "test": ("2018-01-01", "2020-12-31"),
        },
    },
}

# 3. æ¨¡å‹é…ç½®
model_config = {
    "class": "LGBModel",
    "module_path": "qlib.contrib.model.gbdt",
    "kwargs": {
        "loss": "mse",
        "colsample_bytree": 0.8879,
        "learning_rate": 0.0421,
        "subsample": 0.8789,
        "lambda_l1": 205.6999,
        "lambda_l2": 580.9768,
        "max_depth": 8,
        "num_leaves": 210,
        "num_threads": 20,
    },
}

# 4. ç­–ç•¥é…ç½®
strategy_config = {
    "class": "TopkDropoutStrategy",
    "module_path": "qlib.contrib.strategy",
    "kwargs": {
        "model": model_config,
        "dataset": dataset_config,
        "topk": 50,
        "n_drop": 5,
    },
}

# 5. å›æµ‹é…ç½®
backtest_config = {
    "start_time": "2018-01-01",
    "end_time": "2020-12-31",
    "account": 100000000,
    "benchmark": benchmark,
    "exchange_kwargs": {
        "freq": "day",
        "limit_threshold": 0.095,
        "deal_price": "close",
        "open_cost": 0.0005,
        "close_cost": 0.0015,
        "min_cost": 5,
    },
}

# 6. æ‰§è¡Œå›æµ‹
from qlib.workflow import R
from qlib.workflow.record_temp import SignalRecord

with R.start(experiment_name="qlib_example"):
    # åˆå§‹åŒ–æ¨¡å‹
    model = init_instance_by_config(model_config)
    dataset = init_instance_by_config(dataset_config)

    # è®­ç»ƒ
    model.fit(dataset)

    # é¢„æµ‹
    recorder = R.get_recorder()
    pred = model.predict(dataset)

    # ä¿å­˜é¢„æµ‹ç»“æœ
    sr = SignalRecord(model, dataset, recorder)
    sr.generate()

    # å›æµ‹
    from qlib.contrib.evaluate import backtest
    portfolio_metric_dict, indicator_dict = backtest(
        pred,
        strategy=strategy_config,
        backtest_config=backtest_config
    )

    # åˆ†æç»“æœ
    print("å›æµ‹ç»“æœ:")
    print(portfolio_metric_dict)
    print("\næŒ‡æ ‡:")
    print(indicator_dict)

# 7. å¯è§†åŒ–
from qlib.contrib.evaluate import risk_analysis
from qlib.data import D

# è·å–å›æµ‹æŠ¥å‘Š
report_normal, positions_normal = portfolio_metric_dict, indicator_dict

# åˆ†æ
analysis = dict()
analysis["excess_return_without_cost"] = risk_analysis(
    report_normal["return"] - report_normal["bench"],
    freq="day"
)
analysis["excess_return_with_cost"] = risk_analysis(
    report_normal["return"] - report_normal["bench"] - report_normal["cost"],
    freq="day"
)

# æ‰“å°åˆ†æç»“æœ
print("\né£é™©åˆ†æ:")
for key, value in analysis.items():
    print(f"\n{key}:")
    print(value)
```

---

## 19.4 è‡ªå»ºå›æµ‹æ¡†æ¶

å¯¹äºç‰¹æ®Šéœ€æ±‚ï¼Œå¯ä»¥è‡ªå»ºå›æµ‹æ¡†æ¶ã€‚

### â— 19.4.1 äº‹ä»¶é©±åŠ¨æ¶æ„

```python
from enum import Enum
from queue import Queue
from abc import ABC, abstractmethod

class EventType(Enum):
    """äº‹ä»¶ç±»å‹"""
    MARKET = 1
    SIGNAL = 2
    ORDER = 3
    FILL = 4

class Event(ABC):
    """äº‹ä»¶åŸºç±»"""
    @property
    @abstractmethod
    def type(self):
        pass

class MarketEvent(Event):
    """å¸‚åœºæ•°æ®äº‹ä»¶"""
    def __init__(self):
        self.type = EventType.MARKET

class SignalEvent(Event):
    """ä¿¡å·äº‹ä»¶"""
    def __init__(self, symbol, signal_type, strength):
        self.type = EventType.SIGNAL
        self.symbol = symbol
        self.signal_type = signal_type  # 'LONG' or 'SHORT'
        self.strength = strength

class OrderEvent(Event):
    """è®¢å•äº‹ä»¶"""
    def __init__(self, symbol, order_type, quantity, direction):
        self.type = EventType.ORDER
        self.symbol = symbol
        self.order_type = order_type  # 'MKT' or 'LMT'
        self.quantity = quantity
        self.direction = direction  # 'BUY' or 'SELL'

class FillEvent(Event):
    """æˆäº¤äº‹ä»¶"""
    def __init__(self, timestamp, symbol, exchange, quantity, direction, fill_cost, commission=None):
        self.type = EventType.FILL
        self.timestamp = timestamp
        self.symbol = symbol
        self.exchange = exchange
        self.quantity = quantity
        self.direction = direction
        self.fill_cost = fill_cost
        self.commission = commission or 0.0

class DataHandler(ABC):
    """æ•°æ®å¤„ç†å™¨"""
    @abstractmethod
    def get_latest_bars(self, symbol, N=1):
        pass

    @abstractmethod
    def update_bars(self):
        pass

class Strategy(ABC):
    """ç­–ç•¥åŸºç±»"""
    @abstractmethod
    def calculate_signals(self, event):
        pass

class Portfolio:
    """æŠ•èµ„ç»„åˆ"""
    def __init__(self, bars, events, start_date, initial_capital=100000.0):
        self.bars = bars
        self.events = events
        self.symbol_list = self.bars.symbol_list
        self.start_date = start_date
        self.initial_capital = initial_capital

        self.all_positions = []
        self.current_positions = {symbol: 0 for symbol in self.symbol_list}

        self.all_holdings = []
        self.current_holdings = self._construct_current_holdings()

    def _construct_current_holdings(self):
        holdings = {symbol: 0.0 for symbol in self.symbol_list}
        holdings['cash'] = self.initial_capital
        holdings['commission'] = 0.0
        holdings['total'] = self.initial_capital
        return holdings

    def update_timeindex(self, event):
        """æ›´æ–°æ—¶é—´ç´¢å¼•"""
        bars = {}
        for symbol in self.symbol_list:
            bars[symbol] = self.bars.get_latest_bars(symbol, N=1)

        # æ›´æ–°æŒä»“
        positions = {symbol: self.current_positions[symbol] for symbol in self.symbol_list}
        self.all_positions.append(positions)

        # æ›´æ–°æŒä»“å¸‚å€¼
        holdings = {symbol: 0.0 for symbol in self.symbol_list}
        holdings['cash'] = self.current_holdings['cash']
        holdings['commission'] = self.current_holdings['commission']
        holdings['total'] = self.current_holdings['cash']

        for symbol in self.symbol_list:
            market_value = self.current_positions[symbol] * bars[symbol][0]['close']
            holdings[symbol] = market_value
            holdings['total'] += market_value

        self.all_holdings.append(holdings)
        self.current_holdings = holdings

class ExecutionHandler(ABC):
    """æ‰§è¡Œå¤„ç†å™¨"""
    @abstractmethod
    def execute_order(self, event):
        pass

class BacktestEngine:
    """å›æµ‹å¼•æ“"""
    def __init__(self, csv_dir, symbol_list, initial_capital, start_date,
                data_handler, execution_handler, portfolio, strategy):
        self.csv_dir = csv_dir
        self.symbol_list = symbol_list
        self.initial_capital = initial_capital
        self.start_date = start_date

        self.data_handler = data_handler
        self.execution_handler = execution_handler
        self.portfolio = portfolio
        self.strategy = strategy

        self.events = Queue()
        self.signals = 0
        self.orders = 0
        self.fills = 0

    def _run_backtest(self):
        """è¿è¡Œå›æµ‹"""
        while True:
            # æ›´æ–°å¸‚åœºæ•°æ®
            if self.data_handler.continue_backtest:
                self.data_handler.update_bars()
            else:
                break

            # å¤„ç†äº‹ä»¶
            while True:
                try:
                    event = self.events.get(False)
                except:
                    break
                else:
                    if event is not None:
                        if event.type == EventType.MARKET:
                            self.strategy.calculate_signals(event)
                            self.portfolio.update_timeindex(event)

                        elif event.type == EventType.SIGNAL:
                            self.signals += 1
                            self.portfolio.update_signal(event)

                        elif event.type == EventType.ORDER:
                            self.orders += 1
                            self.execution_handler.execute_order(event)

                        elif event.type == EventType.FILL:
                            self.fills += 1
                            self.portfolio.update_fill(event)

    def _output_performance(self):
        """è¾“å‡ºæ€§èƒ½æŒ‡æ ‡"""
        pass

    def simulate_trading(self):
        """æ¨¡æ‹Ÿäº¤æ˜“"""
        self._run_backtest()
        self._output_performance()
```

### â— 19.4.2 æ¨¡å—åŒ–è®¾è®¡

å®Œæ•´çš„å›æµ‹æ¡†æ¶åº”è¯¥åŒ…å«ä»¥ä¸‹æ¨¡å—ï¼š

```
backtest_framework/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ event.py          # äº‹ä»¶å®šä¹‰
â”‚   â”œâ”€â”€ data.py           # æ•°æ®å¤„ç†
â”‚   â”œâ”€â”€ strategy.py       # ç­–ç•¥åŸºç±»
â”‚   â”œâ”€â”€ portfolio.py      # ç»„åˆç®¡ç†
â”‚   â”œâ”€â”€ execution.py      # è®¢å•æ‰§è¡Œ
â”‚   â””â”€â”€ performance.py    # æ€§èƒ½åˆ†æ
â”œâ”€â”€ strategies/
â”‚   â”œâ”€â”€ ma_cross.py       # å‡çº¿ç­–ç•¥
â”‚   â””â”€â”€ mean_reversion.py # å‡å€¼å›å½’
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ indicators.py     # æŠ€æœ¯æŒ‡æ ‡
â”‚   â””â”€â”€ visualize.py      # å¯è§†åŒ–
â””â”€â”€ main.py               # ä¸»ç¨‹åº
```

---

## æœ¬ç« å°ç»“

æœ¬ç« ä»‹ç»äº†ä¸‰å¤§ä¸»æµå›æµ‹æ¡†æ¶å’Œè‡ªå»ºæ¡†æ¶çš„æ–¹æ³•ï¼š

### ğŸ“š æ ¸å¿ƒè¦ç‚¹

1. **backtrader**
   - äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ŒåŠŸèƒ½å¼ºå¤§
   - é€‚åˆå¤æ‚ç­–ç•¥å¼€å‘
   - å­¦ä¹ æ›²çº¿è¾ƒé™¡

2. **vectorbt**
   - å‘é‡åŒ–è®¡ç®—ï¼Œé€Ÿåº¦æå¿«
   - é€‚åˆå‚æ•°ä¼˜åŒ–
   - é€‚åˆç®€å•ç­–ç•¥å¿«é€ŸéªŒè¯

3. **Qlib**
   - AIé‡åŒ–å¹³å°ï¼ŒåŠŸèƒ½æœ€å…¨
   - é›†æˆæ•°æ®ã€å› å­ã€æ¨¡å‹ã€å›æµ‹
   - é€‚åˆæœºå™¨å­¦ä¹ ç­–ç•¥

4. **è‡ªå»ºæ¡†æ¶**
   - å®Œå…¨å¯æ§ï¼Œçµæ´»æ€§æœ€é«˜
   - éœ€è¦æŠ•å…¥è¾ƒå¤šå¼€å‘æ—¶é—´
   - é€‚åˆç‰¹æ®Šéœ€æ±‚

### ğŸ¯ é€‰æ‹©å»ºè®®

| åœºæ™¯ | æ¨èæ¡†æ¶ |
|------|---------|
| å¿«é€ŸéªŒè¯ | vectorbt |
| å¤æ‚ç­–ç•¥ | backtrader |
| AIé‡åŒ– | Qlib |
| ç‰¹æ®Šéœ€æ±‚ | è‡ªå»º |

---

*æœ¬ç« å®Œ*
